<!DOCTYPE html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7"><![endif]-->
<!--[if IE 7]><html class="no-js lt-ie9 lt-ie8" <![endif]-->
<!--[if IE 8]><html class="no-js lt-ie9" <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->

<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
       new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
       j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
       'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
       })(window,document,'script','dataLayer','GTM-WP54B9K');</script>
    <!-- End Google Tag Manager -->

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <title>OVS Deep Dive 3: Datapath</title>

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="/assets/img/favicon.ico" />

    <!-- Come and get me RSS readers -->
    <link rel="alternate" type="application/rss+xml" title="ArthurChiao's Blog" href="http://0.0.0.0:4000/feed.xml" />
    
    <!-- Stylesheet -->
    <link rel="stylesheet" href="/assets/css/style.css">
    <!--[if IE 8]><link rel="stylesheet" href="/assets/css/ie.css"><![endif]-->
    <link rel="canonical" href="http://0.0.0.0:4000/blog/ovs-deep-dive-3-datapath/">

    <!-- Modernizr -->
    <script src="/assets/js/modernizr.custom.15390.js" type="text/javascript"></script>

    
</head>


<body>
  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WP54B9K"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->

    <div class="header">
     <div class="container">
         <h1 class="logo"><a href="/">ArthurChiao's Blog</a></h1>
         <nav class="nav-collapse">
             <ul class="noList">
                 
                   
                   
                   <li class="element first  ">
                     <a href="/index.html">Home</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/articles">Articles</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/articles-zh">Articles (中文)</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/categories">Categories</a>
                   </li> 
                 
                   
                   
                   <li class="element   last">
                     <a href="/about">About</a>
                   </li> 
                 
                 <!-- <li> <a href="https://github.com/arthurchiao/reading" target="_blank">Reading</a></li> -->
                 <!-- <li> <a href="https://github.com/arthurchiao/" target="_blank">GitHub</a></li> -->
             </ul>
         </nav>
     </div>
 </div><!-- end .header -->


   <div class="content">
      <div class="container">
         <div class="post">
  
  <h1 class="postTitle">OVS Deep Dive 3: Datapath</h1>
  <p class="meta">2017-01-01 | <span class="time">41</span> Minute Read</p>

  
  
  <h2 id="1-datapath">1. Datapath</h2>
<p>Datapath is the forwarding plane of OVS. Initially, it is implemented as a
kernel module, and kept as small as possible. Apart from the datapath,
other components are implemented in userspace, and have little dependences with
the underlying systems. That means, porting ovs to another OS or platform is
simple (in concept): just porting or
re-implement the
kernel part to the target OS or platform. As an example of this, ovs-dpdk is
just an effort to run OVS over Intel <a href="dpdk.org">DPDK</a>. For those who do, there
is an official <a href="https://github.com/openvswitch/ovs/blob/master/Documentation/topics/porting.rst">porting guide</a>
for porting OVS to other platforms.</p>

<p>In fact, in recent versions (I’m not sure since which version, but according to
my tests, 2.3+ support this) of OVS, there are already two type of datapath that
you could choose from: <strong>kernel datapath and userspace datapath</strong>.</p>

<p align="center"><img src="/assets/img/ovs-deep-dive/dpif_providers.png" width="75%" height="75%" /></p>
<p align="center">Fig.1.1 Two Types of Datapaths</p>

<p>Reference [5], which discusses OVS hardware offloading, reveals even more
datapath types (enterprise solution). In this article, we only focus on kernel
datapath and userspace datapath, which are provided in stock openvswitch.</p>

<p><strong>Open vSwitch supports different datapaths on different platforms[6]:</strong></p>

<ul>
  <li>
    <p><strong>Linux upstream</strong></p>

    <p>The datapath implemented by the kernel module shipped with
  Linux upstream.  Since features have been gradually introduced into the kernel,
  the table mentions the first Linux release whose OVS module supports the
  feature.</p>
  </li>
  <li>
    <p><strong>Linux OVS tree</strong></p>

    <p>The datapath implemented by the Linux kernel module
  distributed with the OVS source tree. Some features of this module rely on
  functionality not available in older kernels: in this case the minumum Linux
  version (against which the feature can be compiled) is listed.</p>
  </li>
  <li>
    <p><strong>Userspace</strong></p>

    <p>Also known as DPDK, dpif-netdev or dummy datapath. It is the
  only datapath that works on NetBSD and FreeBSD.</p>
  </li>
  <li>
    <p><strong>Hyper-V</strong></p>

    <p>Also known as the Windows datapath.</p>
  </li>
</ul>

<h3 id="11-kernel-datapath">1.1 Kernel Datapath</h3>

<p>Here we only talk about the kernel datapath on Linux platform.</p>

<p>On Linux, kernel datapath is the default datapath type. It needs a kernel module
<code class="highlighter-rouge">openvswitch.ko</code> to be loaded:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>lsmod | <span class="nb">grep </span>openvswitch
openvswitch            98304  3
</code></pre></div></div>

<p>If it is not loaded, you need to install it manually:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>find / <span class="nt">-name</span> openvswitch.ko
/usr/lib/modules/3.10.0-514.2.2.el7.x86_64/kernel/net/openvswitch/openvswitch.ko

<span class="nv">$ </span>modprobe openvswitch.ko
<span class="nv">$ </span>insmod /usr/lib/modules/3.10.0-514.2.2.el7.x86_64/kernel/net/openvswitch/openvswitch.ko
<span class="nv">$ </span>lsmod | <span class="nb">grep </span>openvswitch
</code></pre></div></div>

<p>Creating an OVS bridge:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ovs-vsctl add-br br0

<span class="nv">$ </span>ovs-vsctl show
05daf6f1-da58-4e01-8530-f6ec0d51b4e1
    Bridge br0
        Port br0
            Interface br0
                <span class="nb">type</span>: internal
</code></pre></div></div>

<h3 id="12-userspace-datapath">1.2 Userspace Datapath</h3>

<p>Userspace datapath differs from the traditional datapath in that its packet
forwarding and processing are done in userspace. Among those, <strong>netdev-dpdk</strong>
is one of the implementations, which is supported since OVS 2.4.</p>

<p>Commands for creating an OVS bridge using userspace datapath:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ovs-vsctl add-br br0 <span class="nt">--</span> <span class="nb">set </span>Bridge br0 <span class="nv">datapath_type</span><span class="o">=</span>netdev
</code></pre></div></div>

<p>Note that you must specify the <code class="highlighter-rouge">datapath_type</code> to be <code class="highlighter-rouge">netdev</code> when creating a
bridge, otherwise you will get an error like <strong><em>ovs-vsctl: Error detected while
setting up ‘br0’</em></strong>.</p>

<h3 id="official-doc">Official Doc</h3>
<p>The Open vSwitch kernel module allows flexible userspace control over
flow-level packet processing on selected network devices.  It can be used to
implement a plain Ethernet switch, network device bonding, VLAN processing,
network access control, flow-based network control, and so on.</p>

<p>The kernel module implements multiple <strong><em>datapaths</em></strong> (analogous to bridges), each
of which can have multiple <strong><em>vports</em></strong> (analogous to ports within a bridge).  Each
datapath also has associated with it a <strong><em>flow table</em></strong> that userspace populates
with <strong><em>flows</em></strong> that map from keys based on packet headers and metadata to sets of
actions.  The most common action forwards the packet to another vport; other
actions are also implemented.</p>

<p>When a packet arrives on a vport, the kernel module processes it by extracting
its flow key and looking it up in the flow table.  If there is a matching flow,
it executes the associated actions.  If there is no match, it queues the packet
to userspace for processing (as part of its processing, userspace will likely
set up a flow to handle further packets of the same type entirely in-kernel).</p>

<h2 id="2-key-data-structures">2. Key Data Structures</h2>

<p>Some key data structures in kernel module:</p>

<ul>
  <li><code class="highlighter-rouge">datapath</code> - flow-based packet forwarding/swithcing module</li>
  <li><code class="highlighter-rouge">flow</code></li>
  <li><code class="highlighter-rouge">flow_table</code></li>
  <li><code class="highlighter-rouge">sw_flow_key</code></li>
  <li><code class="highlighter-rouge">vport</code></li>
</ul>

<h3 id="21-datapath">2.1 Datapath</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/** struct datapath - datapath for flow-based packet switching */</span>
<span class="k">struct</span> <span class="n">datapath</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list_node</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">flow_table</span> <span class="n">table</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">ports</span><span class="p">;</span> <span class="cm">/* Switch ports. */</span>
	<span class="k">struct</span> <span class="n">dp_stats_percpu</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">stats_percpu</span><span class="p">;</span>
	<span class="n">possible_net_t</span> <span class="n">net</span><span class="p">;</span> <span class="cm">/* Network namespace ref. */</span>

	<span class="n">u32</span> <span class="n">user_features</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">max_headroom</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="22-flow">2.2 Flow</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">sw_flow</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">node</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
		<span class="n">u32</span> <span class="n">hash</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">flow_table</span><span class="p">,</span> <span class="n">ufid_table</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">stats_last_writer</span><span class="p">;</span>		<span class="cm">/* NUMA-node id of the last writer on * 'stats[0]'.  */</span>
	<span class="k">struct</span> <span class="n">sw_flow_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sw_flow_id</span> <span class="n">id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sw_flow_mask</span> <span class="o">*</span><span class="n">mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sw_flow_actions</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">sf_acts</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">flow_stats</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">stats</span><span class="p">[];</span> <span class="cm">/* One for each NUMA node.  First one
					   * is allocated at flow creation time,
					   * the rest are allocated on demand
					   * while holding the 'stats[0].lock'.
					   */</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="23-flow-table">2.3 Flow Table</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">table_instance</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">flex_array</span> <span class="o">*</span><span class="n">buckets</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_buckets</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node_ver</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hash_seed</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">keep_flows</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">flow_table</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">table_instance</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">ti</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">table_instance</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">ufid_ti</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mask_cache_entry</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">mask_cache</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mask_array</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">mask_array</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_rehash</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ufid_count</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="24-vport">2.4 vport</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/** struct vport - one port within a datapath */</span>
<span class="k">struct</span> <span class="n">vport</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">datapath</span>	<span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vport_portids</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">upcall_portids</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">port_no</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">hash_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">dp_hash_node</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">vport_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">detach_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="25-xlate">2.5 xlate</h3>

<p>ofproto/ofproto-dpif-xlate.c</p>

<ul>
  <li>xlate_in</li>
  <li>xlate_out</li>
  <li>xbridge</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">xlate_out</span> <span class="p">{</span>
    <span class="k">enum</span> <span class="n">slow_path_reason</span> <span class="n">slow</span><span class="p">;</span> <span class="cm">/* 0 if fast path may be used. */</span>

    <span class="k">struct</span> <span class="n">recirc_refs</span> <span class="n">recircs</span><span class="p">;</span> <span class="cm">/* Recirc action IDs on which references are
                                 * held. */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">xlate_in</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">ofproto_dpif</span> <span class="o">*</span><span class="n">ofproto</span><span class="p">;</span>
    <span class="n">ovs_version_t</span>        <span class="n">tables_version</span><span class="p">;</span>   <span class="cm">/* Lookup in this version. */</span>

    <span class="cm">/* Flow to which the OpenFlow actions apply.  xlate_actions() will modify
     * this flow when actions change header fields. */</span>
    <span class="k">struct</span> <span class="n">flow</span> <span class="n">flow</span><span class="p">;</span>

    <span class="cm">/* Pointer to the original flow received during the upcall. xlate_actions()
     * will never modify this flow. */</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">flow</span> <span class="o">*</span><span class="n">upcall_flow</span><span class="p">;</span>

    <span class="cm">/* The packet corresponding to 'flow', or a null pointer if we are
     * revalidating without a packet to refer to. */</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">dp_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">;</span>

    <span class="cm">/* Should OFPP_NORMAL update the MAC learning table?  Should "learn"
     * actions update the flow table? Should FIN_TIMEOUT change the
     * timeouts? Or should controller action send packet to the controller?
     *
     * We want to update these tables if we are actually processing a packet,
     * or if we are accounting for packets that the datapath has processed, but
     * not if we are just revalidating, or if we want to execute the
     * side-effects later via the xlate cache. */</span>
    <span class="n">bool</span> <span class="n">allow_side_effects</span><span class="p">;</span>

    <span class="cm">/* The rule initiating translation or NULL. If both 'rule' and 'ofpacts'
     * are NULL, xlate_actions() will do the initial rule lookup itself. */</span>
    <span class="k">struct</span> <span class="n">rule_dpif</span> <span class="o">*</span><span class="n">rule</span><span class="p">;</span>

    <span class="cm">/* The actions to translate.  If 'rule' is not NULL, these may be NULL. */</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">ofpact</span> <span class="o">*</span><span class="n">ofpacts</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">ofpacts_len</span><span class="p">;</span>

    <span class="cm">/* Union of the set of TCP flags seen so far in this flow.  (Used only by
     * NXAST_FIN_TIMEOUT.  Set to zero to avoid updating updating rules'
     * timeouts.) */</span>
    <span class="kt">uint16_t</span> <span class="n">tcp_flags</span><span class="p">;</span>

    <span class="cm">/* If nonnull, flow translation calls this function just before executing a
     * resubmit or OFPP_TABLE action.  In addition, disables logging of traces
     * when the recursion depth is exceeded.
     *
     * 'rule' is the rule being submitted into.  It will be null if the
     * resubmit or OFPP_TABLE action didn't find a matching rule.
     *
     * 'indentation' is the resubmit recursion depth at time of invocation,
     * suitable for indenting the output.
     *
     * This is normally null so the client has to set it manually after
     * calling xlate_in_init(). */</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">resubmit_hook</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xlate_in</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rule_dpif</span> <span class="o">*</span><span class="n">rule</span><span class="p">,</span>
                          <span class="kt">int</span> <span class="n">indentation</span><span class="p">);</span>

    <span class="cm">/* If nonnull, flow translation calls this function to report some
     * significant decision, e.g. to explain why OFPP_NORMAL translation
     * dropped a packet.  'indentation' is the resubmit recursion depth at time
     * of invocation, suitable for indenting the output. */</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">report_hook</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xlate_in</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">indentation</span><span class="p">,</span>
                        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">args</span><span class="p">);</span>

    <span class="cm">/* If nonnull, flow translation credits the specified statistics to each
     * rule reached through a resubmit or OFPP_TABLE action.
     *
     * This is normally null so the client has to set it manually after
     * calling xlate_in_init(). */</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">dpif_flow_stats</span> <span class="o">*</span><span class="n">resubmit_stats</span><span class="p">;</span>

    <span class="cm">/* Counters carried over from a pre-existing translation of a related flow.
     * This can occur due to, e.g., the translation of an ARP packet that was
     * generated as the result of outputting to a tunnel port.  In that case,
     * the original flow going to the tunnel is the related flow.  Since the
     * two flows are different, they should not use the same xlate_ctx
     * structure.  However, we still need limit the maximum recursion across
     * the entire translation.
     *
     * These fields are normally set to zero, so the client has to set them
     * manually after calling xlate_in_init().  In that case, they should be
     * copied from the same-named fields in the related flow's xlate_ctx.
     *
     * These fields are really implementation details; the client doesn't care
     * about what they mean.  See the corresponding fields in xlate_ctx for
     * real documentation. */</span>
    <span class="kt">int</span> <span class="n">indentation</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">depth</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">resubmits</span><span class="p">;</span>

    <span class="cm">/* If nonnull, flow translation populates this cache with references to all
     * modules that are affected by translation. This 'xlate_cache' may be
     * passed to xlate_push_stats() to perform the same function as
     * xlate_actions() without the full cost of translation.
     *
     * This is normally null so the client has to set it manually after
     * calling xlate_in_init(). */</span>
    <span class="k">struct</span> <span class="n">xlate_cache</span> <span class="o">*</span><span class="n">xcache</span><span class="p">;</span>

    <span class="cm">/* If nonnull, flow translation puts the resulting datapath actions in this
     * buffer.  If null, flow translation will not produce datapath actions. */</span>
    <span class="k">struct</span> <span class="n">ofpbuf</span> <span class="o">*</span><span class="n">odp_actions</span><span class="p">;</span>

    <span class="cm">/* If nonnull, flow translation populates this with wildcards relevant in
     * translation.  Any fields that were used to calculate the action are set,
     * to allow caching and kernel wildcarding to work.  For example, if the
     * flow lookup involved performing the "normal" action on IPv4 and ARP
     * packets, 'wc' would have the 'in_port' (always set), 'dl_type' (flow
     * match), 'vlan_tci' (normal action), and 'dl_dst' (normal action) fields
     * set. */</span>
    <span class="k">struct</span> <span class="n">flow_wildcards</span> <span class="o">*</span><span class="n">wc</span><span class="p">;</span>

    <span class="cm">/* The frozen state to be resumed, as returned by xlate_lookup(). */</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">frozen_state</span> <span class="o">*</span><span class="n">frozen_state</span><span class="p">;</span>
<span class="p">};</span>

</code></pre></div></div>

<p><code class="highlighter-rouge">lib/dp-packet.h</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Buffer for holding packet data.  A dp_packet is automatically reallocated
 * as necessary if it grows too large for the available memory.
 */</span>
<span class="k">struct</span> <span class="n">dp_packet</span> <span class="p">{</span>
<span class="cp">#ifdef DPDK_NETDEV
</span>    <span class="k">struct</span> <span class="n">rte_mbuf</span> <span class="n">mbuf</span><span class="p">;</span>       <span class="cm">/* DPDK mbuf */</span>
<span class="cp">#else
</span>    <span class="kt">void</span> <span class="o">*</span><span class="n">base_</span><span class="p">;</span>                <span class="cm">/* First byte of allocated space. */</span>
    <span class="kt">uint16_t</span> <span class="n">allocated_</span><span class="p">;</span>        <span class="cm">/* Number of bytes allocated. */</span>
    <span class="kt">uint16_t</span> <span class="n">data_ofs</span><span class="p">;</span>          <span class="cm">/* First byte actually in use. */</span>
    <span class="kt">uint32_t</span> <span class="n">size_</span><span class="p">;</span>             <span class="cm">/* Number of bytes in use. */</span>
    <span class="kt">uint32_t</span> <span class="n">rss_hash</span><span class="p">;</span>          <span class="cm">/* Packet hash. */</span>
    <span class="n">bool</span> <span class="n">rss_hash_valid</span><span class="p">;</span>        <span class="cm">/* Is the 'rss_hash' valid? */</span>
<span class="cp">#endif
</span>    <span class="k">enum</span> <span class="n">dp_packet_source</span> <span class="n">source</span><span class="p">;</span>  <span class="cm">/* Source of memory allocated as 'base'. */</span>
    <span class="kt">uint8_t</span> <span class="n">l2_pad_size</span><span class="p">;</span>           <span class="cm">/* Detected l2 padding size.
                                    * Padding is non-pullable. */</span>
    <span class="kt">uint16_t</span> <span class="n">l2_5_ofs</span><span class="p">;</span>             <span class="cm">/* MPLS label stack offset, or UINT16_MAX */</span>
    <span class="kt">uint16_t</span> <span class="n">l3_ofs</span><span class="p">;</span>               <span class="cm">/* Network-level header offset,
                                    * or UINT16_MAX. */</span>
    <span class="kt">uint16_t</span> <span class="n">l4_ofs</span><span class="p">;</span>               <span class="cm">/* Transport-level header offset,
                                      or UINT16_MAX. */</span>
    <span class="kt">uint32_t</span> <span class="n">cutlen</span><span class="p">;</span>               <span class="cm">/* length in bytes to cut from the end. */</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">pkt_metadata</span> <span class="n">md</span><span class="p">;</span>
        <span class="kt">uint64_t</span> <span class="n">data</span><span class="p">[</span><span class="n">DP_PACKET_CONTEXT_SIZE</span> <span class="o">/</span> <span class="mi">8</span><span class="p">];</span>
    <span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div>

<p>distinguish between vports and the corresponding net_devices they register</p>

<p><code class="highlighter-rouge">lib/netdev.c</code>:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* By default enable one tx and rx queue per netdev. */</span>
<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">n_txq</span> <span class="o">=</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">netdev_class</span><span class="o">-&gt;</span><span class="n">send</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">n_rxq</span> <span class="o">=</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">netdev_class</span><span class="o">-&gt;</span><span class="n">rxq_alloc</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="3-kernel-datapath-implementation">3. Kernel Datapath Implementation</h2>

<p><code class="highlighter-rouge">lib/dpif-netlink.c</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Datapath interface for the openvswitch Linux kernel module. */</span>
<span class="k">struct</span> <span class="n">dpif_netlink</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">dpif</span> <span class="n">dpif</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">dp_ifindex</span><span class="p">;</span>

    <span class="cm">/* Upcall messages. */</span>
    <span class="k">struct</span> <span class="n">fat_rwlock</span> <span class="n">upcall_lock</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">dpif_handler</span> <span class="o">*</span><span class="n">handlers</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">n_handlers</span><span class="p">;</span>           <span class="cm">/* Num of upcall handlers. */</span>
    <span class="kt">int</span> <span class="n">uc_array_size</span><span class="p">;</span>             <span class="cm">/* Size of 'handler-&gt;channels' and */</span>
                                   <span class="cm">/* 'handler-&gt;epoll_events'. */</span>

    <span class="cm">/* Change notification. */</span>
    <span class="k">struct</span> <span class="n">nl_sock</span> <span class="o">*</span><span class="n">port_notifier</span><span class="p">;</span> <span class="cm">/* vport multicast group subscriber. */</span>
    <span class="n">bool</span> <span class="n">refresh_channels</span><span class="p">;</span>
<span class="p">};</span>

</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cm">/* vport (netlink) request to kernel */</span>
<span class="k">struct</span> <span class="n">dpif_netlink_vport</span> <span class="p">{</span>
    <span class="cm">/* Generic Netlink header. */</span>
    <span class="kt">uint8_t</span> <span class="n">cmd</span><span class="p">;</span>

    <span class="cm">/* ovs_vport header. */</span>
    <span class="kt">int</span> <span class="n">dp_ifindex</span><span class="p">;</span>
    <span class="n">odp_port_t</span> <span class="n">port_no</span><span class="p">;</span>                    <span class="cm">/* ODPP_NONE if unknown. */</span>
    <span class="k">enum</span> <span class="n">ovs_vport_type</span> <span class="n">type</span><span class="p">;</span>

    <span class="cm">/* Attributes.
     *
     * The 'stats' member points to 64-bit data that might only be aligned on
     * 32-bit boundaries, so use get_unaligned_u64() to access its values.
     */</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>                      <span class="cm">/* OVS_VPORT_ATTR_NAME. */</span>
    <span class="kt">uint32_t</span> <span class="n">n_upcall_pids</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">upcall_pids</span><span class="p">;</span>           <span class="cm">/* OVS_VPORT_ATTR_UPCALL_PID. */</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">ovs_vport_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">;</span>   <span class="cm">/* OVS_VPORT_ATTR_STATS. */</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">options</span><span class="p">;</span>          <span class="cm">/* OVS_VPORT_ATTR_OPTIONS. */</span>
    <span class="kt">size_t</span> <span class="n">options_len</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span>
<span class="nf">get_vport_type</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dpif_netlink_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">struct</span> <span class="n">vlog_rate_limit</span> <span class="n">rl</span> <span class="o">=</span> <span class="n">VLOG_RATE_LIMIT_INIT</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">OVS_VPORT_TYPE_NETDEV</span><span class="p">:</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span> <span class="o">=</span> <span class="n">netdev_get_type_from_name</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">type</span> <span class="o">?</span> <span class="n">type</span> <span class="o">:</span> <span class="s">"system"</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">case</span> <span class="n">OVS_VPORT_TYPE_INTERNAL</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">"internal"</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">OVS_VPORT_TYPE_GENEVE</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">"geneve"</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">OVS_VPORT_TYPE_GRE</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">"gre"</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">OVS_VPORT_TYPE_VXLAN</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">"vxlan"</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">OVS_VPORT_TYPE_LISP</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">"lisp"</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">OVS_VPORT_TYPE_STT</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">"stt"</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">OVS_VPORT_TYPE_UNSPEC</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">__OVS_VPORT_TYPE_MAX</span><span class="p">:</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">VLOG_WARN_RL</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rl</span><span class="p">,</span> <span class="s">"dp%d: port `%s' has unsupported type %u"</span><span class="p">,</span>
                 <span class="n">vport</span><span class="o">-&gt;</span><span class="n">dp_ifindex</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
    <span class="k">return</span> <span class="s">"unknown"</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">ovs_vport_type</span>
<span class="nf">netdev_to_ovs_vport_type</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">netdev</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span> <span class="o">=</span> <span class="n">netdev_get_type</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="s">"tap"</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="s">"system"</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">OVS_VPORT_TYPE_NETDEV</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="s">"internal"</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">OVS_VPORT_TYPE_INTERNAL</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="s">"stt"</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">OVS_VPORT_TYPE_STT</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="s">"geneve"</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">OVS_VPORT_TYPE_GENEVE</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="s">"gre"</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">OVS_VPORT_TYPE_GRE</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="s">"vxlan"</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">OVS_VPORT_TYPE_VXLAN</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="s">"lisp"</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">OVS_VPORT_TYPE_LISP</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">OVS_VPORT_TYPE_UNSPEC</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* with ethtools */</span>
<span class="n">dpif_netlink_port_add</span><span class="p">();</span>
</code></pre></div></div>

<h2 id="4-userspace-datapath-implementation">4. Userspace Datapath Implementation</h2>

<p>Implemented in <code class="highlighter-rouge">lib/dpif-netdev.c</code>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Datapath based on the network device interface from netdev.h.
 */</span>
<span class="k">struct</span> <span class="n">dp_netdev</span> <span class="p">{</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">dpif_class</span> <span class="o">*</span><span class="k">const</span> <span class="n">class</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">name</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">dpif</span> <span class="o">*</span><span class="n">dpif</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">ovs_refcount</span> <span class="n">ref_cnt</span><span class="p">;</span>
    <span class="n">atomic_flag</span> <span class="n">destroyed</span><span class="p">;</span>

    <span class="cm">/* Ports. */</span>
    <span class="k">struct</span> <span class="n">hmap</span> <span class="n">ports</span><span class="p">;</span>

    <span class="cm">/* upcall */</span>
    <span class="n">upcall_callback</span> <span class="o">*</span><span class="n">upcall_cb</span><span class="p">;</span>  <span class="cm">/* Callback function for executing upcalls. */</span>

    <span class="cm">/* Callback function for notifying the purging of dp flows (during
     * reseting pmd deletion). */</span>
    <span class="n">dp_purge_callback</span> <span class="o">*</span><span class="n">dp_purge_cb</span><span class="p">;</span>

    <span class="cm">/* Stores all 'struct dp_netdev_pmd_thread's. */</span>
    <span class="k">struct</span> <span class="n">cmap</span> <span class="n">poll_threads</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">pmd_cmask</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* A port in a netdev-based datapath. */</span>
<span class="k">struct</span> <span class="n">dp_netdev_port</span> <span class="p">{</span>
    <span class="n">odp_port_t</span> <span class="n">port_no</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">netdev</span> <span class="o">*</span><span class="n">netdev</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">hmap_node</span> <span class="n">node</span><span class="p">;</span>      <span class="cm">/* Node in dp_netdev's 'ports'. */</span>
    <span class="k">struct</span> <span class="n">netdev_saved_flags</span> <span class="o">*</span><span class="n">sf</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">dp_netdev_rxq</span> <span class="o">*</span><span class="n">rxqs</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="n">n_rxq</span><span class="p">;</span>             <span class="cm">/* Number of elements in 'rxq' */</span>
    <span class="n">bool</span> <span class="n">dynamic_txqs</span><span class="p">;</span>          <span class="cm">/* If true XPS will be used. */</span>
    <span class="kt">unsigned</span> <span class="o">*</span><span class="n">txq_used</span><span class="p">;</span>         <span class="cm">/* Number of threads that uses each tx queue. */</span>
    <span class="k">struct</span> <span class="n">ovs_mutex</span> <span class="n">txq_used_mutex</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span>                 <span class="cm">/* Port type as requested by user. */</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">rxq_affinity_list</span><span class="p">;</span>    <span class="cm">/* Requested affinity of rx queues. */</span>
<span class="p">};</span>

<span class="cm">/* 'dp_netdevs' contains both "netdev" and "dummy" dpifs.
 * If the class doesn't match, skip this dpif. */</span>

<span class="cm">/* Interface to netdev-based datapath. */</span>
<span class="k">struct</span> <span class="n">dpif_netdev</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">dpif</span> <span class="n">dpif</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">dp_netdev</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">last_port_seq</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span>
<span class="nf">dpif_netdev_port_open_type</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dpif_class</span> <span class="o">*</span><span class="n">class</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="s">"internal"</span><span class="p">)</span> <span class="o">?</span> <span class="n">type</span>
                  <span class="o">:</span> <span class="n">dpif_netdev_class_is_dummy</span><span class="p">(</span><span class="n">class</span><span class="p">)</span> <span class="o">?</span> <span class="s">"dummy-internal"</span>
                  <span class="o">:</span> <span class="s">"tap"</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* default port: "internal" */</span>
    <span class="n">do_add_port</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">dpif_netdev_port_open_type</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">,</span>
                                                             <span class="s">"internal"</span><span class="p">),</span>
                        <span class="n">ODPP_LOCAL</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="5-vport">5. vport</h2>

<p>types:</p>

<ul>
  <li>
    <p>netdev</p>

    <p>.send = dev_queue_xmit</p>

    <p>dev_queue_xmit(skb) will transmit the packet on a physical network device eventually</p>
  </li>
  <li>
    <p>internal</p>

    <p>.send = internal_dev_recv</p>

    <p>the send method will call <code class="highlighter-rouge">netif_rx(skb)</code> insert the skb into TCP/IP stack, and packet will eventually be transmitted by stack</p>
  </li>
  <li>
    <p>patch</p>

    <p>.send = patch_send()</p>

    <p>the send method will just pass the skb pointer to the peer vport</p>
  </li>
  <li>
    <p>tunnel vports: vxlan, gre, etc</p>

    <p>tunnel xmit method in kernel, e.g. .send = vxlan_xmit for vxlan</p>
  </li>
</ul>

<h2 id="references">References</h2>
<ol>
  <li><a href="https://github.com/openvswitch/ovs/blob/master/Documentation/topics/datapath.rst">OVS Doc: Open vSwitch Datapath Development Guide</a></li>
  <li><a href="https://github.com/openvswitch/ovs/blob/master/Documentation/topics/porting.rst">OVS Doc: Porting Guide</a></li>
  <li><a href="https://bugs.launchpad.net/ubuntu/+source/openvswitch/+bug/1629053">ovs bridge breaking TCP between two virtio net devices when checksum offload on</a></li>
  <li><a href="https://mail.openvswitch.org/pipermail/ovs-dev/2016-August/322058.html">netdev-dpdk: Enable Rx checksum offloading	feature on DPDK physical ports</a></li>
  <li><a href="http://openvswitch.org/support/ovscon2016/7/1450-stringer.pdf">OVS Hardware Offload Discuss Panel</a></li>
  <li>http://openvswitch.org/support/dist-docs-2.5/FAQ.md.txt</li>
</ol>


  <!-- POST NAVIGATION -->
  <div class="postNav clearfix">
     
      <a class="prev" href="/blog/ovs-deep-dive-2/"><span>&laquo;&nbsp;OVS Deep Dive 2: OVSDB</span>
      
    </a>
      
      
      <a class="next" href="/blog/ovs-deep-dive-4-patch-port/"><span>OVS Deep Dive 4: OVS netdev and Patch Port&nbsp;&raquo;</span>
       
      </a>
     
  </div>
</div>


         

      </div>
   </div><!-- end .content -->

   <div class="footer">
   <div class="container">
      <p class="copy">&copy; 2016-2019
      <a href="https://arthurchiao.github.io">Arthur Chiao</a>, Powered by
      <a href="http://jekyllrb.com">Jekyll </a>, Theme originated from
      <a href="https://github.com/brianmaierjr/long-haul"> Long Haul.</a>

      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
      <span id="busuanzi_container_site_pv"> Site visits:
          <span id="busuanzi_value_site_pv"></span>, powered by<a href="http://busuanzi.ibruce.info/"> busuanzi</a>
      </span>

      </p>

      <div class="footer-links"> 
         <ul class="noList"> 
            
            <li><a href="https://www.facebook.com/profile.php?id=100014334455077">
                  <svg id="facebook-square" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M82.667,1H17.335C8.351,1,1,8.351,1,17.336v65.329c0,8.99,7.351,16.335,16.334,16.335h65.332 C91.652,99.001,99,91.655,99,82.665V17.337C99,8.353,91.652,1.001,82.667,1L82.667,1z M84.318,50H68.375v42.875H50V50h-8.855V35.973 H50v-9.11c0-12.378,5.339-19.739,19.894-19.739h16.772V22.3H72.967c-4.066-0.007-4.57,2.12-4.57,6.078l-0.023,7.594H86.75 l-2.431,14.027V50z"></path>
                  </svg>
            </a></li>
            
            
            <li><a href="https://linkedin.com/in/yanan-zhao-7691317b?trk=hp-identity-photo">
                  <svg id="linkedin" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M99.001,19.428c-3.606,1.608-7.48,2.695-11.547,3.184c4.15-2.503,7.338-6.466,8.841-11.189 c-3.885,2.318-8.187,4-12.768,4.908c-3.667-3.931-8.893-6.387-14.676-6.387c-11.104,0-20.107,9.054-20.107,20.223 c0,1.585,0.177,3.128,0.52,4.609c-16.71-0.845-31.525-8.895-41.442-21.131C6.092,16.633,5.1,20.107,5.1,23.813 c0,7.017,3.55,13.208,8.945,16.834c-3.296-0.104-6.397-1.014-9.106-2.529c-0.002,0.085-0.002,0.17-0.002,0.255 c0,9.799,6.931,17.972,16.129,19.831c-1.688,0.463-3.463,0.71-5.297,0.71c-1.296,0-2.555-0.127-3.783-0.363 c2.559,8.034,9.984,13.882,18.782,14.045c-6.881,5.424-15.551,8.657-24.971,8.657c-1.623,0-3.223-0.096-4.796-0.282 c8.898,5.738,19.467,9.087,30.82,9.087c36.982,0,57.206-30.817,57.206-57.543c0-0.877-0.02-1.748-0.059-2.617 C92.896,27.045,96.305,23.482,99.001,19.428z"></path>
                  </svg>
            </a></li>
            
            
            <li><a href="https://github.com/ArthurChiao">
                  <svg id="github" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M50,1C22.938,1,1,22.938,1,50s21.938,49,49,49s49-21.938,49-49S77.062,1,50,1z M79.099,79.099 c-3.782,3.782-8.184,6.75-13.083,8.823c-1.245,0.526-2.509,0.989-3.79,1.387v-7.344c0-3.86-1.324-6.699-3.972-8.517 c1.659-0.16,3.182-0.383,4.57-0.67c1.388-0.287,2.855-0.702,4.402-1.245c1.547-0.543,2.935-1.189,4.163-1.938 c1.228-0.75,2.409-1.723,3.541-2.919s2.082-2.552,2.847-4.067s1.372-3.334,1.818-5.455c0.446-2.121,0.67-4.458,0.67-7.01 c0-4.945-1.611-9.155-4.833-12.633c1.467-3.828,1.308-7.991-0.478-12.489l-1.197-0.143c-0.829-0.096-2.321,0.255-4.474,1.053 c-2.153,0.798-4.57,2.105-7.249,3.924c-3.797-1.053-7.736-1.579-11.82-1.579c-4.115,0-8.039,0.526-11.772,1.579 c-1.69-1.149-3.294-2.097-4.809-2.847c-1.515-0.75-2.727-1.26-3.637-1.532c-0.909-0.271-1.754-0.439-2.536-0.503 c-0.782-0.064-1.284-0.079-1.507-0.048c-0.223,0.031-0.383,0.064-0.478,0.096c-1.787,4.53-1.946,8.694-0.478,12.489 c-3.222,3.477-4.833,7.688-4.833,12.633c0,2.552,0.223,4.889,0.67,7.01c0.447,2.121,1.053,3.94,1.818,5.455 c0.765,1.515,1.715,2.871,2.847,4.067s2.313,2.169,3.541,2.919c1.228,0.751,2.616,1.396,4.163,1.938 c1.547,0.543,3.014,0.957,4.402,1.245c1.388,0.287,2.911,0.511,4.57,0.67c-2.616,1.787-3.924,4.626-3.924,8.517v7.487 c-1.445-0.43-2.869-0.938-4.268-1.53c-4.899-2.073-9.301-5.041-13.083-8.823c-3.782-3.782-6.75-8.184-8.823-13.083 C9.934,60.948,8.847,55.56,8.847,50s1.087-10.948,3.231-16.016c2.073-4.899,5.041-9.301,8.823-13.083s8.184-6.75,13.083-8.823 C39.052,9.934,44.44,8.847,50,8.847s10.948,1.087,16.016,3.231c4.9,2.073,9.301,5.041,13.083,8.823 c3.782,3.782,6.75,8.184,8.823,13.083c2.143,5.069,3.23,10.457,3.23,16.016s-1.087,10.948-3.231,16.016 C85.848,70.915,82.88,75.317,79.099,79.099L79.099,79.099z"></path>
                  </svg>
            </a></li>
             
            
            <li><a href="mailto:arthurchiao@hotmail.com">
                  <svg id="mail" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M50,1C22.938,1,1,22.938,1,50s21.938,49,49,49s49-21.938,49-49S77.062,1,50,1z M25.5,25.5h49 c0.874,0,1.723,0.188,2.502,0.542L50,57.544L22.998,26.041C23.777,25.687,24.626,25.499,25.5,25.5L25.5,25.5z M19.375,68.375v-36.75 c0-0.128,0.005-0.256,0.014-0.383l17.96,20.953L19.587,69.958C19.448,69.447,19.376,68.916,19.375,68.375L19.375,68.375z M74.5,74.5 h-49c-0.541,0-1.072-0.073-1.583-0.212l17.429-17.429L50,66.956l8.653-10.096l17.429,17.429C75.572,74.427,75.041,74.5,74.5,74.5 L74.5,74.5z M80.625,68.375c0,0.541-0.073,1.072-0.211,1.583L62.652,52.195l17.96-20.953c0.008,0.127,0.014,0.255,0.014,0.383 L80.625,68.375L80.625,68.375z"></path>
                  </svg>
            </a></li>
            
         </ul>
      </div>
   </div>
</div><!-- end .footer -->

   <!-- Add jQuery and other scripts -->
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src=""><\/script>')</script>
<script src="/assets/js/dropcap.min.js"></script>
<script src="/assets/js/responsive-nav.min.js"></script>
<script src="/assets/js/scripts.js"></script>


</body>

</html>
