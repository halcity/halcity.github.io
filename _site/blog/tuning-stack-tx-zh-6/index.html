<!DOCTYPE html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7"><![endif]-->
<!--[if IE 7]><html class="no-js lt-ie9 lt-ie8" <![endif]-->
<!--[if IE 8]><html class="no-js lt-ie9" <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->

<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
       new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
       j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
       'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
       })(window,document,'script','dataLayer','GTM-WP54B9K');</script>
    <!-- End Google Tag Manager -->

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <title>[译] Linux网络栈监控和调优：发送数据 6</title>

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="/assets/img/favicon.ico" />

    <!-- Come and get me RSS readers -->
    <link rel="alternate" type="application/rss+xml" title="ArthurChiao's Blog" href="http://0.0.0.0:4000/feed.xml" />
    
    <!-- Stylesheet -->
    <link rel="stylesheet" href="/assets/css/style.css">
    <!--[if IE 8]><link rel="stylesheet" href="/assets/css/ie.css"><![endif]-->
    <link rel="canonical" href="http://0.0.0.0:4000/blog/tuning-stack-tx-zh-6/">

    <!-- Modernizr -->
    <script src="/assets/js/modernizr.custom.15390.js" type="text/javascript"></script>

    
</head>


<body>
  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WP54B9K"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->

    <div class="header">
     <div class="container">
         <h1 class="logo"><a href="/">ArthurChiao's Blog</a></h1>
         <nav class="nav-collapse">
             <ul class="noList">
                 
                   
                   
                   <li class="element first  ">
                     <a href="/index.html">Home</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/articles">Articles</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/articles-zh">Articles (中文)</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/categories">Categories</a>
                   </li> 
                 
                   
                   
                   <li class="element   last">
                     <a href="/about">About</a>
                   </li> 
                 
                 <!-- <li> <a href="https://github.com/arthurchiao/reading" target="_blank">Reading</a></li> -->
                 <!-- <li> <a href="https://github.com/arthurchiao/" target="_blank">GitHub</a></li> -->
             </ul>
         </nav>
     </div>
 </div><!-- end .header -->


   <div class="content">
      <div class="container">
         <div class="post">
  
  <h1 class="postTitle">[译] Linux网络栈监控和调优：发送数据 6</h1>
  <p class="meta">2018-12-17 | <span class="time">38</span> Minute Read</p>

  
  
  <h2 id="8-queuing-disciplines排队规则">8 Queuing Disciplines（排队规则）</h2>

<p>至此，我们需要先查看一些qdisc代码。本文不打算涵盖发送队列的每个选项的具体细节。
如果你对此感兴趣，可以查看<a href="http://lartc.org/howto/index.html">这篇</a>很棒的指南。</p>

<p>我们接下来将查看<strong>通用的数据包调度程序</strong>（generic packet scheduler）是如何工作的
。特别地，我们将研究<code class="highlighter-rouge">qdisc_run_begin</code>、<code class="highlighter-rouge">qdisc_run_end</code>、<code class="highlighter-rouge">__ qdisc_run</code>和
<code class="highlighter-rouge">sch_direct_xmit</code>是如何将数据移动到更靠近驱动程序的地方，以进行发送的。</p>

<p>让我们从<code class="highlighter-rouge">qdisc_run_begin</code>的工作原理开始。</p>

<h3 id="81-qdisc_run_begin-and-qdisc_run_end">8.1 <code class="highlighter-rouge">qdisc_run_begin</code> and <code class="highlighter-rouge">qdisc_run_end</code></h3>

<p>定义在<a href="https://github.com/torvalds/linux/blob/v3.13/include/net/sch_generic.h#L101-L107">include/net/sch_generic.h</a>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">qdisc_run_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">qdisc</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">qdisc_is_running</span><span class="p">(</span><span class="n">qdisc</span><span class="p">))</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">qdisc</span><span class="o">-&gt;</span><span class="n">__state</span> <span class="o">|=</span> <span class="n">__QDISC___STATE_RUNNING</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这个函数很简单：检查qdisc的<code class="highlighter-rouge">__state</code>字段是否设置了<code class="highlighter-rouge">__QDISC___STATE_RUNNING</code>标记
位。如果设置了，直接返回<code class="highlighter-rouge">false</code>；否则，标记位置1，然后返回<code class="highlighter-rouge">true</code>。</p>

<p>类似地， <code class="highlighter-rouge">qdisc_run_end</code>执行相反的操作，将此标记位置0：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">qdisc_run_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">qdisc</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">qdisc</span><span class="o">-&gt;</span><span class="n">__state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">__QDISC___STATE_RUNNING</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>需要注意的是，这两个函数都只是设置标记位，并没有真正处理数据。真正的处理过程是从
<code class="highlighter-rouge">__qdisc_run</code>开始的。</p>

<h3 id="82-__qdisc_run">8.2 <code class="highlighter-rouge">__qdisc_run</code></h3>

<p>这个函数乍看非常简单，甚至让人产生错觉：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">__qdisc_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">quota</span> <span class="o">=</span> <span class="n">weight_p</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">qdisc_restart</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span>
                <span class="cm">/*
                 * Ordered by possible occurrence: Postpone processing if
                 * 1. we've exceeded packet quota
                 * 2. another process needs the CPU;
                 */</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">quota</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">need_resched</span><span class="p">())</span> <span class="p">{</span>
                        <span class="n">__netif_schedule</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
                        <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">qdisc_run_end</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>函数首先获取<code class="highlighter-rouge">weight_p</code>，这个变量通常是通过sysctl设置的，收包路径也会用到。我们稍
后会看到如何调整此值。这个循环做两件事：</p>

<ol>
  <li>在<code class="highlighter-rouge">while</code>循环中调用<code class="highlighter-rouge">qdisc_restart</code>，直到它返回<code class="highlighter-rouge">false</code>（或触发下面的中断）</li>
  <li>判断quota是否小于等于零，或<code class="highlighter-rouge">need_resched()</code>是否返回<code class="highlighter-rouge">true</code>。其中任何一个为真，
将调用<code class="highlighter-rouge">__netif_schedule</code>然后跳出循环</li>
</ol>

<p>注意：用户程序调用<code class="highlighter-rouge">sendmsg</code>系统调用之后，<strong>内核便接管了执行过程，一路执行到这里;
用户程序一直在累积系统时间（system time）</strong>。如果用户程序在内核中用完其时间quota
，<code class="highlighter-rouge">need_resched</code>将返回<code class="highlighter-rouge">true</code>。 如果仍有可用quota，且用户程序的时间片尚未使用，则
将再次调用<code class="highlighter-rouge">qdisc_restart</code>。</p>

<p>让我们先来看看<code class="highlighter-rouge">qdisc_restart(q)</code>是如何工作的，然后将深入研究<code class="highlighter-rouge">__netif_schedule(q)</code>。</p>

<h3 id="83-qdisc_restart">8.3 <code class="highlighter-rouge">qdisc_restart</code></h3>

<p><a href="https://github.com/torvalds/linux/blob/v3.13/net/sched/sch_generic.c#L156-L192">qdisc_restart</a>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * NOTE: Called under qdisc_lock(q) with locally disabled BH.
 *
 * __QDISC_STATE_RUNNING guarantees only one CPU can process
 * this qdisc at a time. qdisc_lock(q) serializes queue accesses for
 * this queue.
 *
 *  netif_tx_lock serializes accesses to device driver.
 *
 *  qdisc_lock(q) and netif_tx_lock are mutually exclusive,
 *  if one is grabbed, another must be free.
 *
 * Note, that this procedure can be called by a watchdog timer
 *
 * Returns to the caller:
 *                                0  - queue is empty or throttled.
 *                                &gt;0 - queue is not empty.
 *
 */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">qdisc_restart</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
        <span class="n">spinlock_t</span> <span class="o">*</span><span class="n">root_lock</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

        <span class="cm">/* Dequeue packet */</span>
        <span class="n">skb</span> <span class="o">=</span> <span class="n">dequeue_skb</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">))</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">skb_dst_is_noref</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
        <span class="n">root_lock</span> <span class="o">=</span> <span class="n">qdisc_lock</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
        <span class="n">dev</span> <span class="o">=</span> <span class="n">qdisc_dev</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
        <span class="n">txq</span> <span class="o">=</span> <span class="n">netdev_get_tx_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb_get_queue_mapping</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>

        <span class="k">return</span> <span class="n">sch_direct_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">txq</span><span class="p">,</span> <span class="n">root_lock</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">qdisc_restart</code>函数开头的注释非常有用，描述了此函数用到的三个锁：</p>

<ol>
  <li><code class="highlighter-rouge">__QDISC_STATE_RUNNING</code>保证了同一时间只有一个CPU可以处理这个qdisc</li>
  <li><code class="highlighter-rouge">qdisc_lock(q)</code>将访问此qdisc的操作顺序化</li>
  <li><code class="highlighter-rouge">netif_tx_lock</code>将访问设备驱动的操作顺序化</li>
</ol>

<p>函数首先通过<code class="highlighter-rouge">dequeue_skb</code>从qdisc中取出下一个要发送的skb。如果队列为空，
<code class="highlighter-rouge">qdisc_restart</code>将返回<code class="highlighter-rouge">false</code>（导致上面<code class="highlighter-rouge">__qdisc_run</code>中的循环退出）。</p>

<p>如果skb不为空，代码将获取qdisc队列锁，然后拿到相关的发送设备<code class="highlighter-rouge">dev</code>和发送队列<code class="highlighter-rouge">txq</code>
，最后带着这些参数调用<code class="highlighter-rouge">sch_direct_xmit</code>。</p>

<p>我们来先看<code class="highlighter-rouge">dequeue_skb</code>，然后再回到<code class="highlighter-rouge">sch_direct_xmit</code>。</p>

<h4 id="831-dequeue_skb">8.3.1 <code class="highlighter-rouge">dequeue_skb</code></h4>

<p>我们来看看定义在 <a href="https://github.com/torvalds/linux/blob/v3.13/net/sched/sch_generic.c#L59-L78">net/sched/sch_generic.c</a>中的<code class="highlighter-rouge">dequeue_skb</code>。</p>

<p>函数首先声明一个<code class="highlighter-rouge">struct sk_buff * </code>类型的局部变量<code class="highlighter-rouge">skb</code>，用这个变量表示接下来要处
理的数据。这个变量后面会依的不同情况而被赋不同的值，最后作为函数的返回值被返回给
调用方。</p>

<p>变量<code class="highlighter-rouge">skb</code>被初始化为qdisc的<code class="highlighter-rouge">gso_skb</code>成员变量（<code class="highlighter-rouge">q-&gt;gso_skb</code>），后者指向之前由于无
法发送而重新入队的数据。</p>

<p>接下来分为两种情况，根据<code class="highlighter-rouge">q-&gt;gso_skb</code>是否为空：</p>

<ol>
  <li>如果不为空，会将之前重新入队的skb出队，作为待处理数据返回</li>
  <li>如果为空，则从要处理的qdisc中取出一个新skb，作为待处理数据返回</li>
</ol>

<p>先看第一种情况，如果<code class="highlighter-rouge">q-&gt;gso_skb</code>不为空：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">dequeue_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">gso_skb</span><span class="p">;</span>
        <span class="k">const</span> <span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">dev_queue</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
                <span class="cm">/* check the reason of requeuing without tx lock first */</span>
                <span class="n">txq</span> <span class="o">=</span> <span class="n">netdev_get_tx_queue</span><span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb_get_queue_mapping</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_xmit_frozen_or_stopped</span><span class="p">(</span><span class="n">txq</span><span class="p">))</span> <span class="p">{</span>
                        <span class="n">q</span><span class="o">-&gt;</span><span class="n">gso_skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                        <span class="n">q</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">qlen</span><span class="o">--</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span>
                        <span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</code></pre></div></div>

<p>代码将检查数据的发送队列是否已停止。如果队列未停止工作，则清除<code class="highlighter-rouge">gso_skb</code>字段，并
将队列长度减1。如果队列停止工作，则数据扔留在gso_skb，但将局部变量<code class="highlighter-rouge">skb</code>置空。</p>

<p>第二种情况，如果<code class="highlighter-rouge">q-&gt;gso_skb</code>为空，即之前没有数据被重新入队：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TCQ_F_ONETXQUEUE</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">netif_xmit_frozen_or_stopped</span><span class="p">(</span><span class="n">txq</span><span class="p">))</span>
                        <span class="n">skb</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>进入另一个tricky的if语句，如果：</p>

<ol>
  <li>qdisc不是单发送队列，或</li>
  <li>发送队列未停止工作</li>
</ol>

<p>则将调用qdisc的<code class="highlighter-rouge">dequeue</code>函数以获取新数据，赋值给局部变量<code class="highlighter-rouge">skb</code>。dequeue的内部实现
依qdisc的实现和功能而有所不同。</p>

<p>该函数最后返回局部变量<code class="highlighter-rouge">skb</code>，这是接下来要处理的数据包。</p>

<h4 id="832-sch_direct_xmit">8.3.2 <code class="highlighter-rouge">sch_direct_xmit</code></h4>

<p>现在来到<code class="highlighter-rouge">sch_direct_xmit</code>（定义在
<a href="https://github.com/torvalds/linux/blob/v3.13/net/sched/sch_generic.c#L109-L154">net/sched/sch_generic.c</a>
），这是将数据向下发送到网络设备的重要参与者。</p>

<p>我们一段一段地看：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Transmit one skb, and handle the return status as required. Holding the
 * __QDISC_STATE_RUNNING bit guarantees that only one CPU can execute this
 * function.
 *
 * Returns to the caller:
 *                                0  - queue is empty or throttled.
 *                                &gt;0 - queue is not empty.
 */</span>
<span class="kt">int</span> <span class="nf">sch_direct_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
                    <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">,</span>
                    <span class="n">spinlock_t</span> <span class="o">*</span><span class="n">root_lock</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>

        <span class="cm">/* And release qdisc */</span>
        <span class="n">spin_unlock</span><span class="p">(</span><span class="n">root_lock</span><span class="p">);</span>

        <span class="n">HARD_TX_LOCK</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">txq</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_xmit_frozen_or_stopped</span><span class="p">(</span><span class="n">txq</span><span class="p">))</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">dev_hard_start_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">txq</span><span class="p">);</span>

        <span class="n">HARD_TX_UNLOCK</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">txq</span><span class="p">);</span>
</code></pre></div></div>

<p>这段代码首先释放qdisc（发送队列）锁，然后获取（设备驱动的）发送锁。注意
<code class="highlighter-rouge">HARD_TX_LOCK</code>这个宏：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define HARD_TX_LOCK(dev, txq, cpu) {                   \
        if ((dev-&gt;features &amp; NETIF_F_LLTX) == 0) {      \
                __netif_tx_lock(txq, cpu);              \
        }                                               \
}
</span></code></pre></div></div>

<p>这个宏检查设备是否设置了<code class="highlighter-rouge">NETIF_F_LLTX</code> flag，这个flag已经弃用，不推荐使用，新设
备驱动程序不应使用此标志。内核中的大多数驱动程序也不使用此标志，因此这个if语句
将为<code class="highlighter-rouge">true</code>，接下来获取此数据的发送队列的锁。</p>

<p>接下来，如果发送队列没有停止，就会调用<code class="highlighter-rouge">dev_hard_start_xmit</code>，并保存其返回值，以
确定发送是否成功。正如我们稍后将看到的，<code class="highlighter-rouge">dev_hard_start_xmit</code>会将数据从Linux内核
的网络设备子系统发送到设备驱动程序。</p>

<p><code class="highlighter-rouge">dev_hard_start_xmit</code>执行之后，（或因发送队列停止而跳过执行），队列的发送锁定就会被释放。</p>

<p>让我们继续：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="n">spin_lock</span><span class="p">(</span><span class="n">root_lock</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dev_xmit_complete</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
                <span class="cm">/* Driver sent out skb successfully or skb was consumed */</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">qdisc_qlen</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">NETDEV_TX_LOCKED</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/* Driver try lock failed */</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">handle_dev_cpu_collision</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">txq</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
</code></pre></div></div>

<p>接下来，再次获取此qdisc的锁，然后通过调用<code class="highlighter-rouge">dev_xmit_complete</code>检查<code class="highlighter-rouge">dev_hard_start_xmit</code>的返回值。</p>

<ol>
  <li>如果<code class="highlighter-rouge">dev_xmit_complete</code>返回<code class="highlighter-rouge">true</code>，数据已成功发送，则将qdisc队列长度设置为返回值，否则</li>
  <li>如果<code class="highlighter-rouge">dev_hard_start_xmit</code>返回的是<code class="highlighter-rouge">NETDEV_TX_LOCKED</code>，调用<code class="highlighter-rouge">handle_dev_cpu_collision</code>来处理锁竞争</li>
</ol>

<p>当驱动程序尝试锁定发送队列并失败时，支持<code class="highlighter-rouge">NETIF_F_LLTX</code>功能的设备可以返回<code class="highlighter-rouge">NETDEV_TX_LOCKED</code>。 
我们稍后会仔细研究<code class="highlighter-rouge">handle_dev_cpu_collision</code>。</p>

<p>现在，让我们继续关注<code class="highlighter-rouge">sch_direct_xmit</code>并查看，以上两种情况都不满足时的情况：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="cm">/* Driver returned NETDEV_TX_BUSY - requeue skb */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">))</span>
                        <span class="n">net_warn_ratelimited</span><span class="p">(</span><span class="s">"BUG %s code %d qlen %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                                             <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">qlen</span><span class="p">);</span>

                <span class="n">ret</span> <span class="o">=</span> <span class="n">dev_requeue_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>如果发送失败，而且不是以上两种情况，那还有第三种可能：由于<code class="highlighter-rouge">NETDEV_TX_BUSY</code>。驱动
程序可以返回<code class="highlighter-rouge">NETDEV_TX_BUSY</code>表示设备或驱动程序“忙”并且数据现在无法发送。在这种情
况下，通过调用<code class="highlighter-rouge">dev_requeue_skb</code>将数据重新入队，等下次继续发送。</p>

<p>最后，函数（可能）调整返回值，然后返回：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">netif_xmit_frozen_or_stopped</span><span class="p">(</span><span class="n">txq</span><span class="p">))</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</code></pre></div></div>

<p>我们来深入地看一下<code class="highlighter-rouge">handle_dev_cpu_collision</code>和<code class="highlighter-rouge">dev_requeue_skb</code>。</p>

<h4 id="833-handle_dev_cpu_collision">8.3.3 <code class="highlighter-rouge">handle_dev_cpu_collision</code></h4>

<p>定义在 <a href="https://github.com/torvalds/linux/blob/v3.13/net/sched/sch_generic.c#L80-L107">net/sched/sch_generic.c</a>，处理两种情况：</p>

<ol>
  <li>发送锁由当前CPU保持</li>
  <li>发送锁由其他CPU保存</li>
</ol>

<p>第一种情况认为是配置问题，打印一条警告。</p>

<p>第二种情况，更新统计计数器<code class="highlighter-rouge">cpu_collision</code>，通过<code class="highlighter-rouge">dev_requeue_skb</code>将数据重新入队
以便稍后发送。回想一下，我们在<code class="highlighter-rouge">dequeue_skb</code>中看到了专门处理重新入队的skb的代码。</p>

<p>代码很简短，可以快速阅读：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">handle_dev_cpu_collision</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
                                           <span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">dev_queue</span><span class="p">,</span>
                                           <span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dev_queue</span><span class="o">-&gt;</span><span class="n">xmit_lock_owner</span> <span class="o">==</span> <span class="n">smp_processor_id</span><span class="p">()))</span> <span class="p">{</span>
                <span class="cm">/*
                 * Same CPU holding the lock. It may be a transient
                 * configuration error, when hard_start_xmit() recurses. We
                 * detect it by checking xmit owner and drop the packet when
                 * deadloop is detected. Return OK to try the next skb.
                 */</span>
                <span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
                <span class="n">net_warn_ratelimited</span><span class="p">(</span><span class="s">"Dead loop on netdevice %s, fix it urgently!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                                     <span class="n">dev_queue</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">qdisc_qlen</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="cm">/*
                 * Another cpu is holding lock, requeue &amp; delay xmits for
                 * some time.
                 */</span>
                <span class="n">__this_cpu_inc</span><span class="p">(</span><span class="n">softnet_data</span><span class="p">.</span><span class="n">cpu_collision</span><span class="p">);</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">dev_requeue_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>接下来看看<code class="highlighter-rouge">dev_requeue_skb</code>做了什么，后面会看到，<code class="highlighter-rouge">sch_direct_xmit</code>会调用它.</p>

<h4 id="834-dev_requeue_skb">8.3.4 <code class="highlighter-rouge">dev_requeue_skb</code></h4>

<p>这个函数很简短，<a href="https://github.com/torvalds/linux/blob/v3.13/net/sched/sch_generic.c#L39-L57">net/sched/sch_generic.c</a>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Modifications to data participating in scheduling must be protected with
 * qdisc_lock(qdisc) spinlock.
 *
 * The idea is the following:
 * - enqueue, dequeue are serialized via qdisc root lock
 * - ingress filtering is also serialized via qdisc root lock
 * - updates to tree and tree walking are only done under the rtnl mutex.
 */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dev_requeue_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">skb_dst_force</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
        <span class="n">q</span><span class="o">-&gt;</span><span class="n">gso_skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
        <span class="n">q</span><span class="o">-&gt;</span><span class="n">qstats</span><span class="p">.</span><span class="n">requeues</span><span class="o">++</span><span class="p">;</span>
        <span class="n">q</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">qlen</span><span class="o">++</span><span class="p">;</span>        <span class="cm">/* it's still part of the queue */</span>
        <span class="n">__netif_schedule</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这个函数做了一些事情：</p>

<ol>
  <li>在skb上强制增加一次引用计数</li>
  <li>将skb添加到qdisc的<code class="highlighter-rouge">gso_skb</code>字段。回想一下，之前我们看到在从qdisc的队列中取出数据之前，在dequeue_skb中检查了该字段</li>
  <li>更新<code class="highlighter-rouge">requque</code>统计计数</li>
  <li>更新队列长度</li>
  <li>调用<code class="highlighter-rouge">__netif_schedule</code></li>
</ol>

<p>简单明了。</p>

<p>接下来我们再回忆一遍我们一步步到达这里的过程，然后检查<code class="highlighter-rouge">__netif_schedule</code>。</p>

<h3 id="84-reminder-while-loop-in-__qdisc_run">8.4 Reminder, while loop in <code class="highlighter-rouge">__qdisc_run</code></h3>

<p>回想一下，我们是在查看<code class="highlighter-rouge">__qdisc_run</code>的时候到达这里的：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">__qdisc_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">quota</span> <span class="o">=</span> <span class="n">weight_p</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">qdisc_restart</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span>
                <span class="cm">/*
                 * Ordered by possible occurrence: Postpone processing if
                 * 1. we've exceeded packet quota
                 * 2. another process needs the CPU;
                 */</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">quota</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">need_resched</span><span class="p">())</span> <span class="p">{</span>
                        <span class="n">__netif_schedule</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
                        <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">qdisc_run_end</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>代码在<code class="highlighter-rouge">while</code>循环中调用<code class="highlighter-rouge">qdisc_restart</code>，循环内部使skb出队，尝试通过
<code class="highlighter-rouge">sch_direct_xmit</code>来发送它们，<code class="highlighter-rouge">sch_direct_xmit</code>调用<code class="highlighter-rouge">dev_hard_start_xmit</code>来向驱动
程序进行实际发送。任何无法发送的skb都将被重新入队，以便在<code class="highlighter-rouge">NET_TX</code> softirq中进行
发送。</p>

<p>发送过程的下一步是查看<code class="highlighter-rouge">dev_hard_start_xmit</code>，了解如何调用驱动程序来发送数据。但
在此之前，我们应该先查看<code class="highlighter-rouge">__netif_schedule</code>以完全理解<code class="highlighter-rouge">__qdisc_run</code>和
<code class="highlighter-rouge">dev_requeue_skb</code>的工作方式。</p>

<h4 id="841-__netif_schedule">8.4.1 <code class="highlighter-rouge">__netif_schedule</code></h4>

<p>现在我们来看<code class="highlighter-rouge">__netif_schedule</code>，
<a href="https://github.com/torvalds/linux/blob/v3.13/net/core/dev.c#L2127-L2146">net/core/dev.c</a>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">__netif_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">__QDISC_STATE_SCHED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
                <span class="n">__netif_reschedule</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__netif_schedule</span><span class="p">);</span>
</code></pre></div></div>

<p>此代码检查qdisc状态中的<code class="highlighter-rouge">__QDISC_STATE_SCHED</code>位，如果为该位为0，会将其置1。如果置
位成功（意味着之前不在<code class="highlighter-rouge">__QDISC_STATE_SCHED</code>状态），代码将调用
<code class="highlighter-rouge">__netif_reschedule</code>，这个函数不长，但做的事情非常重要。让我们来看看：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__netif_reschedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">softnet_data</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

        <span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
        <span class="n">sd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">softnet_data</span><span class="p">);</span>
        <span class="n">q</span><span class="o">-&gt;</span><span class="n">next_sched</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="o">*</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">output_queue_tailp</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
        <span class="n">sd</span><span class="o">-&gt;</span><span class="n">output_queue_tailp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">next_sched</span><span class="p">;</span>
        <span class="n">raise_softirq_irqoff</span><span class="p">(</span><span class="n">NET_TX_SOFTIRQ</span><span class="p">);</span>
        <span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这个函数做了几件事：</p>

<ol>
  <li>保存当前的硬中断（IRQ）状态，并通过调用<code class="highlighter-rouge">local_irq_save</code>禁用IRQ</li>
  <li>获取当前CPU的<code class="highlighter-rouge">struct softnet_data</code>实例</li>
  <li>将qdisc添加到<code class="highlighter-rouge">struct softnet_data</code>实例的output队列中</li>
  <li>触发<code class="highlighter-rouge">NET_TX_SOFTIRQ</code>类型软中断（softirq）</li>
  <li>恢复IRQ状态并重新启用硬中断</li>
</ol>

<p>你可以阅读我们之前关于网络栈接收数据的<a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#linux-network-device-subsystem">文章</a>，了解更多有关<code class="highlighter-rouge">softnet_data</code>初始化的信息。</p>

<p>这个函数中的重要代码是：<code class="highlighter-rouge">raise_softirq_irqoff</code>，它触发<code class="highlighter-rouge">NET_TX_SOFTIRQ</code>类型
softirq。 softirqs及其注册也包含在我们之前的<a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#softirqs">文章
</a>
中。简单来说，你可以认为softirqs是以非常高的优先级在执行的内核线程，并代表内核处
理数据，它们用于网络数据的收发处理（incoming和outgoing）。</p>

<p>正如在<a href="">上一篇</a>文章中看到的，<code class="highlighter-rouge">NET_TX_SOFTIRQ</code> softirq有一个注册的回调函数
<code class="highlighter-rouge">net_tx_action</code>，这意味着有一个内核线程将会执行<code class="highlighter-rouge">net_tx_action</code>。该线程偶尔会被暂
停（pause），<code class="highlighter-rouge">raise_softirq_irqoff</code>会恢复（resume）其执行。让我们看一下
<code class="highlighter-rouge">net_tx_action</code>的作用，以便了解内核如何处理发送数据请求。</p>

<h4 id="842-net_tx_action">8.4.2 <code class="highlighter-rouge">net_tx_action</code></h4>

<p>定义在
<a href="https://github.com/torvalds/linux/blob/v3.13/net/core/dev.c#L3297-L3353">net/core/dev.c</a>
，由两个if组成，分别处理executing CPU的<code class="highlighter-rouge">softnet_data</code>实例的两个queue：</p>

<ol>
  <li>completion queue</li>
  <li>output queue</li>
</ol>

<p>让我们分别来看这两种情况，注意，<strong>这段代码在softirq上下文中作为一个独立的内核线
程执行</strong>。网络栈发送侧的热路径中不适合执行的代码，将被延后（defer），然
后由执行<code class="highlighter-rouge">net_tx_action</code>的线程处理。</p>

<h5 id="843-net_tx_action-completion-queue">8.4.3 net_tx_action completion queue</h5>

<p><code class="highlighter-rouge">softnet_data</code>的completion queue存放等待释放的skb。函数<code class="highlighter-rouge">dev_kfree_skb_irq</code>可以将
skbs添加到队列中以便稍后释放。 设备驱动程序通常使用它来推迟释放消耗的skbs。 驱动
程序想要推迟释放skb而不是直接释放的原因是，释放内存可能需要时间，而且有些代码（如hardirq处理程序）
需要尽可能快的执行并返回。</p>

<p>看一下<code class="highlighter-rouge">net_tx_action</code>第一段代码，该代码处理completion queue中等待释放的skb：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">completion_queue</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">clist</span><span class="p">;</span>

                <span class="n">local_irq_disable</span><span class="p">();</span>
                <span class="n">clist</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">completion_queue</span><span class="p">;</span>
                <span class="n">sd</span><span class="o">-&gt;</span><span class="n">completion_queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                <span class="n">local_irq_enable</span><span class="p">();</span>

                <span class="k">while</span> <span class="p">(</span><span class="n">clist</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">clist</span><span class="p">;</span>
                        <span class="n">clist</span> <span class="o">=</span> <span class="n">clist</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

                        <span class="n">WARN_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">));</span>
                        <span class="n">trace_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">net_tx_action</span><span class="p">);</span>
                        <span class="n">__kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
                <span class="p">}</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>如果completion queue非空，<code class="highlighter-rouge">while</code>循环将遍历这个列表并<code class="highlighter-rouge">__kfree_skb</code>释放每个skb占
用的内存。<strong>牢记，此代码在一个名为softirq的独立“线程”中运行 - 它并没有占用用
户程序的系统时间（system time）</strong>。</p>

<h5 id="844-net_tx_action-output-queue">8.4.4 net_tx_action output queue</h5>

<p>output queue存储待发送skb。如前所述，<code class="highlighter-rouge">__netif_reschedule</code>将数据添加到output
queue中，通常从<code class="highlighter-rouge">__netif_schedule</code>调用过来。目前，<code class="highlighter-rouge">__netif_schedule</code>函数在我们
看到的两个地方被调用：</p>

<ol>
  <li><code class="highlighter-rouge">dev_requeue_skb</code>：正如我们所看到的，如果驱动程序返回<code class="highlighter-rouge">NETDEV_TX_BUSY</code>或者存在
CPU冲突，则可以调用此函数</li>
  <li><code class="highlighter-rouge">__qdisc_run</code>：我们之前也看过这个函数。 一旦超出quota或者需要reschedule，它也
会调用<code class="highlighter-rouge">__netif_schedule</code></li>
</ol>

<p>在任何一种情况下，都会调用<code class="highlighter-rouge">__netif_schedule</code>函数，它会将qdisc添加到softnet_data
的output queue进行处理。 这里将输出队列处理代码拆分为三个块。我们来看看第一块：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">output_queue</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>

                <span class="n">local_irq_disable</span><span class="p">();</span>
                <span class="n">head</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">output_queue</span><span class="p">;</span>
                <span class="n">sd</span><span class="o">-&gt;</span><span class="n">output_queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                <span class="n">sd</span><span class="o">-&gt;</span><span class="n">output_queue_tailp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">output_queue</span><span class="p">;</span>
                <span class="n">local_irq_enable</span><span class="p">();</span>
</code></pre></div></div>

<p>这一段代码仅确保output queue上有qdisc，如果有，则将<code class="highlighter-rouge">head</code>变量指向第一个qdisc，并
更新队尾指针。</p>

<p>接下来，一个<code class="highlighter-rouge">while</code>循环开始遍历qdsics列表：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                <span class="k">while</span> <span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
                        <span class="n">spinlock_t</span> <span class="o">*</span><span class="n">root_lock</span><span class="p">;</span>

                        <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next_sched</span><span class="p">;</span>

                        <span class="n">root_lock</span> <span class="o">=</span> <span class="n">qdisc_lock</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">spin_trylock</span><span class="p">(</span><span class="n">root_lock</span><span class="p">))</span> <span class="p">{</span>
                                <span class="n">smp_mb__before_clear_bit</span><span class="p">();</span>
                                <span class="n">clear_bit</span><span class="p">(</span><span class="n">__QDISC_STATE_SCHED</span><span class="p">,</span>
                                          <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
                                <span class="n">qdisc_run</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
                                <span class="n">spin_unlock</span><span class="p">(</span><span class="n">root_lock</span><span class="p">);</span>
</code></pre></div></div>

<p>上面的代码段拿到qdisc锁<code class="highlighter-rouge">root_lock</code>。<code class="highlighter-rouge">spin_trylock</code>尝试锁定;请注意，这里是有意使
用的spin lock（自旋锁），因为它不会阻塞。如果spin lock已经被别人获得，则
<code class="highlighter-rouge">spin_trylock</code>将立即返回，而不是等待获取。</p>

<p><code class="highlighter-rouge">spin_trylock</code>锁定成功将返回非零值。在这种情况下，qdisc的状态的
<code class="highlighter-rouge">__QDISC_STATE_SCHED</code>位被置0，然后调用qdisc_run，它会再将
<code class="highlighter-rouge">__QDISC___STATE_RUNNING</code>位置1，并开始执行<code class="highlighter-rouge">__qdisc_run</code>。</p>

<p>这里很重要。这里发生的是，我们之前跟下来的处理循环是代表用户进行的，从发送系统调
用开始；现在它再次运行，但是，在softirq上下文中，因为这个qdisc的skb之前没有被发
送出去发。这种区别非常重要，因为它会影响你监控发送大量数据的应用程序的CPU使用情
况。让我以另一种方式陈述：</p>

<ol>
  <li>无论发送完成还是驱动程序返回错误，程序的系统时间都将包括调用驱动程序尝试发送
数据所花费的时间</li>
  <li>如果发送在驱动层不成功（例如因为设备正在忙于发送其他内容），则qdisc将被添加到
output quue并稍后由softirq线程处理。在这种情况下，将会额外花费一些softirq（
<code class="highlighter-rouge">si</code>）时间在发送数据上</li>
</ol>

<p>因此，发送数据所花费的总时间是发送相关（send-related）的<strong>系统调用的系统时间</strong>和
<strong><code class="highlighter-rouge">NET_TX</code>类型softirq时间</strong>的组合。</p>

<p>代码最后释放qdisc锁。</p>

<p>如果上面的<code class="highlighter-rouge">spin_trylock</code>调用失败，则执行以下代码：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__QDISC_STATE_DEACTIVATED</span><span class="p">,</span>
                                              <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span> <span class="p">{</span>
                                        <span class="n">__netif_reschedule</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
                                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                                        <span class="n">smp_mb__before_clear_bit</span><span class="p">();</span>
                                        <span class="n">clear_bit</span><span class="p">(</span><span class="n">__QDISC_STATE_SCHED</span><span class="p">,</span>
                                                  <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
                                <span class="p">}</span>
                        <span class="p">}</span>
                <span class="p">}</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>通过检查qdisc状态的<code class="highlighter-rouge">__QDISC_STATE_DEACTIVATED</code>标记位，处理两种情况：</p>

<ol>
  <li>如果qdisc未停用，调用<code class="highlighter-rouge">__netif_reschedule</code>，这会将qdisc放回到原queue中，稍后会再次尝试获取qdisc锁</li>
  <li>如果qdisc已停用，则确保<code class="highlighter-rouge">__QDISC_STATE_SCHED</code>状态也被清除</li>
</ol>

<h3 id="85-最终来到dev_hard_start_xmit">8.5 最终来到<code class="highlighter-rouge">dev_hard_start_xmit</code></h3>

<p>至此，我们已经穿过了整个网络栈，最终来到<code class="highlighter-rouge">dev_hard_start_xmit</code>。也许你是从
<code class="highlighter-rouge">sendmsg</code>系统调用直接到达这里的，或者你是通过qdisc上的softirq线程处理网络数据来
到这里的。<code class="highlighter-rouge">dev_hard_start_xmit</code>将调用设备驱动程序来实际执行发送操作。</p>

<p>这个函数处理两种主要情况：</p>

<ol>
  <li>已经准备好要发送的数据，或</li>
  <li>需要segmentation offloading的数据</li>
</ol>

<p>先看第一种情况，要发送的数据已经准备好的情况。
<a href="https://github.com/torvalds/linux/blob/v3.13/net/core/dev.c#L2541-L2652">net/code/dev.c</a>
：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">dev_hard_start_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
                        <span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="o">*</span><span class="n">ops</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">skb_len</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">;</span>

                <span class="cm">/*
                 * If device doesn't need skb-&gt;dst, release it right now while
                 * its hot in this cpu cache
                 */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">&amp;</span> <span class="n">IFF_XMIT_DST_RELEASE</span><span class="p">)</span>
                        <span class="n">skb_dst_drop</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

                <span class="n">features</span> <span class="o">=</span> <span class="n">netif_skb_features</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
</code></pre></div></div>

<p>代码首先获取设备的回调函数集合<code class="highlighter-rouge">ops</code>，后面让驱动程序做一些发送数据的工作时会用到
。检查<code class="highlighter-rouge">skb-&gt;next</code>以确定此数据不是已分片数据的一部分，然后继续执行以下两项操作：</p>

<p>首先，检查设备是否设置了<code class="highlighter-rouge">IFF_XMIT_DST_RELEASE</code>标志。这个版本的内核中的任何“真实”
以太网设备都不使用此标志，但环回设备和其他一些软件设备使用。如果启用此特性，则可
以减少目标高速缓存条目上的引用计数，因为驱动程序不需要它。</p>

<p>接下来，<code class="highlighter-rouge">netif_skb_features</code>获取设备支持的功能列表，并根据数据的协议类型（
<code class="highlighter-rouge">dev-&gt;protocol</code>）对特性列表进行一些修改。例如，如果设备支持此协议的校验和计算，
则将对skb进行相应的标记。 VLAN tag（如果已设置）也会导致功能标记被修改。</p>

<p>接下来，将检查vlan标记，如果设备无法offload VLAN tag，将通过<code class="highlighter-rouge">__vlan_put_tag</code>在软
件中执行此操作：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                <span class="k">if</span> <span class="p">(</span><span class="n">vlan_tx_tag_present</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                    <span class="o">!</span><span class="n">vlan_hw_offload_capable</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">vlan_proto</span><span class="p">))</span> <span class="p">{</span>
                        <span class="n">skb</span> <span class="o">=</span> <span class="n">__vlan_put_tag</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">vlan_proto</span><span class="p">,</span>
                                             <span class="n">vlan_tx_tag_get</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">))</span>
                                <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

                        <span class="n">skb</span><span class="o">-&gt;</span><span class="n">vlan_tci</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="p">}</span>
</code></pre></div></div>

<p>然后，检查数据以确定这是不是encapsulation （隧道封装）offload请求，例如，
<a href="https://en.wikipedia.org/wiki/Generic_Routing_Encapsulation">GRE</a>。 在这种情况
下，feature flags将被更新，以添加任何特定于设备的硬件封装功能：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                <span class="cm">/* If encapsulation offload request, verify we are testing
                 * hardware encapsulation features instead of standard
                 * features for the netdev
                 */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">encapsulation</span><span class="p">)</span>
                        <span class="n">features</span> <span class="o">&amp;=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_enc_features</span><span class="p">;</span>
</code></pre></div></div>

<p>接下来，<code class="highlighter-rouge">netif_needs_gso</code>用于确定skb是否需要分片。 如果需要，但设备不支持，则
<code class="highlighter-rouge">netif_needs_gso</code>将返回<code class="highlighter-rouge">true</code>，表示分片应在软件中进行。 在这种情况下，调用
<code class="highlighter-rouge">dev_gso_segment</code>进行分片，代码将跳转到gso以发送数据包。我们稍后会看到GSO路径。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                <span class="k">if</span> <span class="p">(</span><span class="n">netif_needs_gso</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">features</span><span class="p">))</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dev_gso_segment</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">features</span><span class="p">)))</span>
                                <span class="k">goto</span> <span class="n">out_kfree_skb</span><span class="p">;</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
                                <span class="k">goto</span> <span class="n">gso</span><span class="p">;</span>
                <span class="p">}</span>
</code></pre></div></div>

<p>如果数据不需要分片，则处理一些其他情况。 首先，数据是否需要顺序化？ 也就是说，如
果数据分布在多个缓冲区中，设备是否支持发送网络数据，还是首先需要将它们组合成单个
有序缓冲区？ 绝大多数网卡不需要在发送之前将数据顺序化，因此在几乎所有情况下，
<code class="highlighter-rouge">skb_needs_linearize</code>将为<code class="highlighter-rouge">false</code>然后被跳过。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                                    <span class="k">else</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">skb_needs_linearize</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">features</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                            <span class="n">__skb_linearize</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
                                <span class="k">goto</span> <span class="n">out_kfree_skb</span><span class="p">;</span>
</code></pre></div></div>

<p>从接下来的一段注释我们可以了解到，下面的代码判断数据包是否仍然需要计算校验和。 如果设备不支持计算校验和，则在这里通过软件计算：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                        <span class="cm">/* If packet is not checksummed and device does not
                         * support checksumming for this protocol, complete
                         * checksumming here.
                         */</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">)</span> <span class="p">{</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">encapsulation</span><span class="p">)</span>
                                        <span class="n">skb_set_inner_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span>
                                                <span class="n">skb_checksum_start_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
                                <span class="k">else</span>
                                        <span class="n">skb_set_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span>
                                                <span class="n">skb_checksum_start_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
                                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_ALL_CSUM</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                                     <span class="n">skb_checksum_help</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
                                        <span class="k">goto</span> <span class="n">out_kfree_skb</span><span class="p">;</span>
                        <span class="p">}</span>
                <span class="p">}</span>
</code></pre></div></div>

<p>再往前，我们来到了packet taps（tap是包过滤器的安插点，例如抓包执行的地方）。回想
一下在<a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#netifreceiveskbcore-special-box-delivers-data-to-packet-taps-and-protocol-layers">接收数据的文章
</a>
中，我们看到了数据包是如何传递给tap（如
<a href="http://www.tcpdump.org/manpages/pcap.3pcap.html">PCAP</a>）的。 该函数中的下一个代
码块将要发送的数据包传递给tap（如果有的话）：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptype_all</span><span class="p">))</span>
                        <span class="n">dev_queue_xmit_nit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
</code></pre></div></div>

<p>最终，调用驱动的<code class="highlighter-rouge">ops</code>里面的发送回调函数<code class="highlighter-rouge">ndo_start_xmit</code>将数据包传给网卡设备：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                <span class="n">skb_len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
                <span class="n">rc</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_start_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

                <span class="n">trace_net_dev_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">skb_len</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">NETDEV_TX_OK</span><span class="p">)</span>
                        <span class="n">txq_trans_update</span><span class="p">(</span><span class="n">txq</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">ndo_start_xmit</code>的返回值表示发送成功与否，并作为这个函数的返回值被返回给更上层。
我们看到了这个返回值将如何影响上层：数据可能会被此时的qdisc重新入队，因此
稍后尝试再次发送。</p>

<p>我们来看看GSO的case。如果此函数的前面部分完成了分片，或者之前已经完成了分片但是
上次发送失败，则会进入下面的代码：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">gso:</span>
        <span class="k">do</span> <span class="p">{</span>
                <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">nskb</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

                <span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">nskb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                <span class="n">nskb</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptype_all</span><span class="p">))</span>
                        <span class="n">dev_queue_xmit_nit</span><span class="p">(</span><span class="n">nskb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

                <span class="n">skb_len</span> <span class="o">=</span> <span class="n">nskb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
                <span class="n">rc</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_start_xmit</span><span class="p">(</span><span class="n">nskb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
                <span class="n">trace_net_dev_xmit</span><span class="p">(</span><span class="n">nskb</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">skb_len</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">NETDEV_TX_OK</span><span class="p">))</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">NETDEV_TX_MASK</span><span class="p">)</span>
                                <span class="k">goto</span> <span class="n">out_kfree_gso_skb</span><span class="p">;</span>
                        <span class="n">nskb</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                        <span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">nskb</span><span class="p">;</span>
                        <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">txq_trans_update</span><span class="p">(</span><span class="n">txq</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">netif_xmit_stopped</span><span class="p">(</span><span class="n">txq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">))</span>
                        <span class="k">return</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
</code></pre></div></div>

<p>你可能已经猜到，此<code class="highlighter-rouge">while</code>循环会遍历分片生成的skb列表。</p>

<p>每个数据包将被：</p>

<ul>
  <li>传给包过滤器（tap，如果有的话）</li>
  <li>通过<code class="highlighter-rouge">ndo_start_xmit</code>传递给驱动程序进行发送</li>
</ul>

<p>设备驱动<code class="highlighter-rouge">ndo_start_xmit()</code>返回错误时，会进行一些错误处理，并将错误返回给更上层。
未发送的skbs可能会被重新入队以便稍后再次发送。</p>

<p>该函数的最后一部分做一些清理工作，在上面发生错误时释放一些资源：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">out_kfree_gso_skb:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">skb</span><span class="o">-&gt;</span><span class="n">destructor</span> <span class="o">=</span> <span class="n">DEV_GSO_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">destructor</span><span class="p">;</span>
                <span class="n">consume_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
        <span class="p">}</span>
<span class="n">out_kfree_skb</span><span class="o">:</span>
        <span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="n">out</span><span class="o">:</span>
        <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dev_hard_start_xmit</span><span class="p">);</span>
</code></pre></div></div>

<p>在继续进入到设备驱动程序之前，先来看一些和前面分析过的代码有关的监控和调优的内容。</p>

<h3 id="86-monitoring-qdiscs">8.6 Monitoring qdiscs</h3>

<h4 id="using-the-tc-command-line-tool">Using the tc command line tool</h4>

<p>使用<code class="highlighter-rouge">tc</code>工具监控qdisc统计：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>tc <span class="nt">-s</span> qdisc show dev eth1
qdisc mq 0: root
 Sent 31973946891907 bytes 2298757402 pkt <span class="o">(</span>dropped 0, overlimits 0 requeues 1776429<span class="o">)</span>
 backlog 0b 0p requeues 1776429
</code></pre></div></div>

<p>网络设备的qdisc统计对于监控系统发送数据包的运行状况至关重要。你可以通过运行命令
行工具tc来查看状态。 上面的示例显示了如何检查eth1的统计信息。</p>

<ul>
  <li><code class="highlighter-rouge">bytes</code>: The number of bytes that were pushed down to the driver for transmit.</li>
  <li><code class="highlighter-rouge">pkt</code>: The number of packets that were pushed down to the driver for transmit.</li>
  <li><code class="highlighter-rouge">dropped</code>: The number of packets that were dropped by the qdisc. This can
happen if transmit queue length is not large enough to fit the data being
queued to it.</li>
  <li><code class="highlighter-rouge">overlimits</code>: Depends on the queuing discipline, but can be either the number
of packets that could not be enqueued due to a limit being hit, and/or the
number of packets which triggered a throttling event when dequeued.</li>
  <li><code class="highlighter-rouge">requeues</code>: Number of times dev_requeue_skb has been called to requeue an skb.
Note that an skb which is requeued multiple times will bump this counter each
time it is requeued.</li>
  <li><code class="highlighter-rouge">backlog</code>: Number of bytes currently on the qdisc’s queue. This number is
usually bumped each time a packet is enqueued.</li>
</ul>

<p>一些qdisc还会导出额外的统计信息。每个qdisc都不同，对同一个counter可能会累积不同
的次数。你需要查看相应qdisc的源代码，弄清楚每个counter是在哪里、什么条件下被更新
的，如果这些数据对你非常重要，那你必须这么谨慎。</p>

<h3 id="87-tuning-qdiscs">8.7 Tuning qdiscs</h3>

<h4 id="调整__qdisc_run处理权重">调整<code class="highlighter-rouge">__qdisc_run</code>处理权重</h4>

<p>你可以调整前面看到的<code class="highlighter-rouge">__qdisc_run</code>循环的权重（上面看到的<code class="highlighter-rouge">quota</code>变量），这将导致
<code class="highlighter-rouge">__netif_schedule</code>更多的被调用执行。 结果将是当前qdisc将被更多的添加到当前CPU的
output_queue，最终会使发包所占的时间变多。</p>

<p>例如：调整所有qdisc的<code class="highlighter-rouge">__qdisc_run</code>权重：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>sysctl <span class="nt">-w</span> net.core.dev_weight<span class="o">=</span>600
</code></pre></div></div>

<h4 id="增加发送队列长度">增加发送队列长度</h4>

<p>每个网络设备都有一个可以修改的txqueuelen。 大多数qdisc在将数据插入到其发送队列之
前，会检查txqueuelen是否足够（表示的是字节数？）。 你可以调整这个参数以增加qdisc
队列的字节数。</p>

<p>Example: increase the <code class="highlighter-rouge">txqueuelen</code> of <code class="highlighter-rouge">eth0</code> to <code class="highlighter-rouge">10000</code>.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>ifconfig eth0 txqueuelen 10000
</code></pre></div></div>

<p>默认值是1000，你可以通过ifconfig命令的输出，查看每个网络设备的txqueuelen。</p>


  <!-- POST NAVIGATION -->
  <div class="postNav clearfix">
     
      <a class="prev" href="/blog/tuning-stack-tx-zh-5/"><span>&laquo;&nbsp;[译] Linux网络栈监控和调优：发送数据 5</span>
      
    </a>
      
      
      <a class="next" href="/blog/tuning-stack-tx-zh-7/"><span>[译] Linux网络栈监控和调优：发送数据 7&nbsp;&raquo;</span>
       
      </a>
     
  </div>
</div>


         

      </div>
   </div><!-- end .content -->

   <div class="footer">
   <div class="container">
      <p class="copy">&copy; 2016-2019
      <a href="https://arthurchiao.github.io">Arthur Chiao</a>, Powered by
      <a href="http://jekyllrb.com">Jekyll </a>, Theme originated from
      <a href="https://github.com/brianmaierjr/long-haul"> Long Haul.</a>

      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
      <span id="busuanzi_container_site_pv"> Site visits:
          <span id="busuanzi_value_site_pv"></span>, powered by<a href="http://busuanzi.ibruce.info/"> busuanzi</a>
      </span>

      </p>

      <div class="footer-links"> 
         <ul class="noList"> 
            
            <li><a href="https://www.facebook.com/profile.php?id=100014334455077">
                  <svg id="facebook-square" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M82.667,1H17.335C8.351,1,1,8.351,1,17.336v65.329c0,8.99,7.351,16.335,16.334,16.335h65.332 C91.652,99.001,99,91.655,99,82.665V17.337C99,8.353,91.652,1.001,82.667,1L82.667,1z M84.318,50H68.375v42.875H50V50h-8.855V35.973 H50v-9.11c0-12.378,5.339-19.739,19.894-19.739h16.772V22.3H72.967c-4.066-0.007-4.57,2.12-4.57,6.078l-0.023,7.594H86.75 l-2.431,14.027V50z"></path>
                  </svg>
            </a></li>
            
            
            <li><a href="https://linkedin.com/in/yanan-zhao-7691317b?trk=hp-identity-photo">
                  <svg id="linkedin" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M99.001,19.428c-3.606,1.608-7.48,2.695-11.547,3.184c4.15-2.503,7.338-6.466,8.841-11.189 c-3.885,2.318-8.187,4-12.768,4.908c-3.667-3.931-8.893-6.387-14.676-6.387c-11.104,0-20.107,9.054-20.107,20.223 c0,1.585,0.177,3.128,0.52,4.609c-16.71-0.845-31.525-8.895-41.442-21.131C6.092,16.633,5.1,20.107,5.1,23.813 c0,7.017,3.55,13.208,8.945,16.834c-3.296-0.104-6.397-1.014-9.106-2.529c-0.002,0.085-0.002,0.17-0.002,0.255 c0,9.799,6.931,17.972,16.129,19.831c-1.688,0.463-3.463,0.71-5.297,0.71c-1.296,0-2.555-0.127-3.783-0.363 c2.559,8.034,9.984,13.882,18.782,14.045c-6.881,5.424-15.551,8.657-24.971,8.657c-1.623,0-3.223-0.096-4.796-0.282 c8.898,5.738,19.467,9.087,30.82,9.087c36.982,0,57.206-30.817,57.206-57.543c0-0.877-0.02-1.748-0.059-2.617 C92.896,27.045,96.305,23.482,99.001,19.428z"></path>
                  </svg>
            </a></li>
            
            
            <li><a href="https://github.com/ArthurChiao">
                  <svg id="github" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M50,1C22.938,1,1,22.938,1,50s21.938,49,49,49s49-21.938,49-49S77.062,1,50,1z M79.099,79.099 c-3.782,3.782-8.184,6.75-13.083,8.823c-1.245,0.526-2.509,0.989-3.79,1.387v-7.344c0-3.86-1.324-6.699-3.972-8.517 c1.659-0.16,3.182-0.383,4.57-0.67c1.388-0.287,2.855-0.702,4.402-1.245c1.547-0.543,2.935-1.189,4.163-1.938 c1.228-0.75,2.409-1.723,3.541-2.919s2.082-2.552,2.847-4.067s1.372-3.334,1.818-5.455c0.446-2.121,0.67-4.458,0.67-7.01 c0-4.945-1.611-9.155-4.833-12.633c1.467-3.828,1.308-7.991-0.478-12.489l-1.197-0.143c-0.829-0.096-2.321,0.255-4.474,1.053 c-2.153,0.798-4.57,2.105-7.249,3.924c-3.797-1.053-7.736-1.579-11.82-1.579c-4.115,0-8.039,0.526-11.772,1.579 c-1.69-1.149-3.294-2.097-4.809-2.847c-1.515-0.75-2.727-1.26-3.637-1.532c-0.909-0.271-1.754-0.439-2.536-0.503 c-0.782-0.064-1.284-0.079-1.507-0.048c-0.223,0.031-0.383,0.064-0.478,0.096c-1.787,4.53-1.946,8.694-0.478,12.489 c-3.222,3.477-4.833,7.688-4.833,12.633c0,2.552,0.223,4.889,0.67,7.01c0.447,2.121,1.053,3.94,1.818,5.455 c0.765,1.515,1.715,2.871,2.847,4.067s2.313,2.169,3.541,2.919c1.228,0.751,2.616,1.396,4.163,1.938 c1.547,0.543,3.014,0.957,4.402,1.245c1.388,0.287,2.911,0.511,4.57,0.67c-2.616,1.787-3.924,4.626-3.924,8.517v7.487 c-1.445-0.43-2.869-0.938-4.268-1.53c-4.899-2.073-9.301-5.041-13.083-8.823c-3.782-3.782-6.75-8.184-8.823-13.083 C9.934,60.948,8.847,55.56,8.847,50s1.087-10.948,3.231-16.016c2.073-4.899,5.041-9.301,8.823-13.083s8.184-6.75,13.083-8.823 C39.052,9.934,44.44,8.847,50,8.847s10.948,1.087,16.016,3.231c4.9,2.073,9.301,5.041,13.083,8.823 c3.782,3.782,6.75,8.184,8.823,13.083c2.143,5.069,3.23,10.457,3.23,16.016s-1.087,10.948-3.231,16.016 C85.848,70.915,82.88,75.317,79.099,79.099L79.099,79.099z"></path>
                  </svg>
            </a></li>
             
            
            <li><a href="mailto:arthurchiao@hotmail.com">
                  <svg id="mail" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M50,1C22.938,1,1,22.938,1,50s21.938,49,49,49s49-21.938,49-49S77.062,1,50,1z M25.5,25.5h49 c0.874,0,1.723,0.188,2.502,0.542L50,57.544L22.998,26.041C23.777,25.687,24.626,25.499,25.5,25.5L25.5,25.5z M19.375,68.375v-36.75 c0-0.128,0.005-0.256,0.014-0.383l17.96,20.953L19.587,69.958C19.448,69.447,19.376,68.916,19.375,68.375L19.375,68.375z M74.5,74.5 h-49c-0.541,0-1.072-0.073-1.583-0.212l17.429-17.429L50,66.956l8.653-10.096l17.429,17.429C75.572,74.427,75.041,74.5,74.5,74.5 L74.5,74.5z M80.625,68.375c0,0.541-0.073,1.072-0.211,1.583L62.652,52.195l17.96-20.953c0.008,0.127,0.014,0.255,0.014,0.383 L80.625,68.375L80.625,68.375z"></path>
                  </svg>
            </a></li>
            
         </ul>
      </div>
   </div>
</div><!-- end .footer -->

   <!-- Add jQuery and other scripts -->
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src=""><\/script>')</script>
<script src="/assets/js/dropcap.min.js"></script>
<script src="/assets/js/responsive-nav.min.js"></script>
<script src="/assets/js/scripts.js"></script>


</body>

</html>
