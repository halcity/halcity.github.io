<!DOCTYPE html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7"><![endif]-->
<!--[if IE 7]><html class="no-js lt-ie9 lt-ie8" <![endif]-->
<!--[if IE 8]><html class="no-js lt-ie9" <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->

<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
       new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
       j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
       'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
       })(window,document,'script','dataLayer','GTM-WP54B9K');</script>
    <!-- End Google Tag Manager -->

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <title>OVS Deep Dive 1: vswitchd</title>

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="/assets/img/favicon.ico" />

    <!-- Come and get me RSS readers -->
    <link rel="alternate" type="application/rss+xml" title="ArthurChiao's Blog" href="http://0.0.0.0:4000/feed.xml" />
    
    <!-- Stylesheet -->
    <link rel="stylesheet" href="/assets/css/style.css">
    <!--[if IE 8]><link rel="stylesheet" href="/assets/css/ie.css"><![endif]-->
    <link rel="canonical" href="http://0.0.0.0:4000/blog/ovs-deep-dive-1-vswitchd/">

    <!-- Modernizr -->
    <script src="/assets/js/modernizr.custom.15390.js" type="text/javascript"></script>

    
</head>


<body>
  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WP54B9K"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->

    <div class="header">
     <div class="container">
         <h1 class="logo"><a href="/">ArthurChiao's Blog</a></h1>
         <nav class="nav-collapse">
             <ul class="noList">
                 
                   
                   
                   <li class="element first  ">
                     <a href="/index.html">Home</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/articles">Articles</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/articles-zh">Articles (中文)</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/categories">Categories</a>
                   </li> 
                 
                   
                   
                   <li class="element   last">
                     <a href="/about">About</a>
                   </li> 
                 
                 <!-- <li> <a href="https://github.com/arthurchiao/reading" target="_blank">Reading</a></li> -->
                 <!-- <li> <a href="https://github.com/arthurchiao/" target="_blank">GitHub</a></li> -->
             </ul>
         </nav>
     </div>
 </div><!-- end .header -->


   <div class="content">
      <div class="container">
         <div class="post">
  
  <h1 class="postTitle">OVS Deep Dive 1: vswitchd</h1>
  <p class="meta">2016-12-31 | <span class="time">54</span> Minute Read</p>

  
  
  <p class="intro"><span class="dropcap">I</span>n this OVS Deep Dive series,
I will walk through the <a href="https://github.com/openvswitch/ovs">Open vSwtich</a>
 source code to look into the core designs
and implementations of OVS. The code is based on
 <span style="font-weight:bold">ovs 2.6.1</span>.
</p>

<h2 id="1-vswitchd-overview">1. vswitchd Overview</h2>
<p align="center"><img src="/assets/img/ovs-deep-dive/ovs_arch.jpg" width="80%" height="80%" /></p>
<p align="center">Fig.1. OVS Architecture (image source NSRC[1])</p>

<p>As depicted in Fig.1, <code class="highlighter-rouge">ovs-vswitchd</code> sits in the key position of OVS, which
needs to interact with OpenFlow controller, OVSDB, and kernel module.</p>

<ol>
  <li>Core components in the system
    <ul>
      <li>communicate with <strong>outside world</strong> using <code class="highlighter-rouge">OpenFlow</code></li>
      <li>communicate with <strong>ovsdb-server</strong> using <code class="highlighter-rouge">OVSDB protocol</code></li>
      <li>communicate with <strong>kernel</strong> over <code class="highlighter-rouge">netlink</code></li>
      <li>communicate with <strong>system</strong> through <code class="highlighter-rouge">netdev</code> abstract interface</li>
    </ul>
  </li>
  <li>Implements mirroring, bonding, and VLANs</li>
  <li>CLI Tools: <code class="highlighter-rouge">ovs-ofctl</code>, <code class="highlighter-rouge">ovs-appctl</code></li>
</ol>

<p>The following diagram reveals more details:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                       +-------------------+
                       |    ovs-vswitchd   |&lt;<span class="nt">--</span><span class="o">&gt;</span>ovsdb-server
                       +-------------------+
                       |      ofproto      |&lt;<span class="nt">--</span><span class="o">&gt;</span>OpenFlow controllers
                       +--------+-+--------+
                       | netdev | | ofproto|
                       +--------+ |provider|
                       | netdev | +--------+
                       |provider|
                       +--------+
</code></pre></div></div>

<p>Here, the <code class="highlighter-rouge">vswitch</code> module is further devided into submodules/libraies:</p>

<ul>
  <li><code class="highlighter-rouge">ovs-vswitchd</code>: <code class="highlighter-rouge">vswitchd</code> daemon</li>
  <li><code class="highlighter-rouge">ofproto</code>: library which abstracts ovs bridge</li>
  <li><code class="highlighter-rouge">ofproto-provider</code>: interface to control an specific kind of OpenFlow switch</li>
  <li><code class="highlighter-rouge">netdev</code>: library which abstracts network devices</li>
  <li><code class="highlighter-rouge">netdev-provider</code>: OS- and hardware-specific interface to network devices</li>
</ul>

<p>We explain these concepts and data structures in following sections.</p>

<h2 id="2-key-data-structures">2. Key Data Structures</h2>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                          _
                         |   +-------------------+
                         |   |    ovs-vswitchd   |&lt;<span class="nt">--</span><span class="o">&gt;</span>ovsdb-server
                         |   +-------------------+
                         |   |      ofproto      |&lt;<span class="nt">--</span><span class="o">&gt;</span>OpenFlow controllers
                         |   +--------+-+--------+  _
                         |   | netdev | |ofproto-|   |
               userspace |   +--------+ |  dpif  |   |
                         |   | netdev | +--------+   |
                         |   |provider| |  dpif  |   |
                         |   +---||---+ +--------+   |
                         |       <span class="o">||</span>     |  dpif  |   | implementation of
                         |       <span class="o">||</span>     |provider|   | ofproto provider
                         |_      <span class="o">||</span>     +---||---+   |
                                 <span class="o">||</span>         <span class="o">||</span>       |
                          _  +---||-----+---||---+   |
                         |   |          |datapath|   |
                  kernel |   |          +--------+  _|
                         |   |                   |
                         |_  +--------||---------+
                                      <span class="o">||</span>
                                   physical
                                      NIC

</code></pre></div></div>
<p align="center">Fig.2.1. OVS Internal Architecture [2]</p>

<p>An OVS bridges manages two types of resources:</p>

<ul>
  <li>the forwarding plane it controls (<code class="highlighter-rouge">datapath</code>)</li>
  <li>the (physical and virtual) network devices attached to it (<code class="highlighter-rouge">netdev</code>)</li>
</ul>

<p>Key data structures:</p>

<ul>
  <li>
    <p>OVS bridge implementation</p>

    <p><code class="highlighter-rouge">ofproto</code>, <code class="highlighter-rouge">ofproto-provider</code></p>
  </li>
  <li>
    <p>for <code class="highlighter-rouge">datapath</code> management</p>

    <p><code class="highlighter-rouge">dpif</code>, <code class="highlighter-rouge">dpif-provider</code></p>
  </li>
  <li>
    <p>for network devices management</p>

    <p><code class="highlighter-rouge">netdev</code>, <code class="highlighter-rouge">netdev-provider</code></p>
  </li>
</ul>

<p>We explain them, respectively.</p>

<h3 id="21-ofproto">2.1 ofproto</h3>

<p><code class="highlighter-rouge">struct ofproto</code> abstracts OpenFlow switches.
An ofproto instance is just an OpenFlow switch (bridge).</p>

<p>Data Structures (<code class="highlighter-rouge">ofproto/ofproto-provider.h</code>):</p>

<ul>
  <li><code class="highlighter-rouge">struct ofproto</code>: represents an OpenFlow switch (ovs bridge),
                  all flow/port operations are done on the ofproto</li>
  <li><code class="highlighter-rouge">struct ofport</code>: represents a port within an ofproto</li>
  <li><code class="highlighter-rouge">struct rule</code>: represents an OpenFlow flow within an ofproto</li>
  <li><code class="highlighter-rouge">struct ofgroup</code>: represents an OpenFlow 1.1+ group within an ofproto</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* An OpenFlow switch. */</span>
<span class="k">struct</span> <span class="n">ofproto</span> <span class="p">{</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">ofproto_class</span> <span class="o">*</span><span class="n">ofproto_class</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span>                 <span class="cm">/* Datapath type. */</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>                 <span class="cm">/* Datapath name. */</span>

    <span class="cm">/* Settings. */</span>
    <span class="kt">uint64_t</span> <span class="n">fallback_dpid</span><span class="p">;</span>     <span class="cm">/* Datapath ID if no better choice found. */</span>
    <span class="kt">uint64_t</span> <span class="n">datapath_id</span><span class="p">;</span>       <span class="cm">/* Datapath ID. */</span>

    <span class="cm">/* Datapath. */</span>
    <span class="k">struct</span> <span class="n">hmap</span> <span class="n">ports</span><span class="p">;</span>          <span class="cm">/* Contains "struct ofport"s. */</span>
    <span class="k">struct</span> <span class="n">simap</span> <span class="n">ofp_requests</span><span class="p">;</span>  <span class="cm">/* OpenFlow port number requests. */</span>
    <span class="kt">uint16_t</span> <span class="n">max_ports</span><span class="p">;</span>         <span class="cm">/* Max possible OpenFlow port num, plus one. */</span>

    <span class="cm">/* Flow tables. */</span>
    <span class="k">struct</span> <span class="n">oftable</span> <span class="o">*</span><span class="n">tables</span><span class="p">;</span>

    <span class="cm">/* Rules indexed on their cookie values, in all flow tables. */</span>

    <span class="cm">/* List of expirable flows, in all flow tables. */</span>

    <span class="cm">/* OpenFlow connections. */</span>

    <span class="cm">/* Groups. */</span>

    <span class="cm">/* Tunnel TLV mapping table. */</span>
<span class="p">};</span>


<span class="cm">/* An OpenFlow port within a "struct ofproto".
 *
 * The port's name is netdev_get_name(port-&gt;netdev).
 */</span>
<span class="k">struct</span> <span class="n">ofport</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">hmap_node</span> <span class="n">hmap_node</span><span class="p">;</span> <span class="cm">/* In struct ofproto's "ports" hmap. */</span>
    <span class="k">struct</span> <span class="n">ofproto</span> <span class="o">*</span><span class="n">ofproto</span><span class="p">;</span>    <span class="cm">/* The ofproto that contains this port. */</span>
    <span class="k">struct</span> <span class="n">netdev</span> <span class="o">*</span><span class="n">netdev</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">ofputil_phy_port</span> <span class="n">pp</span><span class="p">;</span>
    <span class="n">ofp_port_t</span> <span class="n">ofp_port</span><span class="p">;</span>        <span class="cm">/* OpenFlow port number. */</span>
    <span class="kt">uint64_t</span> <span class="n">change_seq</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">created</span><span class="p">;</span>      <span class="cm">/* Time created, in msec. */</span>
    <span class="kt">int</span> <span class="n">mtu</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="22-ofproto-provider">2.2 ofproto-provider</h3>

<p align="center"><img src="/assets/img/ovs-deep-dive/ofproto_providers.png" /></p>
<p align="center">Fig.2.1. OVS Providers</p>

<p><strong>ofproto class structure, to be defined by each ofproto (ovs bridge)
implementation.</strong></p>

<p>An <strong>ofproto provider</strong> is what ofproto uses to directly <strong>monitor and control
an OpenFlow-capable switch</strong>. struct <code class="highlighter-rouge">ofproto_class</code>, in <code class="highlighter-rouge">ofproto/ofproto-provider.h</code>,
defines the interfaces to implement an ofproto provider for new hardware or software.</p>

<p>Open vSwitch has a <strong>built-in ofproto provider</strong> named <strong>ofproto-dpif</strong>, which
is built on top of a library for manipulating datapaths, called <strong>dpif</strong>.
A “datapath” is a simple flow table, one that is only required to support
exact-match flows, that is, flows without wildcards. When a packet arrives on
a network device, the datapath looks for it in this table.  If there is a
match, then it performs the associated actions.  If there is no match, the
datapath passes the packet up to <code class="highlighter-rouge">ofproto-dpif</code>, <strong>which maintains the full
OpenFlow flow table</strong>.  If the packet matches in this flow table, then
ofproto-dpif executes its actions and inserts a new entry into the dpif flow
table.  (Otherwise, ofproto-dpif passes the packet up to ofproto to send the
packet to the OpenFlow controller, if one is configured.)</p>

<p>The “dpif” library in turn delegates much of its functionality to a “dpif
provider”.  Fig.2.1 shows how dpif providers fit into the Open
vSwitch architecture.</p>

<h3 id="23-netdev">2.3 netdev</h3>

<p>The Open vSwitch library, defined in <code class="highlighter-rouge">lib/netdev-provider.h</code>, implemented in
<code class="highlighter-rouge">lib/netdev.c</code>, that <strong>abstracts interacting with
network devices</strong>, that is, Ethernet interfaces.</p>

<p>Every port on a switch must have a corresponding netdev that must minimally
support a few operations, such as the ability to read the netdev’s MTU, get the
number of RX and TX queues.</p>

<p>The netdev library is a thin
layer over “netdev provider” code, explained further below.</p>

<h3 id="24-netdev-provider">2.4 netdev-provider</h3>

<p align="center"><img src="/assets/img/ovs-deep-dive/netdev_providers.png" /></p>
<p align="center">Fig.2.2. netdev providers</p>

<p>A <strong>netdev provider</strong> implements an <strong>OS- and hardware-specific interface to
“network devices”</strong>, e.g. and ethernet device. <strong>Open vSwitch must be able to open
each port on a switch as a netdev</strong>, so you will need to implement a
“netdev provider” that works with your switch hardware and software.</p>

<p>Fig.2.2 depicts the <code class="highlighter-rouge">netdev</code> and <code class="highlighter-rouge">netdev providers</code> in OVS. The detailed
<code class="highlighter-rouge">netdev</code> provider types are listed below:</p>

<p><strong>All types of <code class="highlighter-rouge">netdev</code> classes</strong>:</p>

<ul>
  <li>linux netdev (<code class="highlighter-rouge">lib/netdev-linux.c</code>, for linux platform)
    <ul>
      <li><code class="highlighter-rouge">system</code> - <code class="highlighter-rouge">netdev_linux_class</code></li>
      <li><code class="highlighter-rouge">tap</code> - <code class="highlighter-rouge">netdev_tap_class</code></li>
      <li><code class="highlighter-rouge">internal</code> - <code class="highlighter-rouge">netdev_internal_class</code></li>
    </ul>
  </li>
  <li>bsd netdev (<code class="highlighter-rouge">lib/netdev-bsd.c</code>, for bsd platform)
    <ul>
      <li><code class="highlighter-rouge">system</code> - <code class="highlighter-rouge">netdev_bsd_class</code></li>
      <li><code class="highlighter-rouge">tap</code> - <code class="highlighter-rouge">netdev_tap_class</code></li>
    </ul>
  </li>
  <li>windows netdev (for windows platform)
    <ul>
      <li><code class="highlighter-rouge">system</code> - <code class="highlighter-rouge">netdev_windows_class</code></li>
      <li><code class="highlighter-rouge">internal</code> - <code class="highlighter-rouge">netdev_internal_class</code></li>
    </ul>
  </li>
  <li>dummy netdev (<code class="highlighter-rouge">lib/netdev-dummy.c</code>)
    <ul>
      <li><code class="highlighter-rouge">dummy</code> - <code class="highlighter-rouge">dummy_class</code></li>
      <li><code class="highlighter-rouge">dummy-internal</code> - <code class="highlighter-rouge">dummy_internal_class</code></li>
      <li><code class="highlighter-rouge">dummy-pmd</code> - <code class="highlighter-rouge">dummy_pmd_class</code></li>
    </ul>
  </li>
  <li>vport netdev (<code class="highlighter-rouge">lib/netdev-vport.c</code>, a vport holds a reference to a port in
datapath, the latter could be opened with <code class="highlighter-rouge">netdev_open()</code>)
    <ul>
      <li>tunnel class:
        <ul>
          <li><code class="highlighter-rouge">geneve</code></li>
          <li><code class="highlighter-rouge">gre</code></li>
          <li><code class="highlighter-rouge">vxlan</code></li>
          <li><code class="highlighter-rouge">lisp</code></li>
          <li><code class="highlighter-rouge">stt</code></li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">patch</code> - <code class="highlighter-rouge">patch_class</code></li>
    </ul>
  </li>
  <li>dpdk netdev
    <ul>
      <li><code class="highlighter-rouge">dpdk_class</code></li>
      <li><code class="highlighter-rouge">dpdk_ring_class</code></li>
      <li><code class="highlighter-rouge">dpdk_vhost_class</code></li>
      <li><code class="highlighter-rouge">dpdk_vhost_client_class</code></li>
    </ul>
  </li>
</ul>

<p>For example, the community is experimenting running OVS over DPDK, which
performs high performance packet processing in userspace. In this solution, the
kernel module of OVS will be replaced by the counterparts in DPDK.  That means a
DPDK netdev must be implemented as the <strong>netdev-provider</strong> for this platform. If
you look at the source code, you will see that’s what exactly been doing at
the end of DPDK init code - register it’s netdev provider classes:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">netdev_dpdk_register</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">netdev_register_provider</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dpdk_class</span><span class="p">);</span>
    <span class="n">netdev_register_provider</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dpdk_ring_class</span><span class="p">);</span>
    <span class="n">netdev_register_provider</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dpdk_vhost_class</span><span class="p">);</span>
    <span class="n">netdev_register_provider</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dpdk_vhost_client_class</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The Porting section of the documentation has more information in the
“Writing a netdev Provider” section.</p>

<h2 id="3-call-flows">3. Call Flows</h2>

<p align="center"><img src="/assets/img/ovs-deep-dive/vswitch_flow_diagram.jpg" width="35%" height="35%" /></p>
<p align="center">Fig.3.1 vswitchd flow diagram</p>

<p>Entrypoint of <code class="highlighter-rouge">vswitchd</code> is in <code class="highlighter-rouge">vswitchd/ovs-vswitchd.c</code>.
Logical control diagram of <code class="highlighter-rouge">ovs-vswitchd</code> is depicted in Fig.3.1.</p>

<p>At the start, it initializes the bridge module, which is implemented in
<code class="highlighter-rouge">vswitchd/bridge.c</code>. The bridge module will retrieve some configuration
parameters from ovsdb.</p>

<p>Then, <code class="highlighter-rouge">ovs-vswitchd</code> enters the main loop. In the first iteration of this loop,
it initializes some libraries, include DPDK (if configured), and the most
important, <code class="highlighter-rouge">ofproto</code> library. Note that these resources only init once.</p>

<p>Then, each datapath will do its work by running <code class="highlighter-rouge">ofproto_type_run()</code>, which will
call into the specific <code class="highlighter-rouge">type_run()</code> implementation of that datapath type.</p>

<p>Then, each bridge will do its work by running <code class="highlighter-rouge">ofproto_run()</code>, which will call
into the specific <code class="highlighter-rouge">run()</code> implementation of ofproto class.</p>

<p>Then, <code class="highlighter-rouge">ovs-vswitchd</code> will handle IPC (JSON-RPC) messages, which comes from
command line (<code class="highlighter-rouge">ovs-appctl</code>) and <code class="highlighter-rouge">ovsdb-server</code>.</p>

<p>Then, <code class="highlighter-rouge">netdev_run()</code> is called to process all the various kinds of netdevs.</p>

<p>After all the above work is done, the brige, unixctl server, and netdev modules
will enter blocking state until new signals trigger.</p>

<p>Corresponding psudo-code is shown below:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="cm">/* step.1. init bridge module, obtain configs from ovsdb */</span>
    <span class="n">bridge_init</span><span class="p">();</span>

    <span class="cm">/* step.2. deamon loop */</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">exiting</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* step.2.1. process control messages from OpenFlow Controller and CLI */</span>
        <span class="n">bridge_run</span><span class="p">()</span>
          <span class="o">|</span>
          <span class="o">|--</span><span class="n">dpdk_init</span><span class="p">()</span>
          <span class="o">|--</span><span class="n">bridge_init_ofproto</span><span class="p">()</span> <span class="c1">// init bridges, only once</span>
          <span class="o">|--</span><span class="n">bridge_run__</span><span class="p">()</span>
              <span class="o">|</span>
              <span class="o">|--</span><span class="k">for</span><span class="p">(</span><span class="n">datapath</span> <span class="n">types</span><span class="p">)</span><span class="o">:</span><span class="cm">/* Let each datapath type do the work that it needs to do. */</span>
                     <span class="n">ofproto_type_run</span><span class="p">(</span><span class="n">type</span><span class="p">)</span>
              <span class="o">|--</span><span class="k">for</span><span class="p">(</span><span class="n">all_bridges</span><span class="p">)</span><span class="o">:</span>
                     <span class="n">ofproto_run</span><span class="p">(</span><span class="n">bridge</span><span class="p">)</span> <span class="c1">// handle messages from OpenFlow Controller</span>

        <span class="n">unixctl_server_run</span><span class="p">(</span><span class="n">unixctl</span><span class="p">);</span> <span class="cm">/* receive control messages from CLI (ovs-appctl &lt;xxx&gt;) */</span>
        <span class="n">netdev_run</span><span class="p">();</span> <span class="cm">/* Performs periodic work needed by all the various kinds of netdevs */</span>

        <span class="cm">/* step.2.2. wait events arriving */</span>
        <span class="n">bridge_wait</span><span class="p">();</span>
        <span class="n">unixctl_server_wait</span><span class="p">(</span><span class="n">unixctl</span><span class="p">);</span>
        <span class="n">netdev_wait</span><span class="p">();</span>

        <span class="cm">/* step.2.3. block util events arrive */</span>
        <span class="n">poll_block</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We explain some of the most important procedures in the following.</p>

<h2 id="4-procedures-and-submodules">4. Procedures and Submodules</h2>

<h3 id="41-bridge-module-init">4.1. bridge module init</h3>
<p>Let’s see what the <code class="highlighter-rouge">bridge_init()</code> really does:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Initializes the bridge module, configuring it to obtain its configuration
 * from an OVSDB server accessed over 'remote', which should be a string in a
 * form acceptable to ovsdb_idl_create(). */</span>
<span class="kt">void</span>
<span class="nf">bridge_init</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">remote</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* step.1. Create connection to database. */</span>
    <span class="n">idl</span> <span class="o">=</span> <span class="n">ovsdb_idl_create</span><span class="p">(</span><span class="n">remote</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ovsrec_idl_class</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

    <span class="cm">/* step.2. Register unixctl commands. (ovs-appctl &lt;command&gt;) */</span>
    <span class="n">unixctl_command_register</span><span class="p">(</span><span class="s">"qos/show-types"</span><span class="p">,</span> <span class="s">"interface"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">...</span>
    <span class="n">unixctl_command_register</span><span class="p">(</span><span class="s">"bridge/dump-flows"</span><span class="p">,</span> <span class="s">"bridge"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,)</span>

    <span class="cm">/* step.3. init submodules */</span>
    <span class="n">lacp_init</span><span class="p">();</span> <span class="c1">// register command lacp/show &lt;port&gt;</span>
    <span class="n">bond_init</span><span class="p">();</span> <span class="c1">// register bond commands</span>
    <span class="n">cfm_init</span><span class="p">();</span>
    <span class="n">bfd_init</span><span class="p">();</span>
    <span class="n">ovs_numa_init</span><span class="p">();</span>
    <span class="n">stp_init</span><span class="p">();</span>
    <span class="n">lldp_init</span><span class="p">();</span>
    <span class="n">rstp_init</span><span class="p">();</span>
    <span class="n">ifnotifier</span> <span class="o">=</span> <span class="n">if_notifier_create</span><span class="p">(</span><span class="n">if_change_cb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">ovs-vswitchd</code> first creates a connection to <code class="highlighter-rouge">ovsdb-server</code> using a module
called <strong><em>OVSDB IDL</em></strong>.
<strong><em>IDL</em></strong> is short for <strong>Interface Definition Language</strong>.
The OVSDB IDL maintains an in-memory replica of a database. It issues RPC
requests to an OVSDB database server and parses the responses, converting
raw JSON into data structures that are easier for clients to digest.
There is more explanations about OVSDB IDL in <code class="highlighter-rouge">ovsdb-idl.h</code>.</p>

<p><code class="highlighter-rouge">unixctl_command_register()</code> will register a single unixctl command, which
allow controlling <code class="highlighter-rouge">ovs-vswitchd</code> over CLI. Each submodule 
calls this method to register its subcommands and expose them to the outside.
As we mentioned in the beginning, the command line tool to interact with
vswitchd is <code class="highlighter-rouge">ovs-appctl</code>, so you could verify the those registered commands:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ovs-appctl <span class="nt">--version</span>
ovs-appctl <span class="o">(</span>Open vSwitch<span class="o">)</span> 2.5.0
Compiled Mar 18 2016 15:00:11

<span class="nv">$ </span>ovs-appctl bridge/dump-flows br-int
<span class="nv">duration</span><span class="o">=</span>850872s, <span class="nv">n_packets</span><span class="o">=</span>2828, <span class="nv">n_bytes</span><span class="o">=</span>181182, <span class="nv">priority</span><span class="o">=</span>3,in_port<span class="o">=</span>1,dl_vlan<span class="o">=</span>1003,actions<span class="o">=</span>mod_vlan_vid:1003,NORMAL
<span class="nv">duration</span><span class="o">=</span>868485s, <span class="nv">n_packets</span><span class="o">=</span>3886, <span class="nv">n_bytes</span><span class="o">=</span>222426, <span class="nv">priority</span><span class="o">=</span>1,actions<span class="o">=</span>NORMAL
<span class="nv">table_id</span><span class="o">=</span>23, <span class="nv">duration</span><span class="o">=</span>1019439s, <span class="nv">n_packets</span><span class="o">=</span>0, <span class="nv">n_bytes</span><span class="o">=</span>0, ,actions<span class="o">=</span>drop

<span class="nv">$ </span>ovs-appctl qos/show br-int
QoS not configured on br-int
ovs-appctl: ovs-vswitchd: server returned an error
</code></pre></div></div>

<p>At the end of <code class="highlighter-rouge">bridge_init()</code>, some vswitchd submodules are initialized,
including <strong>LACP, BOND, CFM, BDF, NUMA, STP, LLDP, RSTP</strong>, and <code class="highlighter-rouge">inotifiers</code>.</p>

<p>The internal structure of <code class="highlighter-rouge">ovs-vswitchd</code> is shown in Fig.4.1.</p>

<p align="center"><img src="/assets/img/ovs-deep-dive/vswitchd_2.png" width="65%" height="65%" /></p>
<p align="center">Fig.4.1 vswitchd internal modules</p>

<h3 id="42-ofproto-library-init">4.2. ofproto library init</h3>

<p>ofproto maintains a registered ofproto class array <code class="highlighter-rouge">ofproto_classes</code>, in
<code class="highlighter-rouge">ofproto/ofproto.c</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">288</span> <span class="cm">/* All registered ofproto classes, in probe order. */</span>
<span class="mi">289</span> <span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ofproto_class</span> <span class="o">**</span><span class="n">ofproto_classes</span><span class="p">;</span>
<span class="mi">290</span> <span class="k">static</span> <span class="kt">size_t</span> <span class="n">n_ofproto_classes</span><span class="p">;</span>
<span class="mi">291</span> <span class="k">static</span> <span class="kt">size_t</span> <span class="n">allocated_ofproto_classes</span><span class="p">;</span>
</code></pre></div></div>

<p>In <code class="highlighter-rouge">ofproto_init()</code>, the built in ofproto class <code class="highlighter-rouge">ofproto_dpif_class</code> will be
registered, which is defined and implemented in <code class="highlighter-rouge">ofproto/ofproto-dpif.c</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="k">struct</span> <span class="n">ofproto_class</span> <span class="n">ofproto_dpif_class</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">init</span><span class="p">,</span>
    <span class="p">...</span>
    <span class="n">port_alloc</span><span class="p">,</span>
    <span class="n">port_construct</span><span class="p">,</span>
    <span class="n">port_destruct</span><span class="p">,</span>
    <span class="n">port_dealloc</span><span class="p">,</span>
    <span class="n">port_modified</span><span class="p">,</span>
    <span class="n">port_query_by_name</span><span class="p">,</span>
    <span class="n">port_add</span><span class="p">,</span>
    <span class="n">port_del</span><span class="p">,</span>
    <span class="p">...</span>
    <span class="n">ct_flush</span><span class="p">,</span>                   <span class="cm">/* ct_flush */</span>
<span class="p">};</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">init()</code> method of <code class="highlighter-rouge">ofproto_dpif_class</code> will register its unixctl commands:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span>
<span class="nf">init</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">shash</span> <span class="o">*</span><span class="n">iface_hints</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">shash_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

    <span class="cm">/* Make a local copy, since we don't own 'iface_hints' elements. */</span>
    <span class="n">SHASH_FOR_EACH</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">iface_hints</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">const</span> <span class="k">struct</span> <span class="n">iface_hint</span> <span class="o">*</span><span class="n">orig_hint</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">iface_hint</span> <span class="o">*</span><span class="n">new_hint</span> <span class="o">=</span> <span class="n">xmalloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">new_hint</span><span class="p">);</span>

        <span class="n">new_hint</span><span class="o">-&gt;</span><span class="n">br_name</span> <span class="o">=</span> <span class="n">xstrdup</span><span class="p">(</span><span class="n">orig_hint</span><span class="o">-&gt;</span><span class="n">br_name</span><span class="p">);</span>
        <span class="n">new_hint</span><span class="o">-&gt;</span><span class="n">br_type</span> <span class="o">=</span> <span class="n">xstrdup</span><span class="p">(</span><span class="n">orig_hint</span><span class="o">-&gt;</span><span class="n">br_type</span><span class="p">);</span>
        <span class="n">new_hint</span><span class="o">-&gt;</span><span class="n">ofp_port</span> <span class="o">=</span> <span class="n">orig_hint</span><span class="o">-&gt;</span><span class="n">ofp_port</span><span class="p">;</span>

        <span class="n">shash_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_ofp_ports</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">new_hint</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">ofproto_unixctl_init</span><span class="p">();</span> <span class="c1">// register fdb/xxx commands</span>
    <span class="n">udpif_init</span><span class="p">();</span>           <span class="c1">// register upcall/xxx commands</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Let’s test one:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># an ofproto instance is an ovs bridge, so to list all bridges, just issue:</span>
<span class="nv">$ </span>ovs-appctl ofproto/list
br-bond
br-int

<span class="c"># you can also get the bridges info by querying ovsdb directly:</span>
<span class="nv">$ </span>ovs-vsctl show
f9c76d49-891c-4670-b2fc-75aabca7a1a6
    Bridge br-int
        fail_mode: secure
        Port br-int
            Interface br-int
                <span class="nb">type</span>: internal
    Bridge br-bond
        Port br-bond
            Interface br-bond
                <span class="nb">type</span>: internal
    ovs_version: <span class="s2">"2.5.0"</span>
</code></pre></div></div>

<p>Note that <code class="highlighter-rouge">ofproto</code> library only inits once.</p>

<h3 id="43-datapath-processing">4.3. Datapath Processing</h3>

<p style="color: red; font-weight:bold">TODO: this section needs to refine</p>

<p>After <code class="highlighter-rouge">ofproto</code> library is correctly initialized (which means all datapath
types that will be used later have been registered), vswitchd will loop over
the datapath types and let the datapath handle all the things it needs to,
such as, process port changes in this datapath, handle upcall (sending
mis-matched packets to OpenFlow controller). Datapath finishes these
logics by implementing the callback <code class="highlighter-rouge">type_run()</code>.</p>

<p>For <code class="highlighter-rouge">ofproto-dpif</code> - the built in datapath type, the <code class="highlighter-rouge">type_run()</code> is implemented
in <code class="highlighter-rouge">ofproto/ofproto_dpif.c</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span>
<span class="nf">type_run</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">udpif_run</span><span class="p">(</span><span class="n">backer</span><span class="o">-&gt;</span><span class="n">udpif</span><span class="p">);</span>
      <span class="o">|</span>
      <span class="o">|--</span><span class="n">unixctl_command_reply</span><span class="p">()</span> <span class="c1">// handles upcall</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">backer</span><span class="o">-&gt;</span><span class="n">recv_set_enable</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">udpif_set_threads</span><span class="p">(</span><span class="n">backer</span><span class="o">-&gt;</span><span class="n">udpif</span><span class="p">,</span> <span class="n">n_handlers</span><span class="p">,</span> <span class="n">n_revalidators</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">backer</span><span class="o">-&gt;</span><span class="n">need_revalidate</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// revalidate</span>

        <span class="n">udpif_revalidate</span><span class="p">(</span><span class="n">backer</span><span class="o">-&gt;</span><span class="n">udpif</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* Check for and handle port changes dpif. */</span>
    <span class="n">process_dpif_port_changes</span><span class="p">(</span><span class="n">backer</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="44-bridge-processing">4.4. Bridge Processing</h3>

<p style="color: red; font-weight:bold">TODO: this section needs to refine</p>

<p>In each loop, vswitchd also let each bridge handle all its affairs in
<code class="highlighter-rouge">ofproto_run()</code>.  <code class="highlighter-rouge">ofproto_run()</code> is defined in <code class="highlighter-rouge">vswitch/bridge.c</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span>
<span class="nf">ofproto_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">ofproto</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">ofproto_class</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="c1">// calls into ofproto-dpif.c for dpif class</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ofproto_class</span><span class="o">-&gt;</span><span class="n">port_poll</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ofproto_class</span><span class="o">-&gt;</span><span class="n">port_poll</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devname</span><span class="p">))</span> <span class="o">!=</span> <span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">process_port_change</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">devname</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">new_seq</span> <span class="o">!=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">change_seq</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Update OpenFlow port status for any port whose netdev has changed.
         *
         * Refreshing a given 'ofport' can cause an arbitrary ofport to be
         * destroyed, so it's not safe to update ports directly from the
         * HMAP_FOR_EACH loop, or even to use HMAP_FOR_EACH_SAFE.  Instead, we
         * need this two-phase approach. */</span>
        <span class="n">SSET_FOR_EACH</span> <span class="p">(</span><span class="n">devname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devnames</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">update_port</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">devname</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">connmgr_run</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">connmgr</span><span class="p">,</span> <span class="n">handle_openflow</span><span class="p">);</span> <span class="c1">// handles openflow messages</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In the above, the bridge first calls the <code class="highlighter-rouge">run()</code> method of this ofproto class,
to let the ofproto class handle all its class-specific affairs. Then it proceeds
to the handling of port changes and OpenFlow messages.<br />
For <code class="highlighter-rouge">dpif</code>, the <code class="highlighter-rouge">run()</code> method is implemented in <code class="highlighter-rouge">ofproto/ofproto-dpif.c</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span>
<span class="nf">run</span><span class="p">(</span><span class="k">struct</span> <span class="n">ofproto</span> <span class="o">*</span><span class="n">ofproto_</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ofproto</span><span class="o">-&gt;</span><span class="n">netflow</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">netflow_run</span><span class="p">(</span><span class="n">ofproto</span><span class="o">-&gt;</span><span class="n">netflow</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ofproto</span><span class="o">-&gt;</span><span class="n">sflow</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dpif_sflow_run</span><span class="p">(</span><span class="n">ofproto</span><span class="o">-&gt;</span><span class="n">sflow</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ofproto</span><span class="o">-&gt;</span><span class="n">ipfix</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dpif_ipfix_run</span><span class="p">(</span><span class="n">ofproto</span><span class="o">-&gt;</span><span class="n">ipfix</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ofproto</span><span class="o">-&gt;</span><span class="n">change_seq</span> <span class="o">!=</span> <span class="n">new_seq</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">HMAP_FOR_EACH</span> <span class="p">(</span><span class="n">ofport</span><span class="p">,</span> <span class="n">up</span><span class="p">.</span><span class="n">hmap_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ofproto</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">.</span><span class="n">ports</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">port_run</span><span class="p">(</span><span class="n">ofport</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ofproto</span><span class="o">-&gt;</span><span class="n">lacp_enabled</span> <span class="o">||</span> <span class="n">ofproto</span><span class="o">-&gt;</span><span class="n">has_bonded_bundles</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">HMAP_FOR_EACH</span> <span class="p">(</span><span class="n">bundle</span><span class="p">,</span> <span class="n">hmap_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ofproto</span><span class="o">-&gt;</span><span class="n">bundles</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">bundle_run</span><span class="p">(</span><span class="n">bundle</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">stp_run</span><span class="p">(</span><span class="n">ofproto</span><span class="p">);</span>
    <span class="n">rstp_run</span><span class="p">(</span><span class="n">ofproto</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mac_learning_run</span><span class="p">(</span><span class="n">ofproto</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">ofproto</span><span class="o">-&gt;</span><span class="n">backer</span><span class="o">-&gt;</span><span class="n">need_revalidate</span> <span class="o">=</span> <span class="n">REV_MAC_LEARNING</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mcast_snooping_run</span><span class="p">(</span><span class="n">ofproto</span><span class="o">-&gt;</span><span class="n">ms</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">ofproto</span><span class="o">-&gt;</span><span class="n">backer</span><span class="o">-&gt;</span><span class="n">need_revalidate</span> <span class="o">=</span> <span class="n">REV_MCAST_SNOOPING</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ofproto</span><span class="o">-&gt;</span><span class="n">dump_seq</span> <span class="o">!=</span> <span class="n">new_dump_seq</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Expire OpenFlow flows whose idle_timeout or hard_timeout has passed. */</span>
        <span class="n">LIST_FOR_EACH_SAFE</span> <span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">next_rule</span><span class="p">,</span> <span class="n">expirable</span><span class="p">,</span>
                            <span class="o">&amp;</span><span class="n">ofproto</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">.</span><span class="n">expirable</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">rule_expire</span><span class="p">(</span><span class="n">rule_dpif_cast</span><span class="p">(</span><span class="n">rule</span><span class="p">),</span> <span class="n">now</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* All outstanding data in existing flows has been accounted, so it's a
         * good time to do bond rebalancing. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ofproto</span><span class="o">-&gt;</span><span class="n">has_bonded_bundles</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">HMAP_FOR_EACH</span> <span class="p">(</span><span class="n">bundle</span><span class="p">,</span> <span class="n">hmap_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ofproto</span><span class="o">-&gt;</span><span class="n">bundles</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">bundle</span><span class="o">-&gt;</span><span class="n">bond</span><span class="p">)</span>
                    <span class="n">bond_rebalance</span><span class="p">(</span><span class="n">bundle</span><span class="o">-&gt;</span><span class="n">bond</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<h3 id="45-sum-up-bridge_run">4.5 Sum Up: bridge_run()</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">bridge_run</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* step.1. init all needed */</span>
    <span class="n">ovsdb_idl_run</span><span class="p">(</span><span class="n">idl</span><span class="p">);</span> <span class="c1">// handle RPC; sync with remote OVSDB</span>
    <span class="n">if_notifier_run</span><span class="p">();</span> <span class="c1">// TODO: not sure what's doing here</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">cfg</span><span class="p">)</span>
        <span class="n">dpdk_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">other_config</span><span class="p">);</span>

    <span class="cm">/* init ofproto library.  This only runs once */</span>
    <span class="n">bridge_init_ofproto</span><span class="p">(</span><span class="n">cfg</span><span class="p">);</span>
      <span class="o">|</span>
      <span class="o">|--</span><span class="n">ofproto_init</span><span class="p">();</span> <span class="c1">// resiter `ofproto/list` command</span>
           <span class="o">|</span>
           <span class="o">|--</span><span class="n">ofproto_class_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofproto_dpif_class</span><span class="p">)</span> <span class="c1">// register default ofproto class</span>
           <span class="o">|--</span><span class="k">for</span> <span class="p">(</span><span class="n">ofproto</span> <span class="n">classes</span><span class="p">)</span><span class="o">:</span>
                <span class="n">ofproto_classes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">()</span> <span class="c1">// for ofproto_dpif_class, this will call the init() method in ofproto-dpif.c</span>

    <span class="cm">/* step.2. datapath &amp; bridge processing */</span>
    <span class="n">bridge_run__</span><span class="p">();</span>
      <span class="o">|</span>
      <span class="o">|--</span><span class="n">FOR_EACH</span> <span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">types</span><span class="p">)</span> <span class="cm">/* Let each datapath type do the work that it needs to do. */</span>
      <span class="o">|</span>    <span class="n">ofproto_type_run</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
      <span class="o">|</span>
      <span class="o">|--</span><span class="n">FOR_EACH</span> <span class="p">(</span><span class="n">br</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">all_bridges</span><span class="p">)</span> <span class="cm">/* Let each bridge do the work that it needs to do. */</span>
           <span class="n">ofproto_run</span><span class="p">(</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">ofproto</span><span class="p">);</span>
               <span class="o">|</span>
               <span class="o">|--</span><span class="n">ofproto_class</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">()</span>
               <span class="o">|--</span><span class="n">connmgr_run</span><span class="p">(</span><span class="n">connmgr</span><span class="p">,</span> <span class="n">handle_openflow</span><span class="p">)</span> <span class="c1">// handles messages from OpenFlow controller</span>

    <span class="cm">/* step.3. commit to ovsdb if needed */</span>
    <span class="n">ovsdb_idl_txn_commit</span><span class="p">(</span><span class="n">txn</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="46-unixctl-ipc-handling">4.6 Unixctl IPC Handling</h3>
<p>In each loop of <code class="highlighter-rouge">ovs-vswitchd</code>, <code class="highlighter-rouge">unixctl_server_run()</code> will be called once.
In this method, the unixctl server first accepts connctions from IPC clients,
then processes requests from each connection.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">unixctl_server_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">unixctl_server</span> <span class="o">*</span><span class="n">server</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// accept connections</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">pstream_accept</span><span class="p">(</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">listener</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stream</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">conn</span><span class="o">-&gt;</span><span class="n">rpc</span> <span class="o">=</span> <span class="n">jsonrpc_open</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// process requests from each connection</span>
    <span class="n">LIST_FOR_EACH_SAFE</span> <span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">conns</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">run_connection</span><span class="p">(</span><span class="n">conn</span><span class="p">);</span>
          <span class="o">|</span>
          <span class="o">|--</span><span class="n">jsonrpc_run</span><span class="p">()</span>
          <span class="o">|</span>    <span class="o">|--</span><span class="n">stream_send</span><span class="p">()</span>
          <span class="o">|--</span><span class="n">jsonrpc_recv</span><span class="p">(</span><span class="n">conn_rpc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">)</span>
               <span class="o">|--</span><span class="n">assert</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">JSONRPC_REQUEST</span><span class="p">)</span>
               <span class="o">|--</span><span class="n">process_command</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span> <span class="c1">// format the received text to desired output</span>
                    <span class="o">|--</span><span class="n">registerd</span> <span class="n">unixctl</span> <span class="n">command</span> <span class="n">callback</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p style="color: red; font-weight:bold">TODO: add an example</p>

<h3 id="47-netdev-run">4.7. netdev run</h3>
<p>In <code class="highlighter-rouge">netdev_run()</code>, vswitchd <strong>loops over all the network devices, and updates
the <code class="highlighter-rouge">netdev</code> information of any of them changed</strong> (e.g. mtu, src/dst mac).
The netdev processing in each loop is as follows:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Performs periodic work needed by all the various kinds of netdevs.
 *
 * If your program opens any netdevs, it must call this function within its
 * main poll loop. */</span>
<span class="kt">void</span>
<span class="nf">netdev_run</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">netdev_initialize</span><span class="p">();</span>

    <span class="k">struct</span> <span class="n">netdev_registered_class</span> <span class="o">*</span><span class="n">rc</span><span class="p">;</span>
    <span class="n">CMAP_FOR_EACH</span> <span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">cmap_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">netdev_classes</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">)</span>
            <span class="n">rc</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">(</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">struct netdev</code> is a generic abstraction of network devices, defined in
<code class="highlighter-rouge">lib/netdev-provider.h</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* A network device (e.g. an Ethernet device).
 *
 * Network device implementations may read these members but should not modify
 * them. */</span>
<span class="k">struct</span> <span class="n">netdev</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>                         <span class="cm">/* Name of network device. */</span>
    <span class="k">struct</span> <span class="n">netdev_class</span> <span class="o">*</span><span class="n">netdev_class</span><span class="p">;</span> <span class="cm">/* Functions to control this device. */</span>
    <span class="p">...</span>
    <span class="kt">int</span> <span class="n">n_txq</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n_rxq</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ref_cnt</span><span class="p">;</span>                        <span class="cm">/* Times this devices was opened. */</span>
    <span class="k">struct</span> <span class="n">shash_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>            <span class="cm">/* Pointer to element in global map. */</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Each specific type of network device needs to implement the methods in <code class="highlighter-rouge">struct
netdev_class</code>, e.g. there are implementations for BSD, linux, DPDK. These
implementations are in <code class="highlighter-rouge">lib/netdev_xxx.c</code>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">netdev_class</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span> <span class="cm">/* Type of netdevs in this class, e.g. "system", "tap", "gre", etc. */</span>
    <span class="n">bool</span> <span class="n">is_pmd</span><span class="p">;</span>      <span class="cm">/* If 'true' then this netdev should be polled by PMD threads. */</span>

    <span class="cm">/* ## Top-Level Functions ## */</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">run</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">netdev_class</span> <span class="o">*</span><span class="n">netdev_class</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">wait</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">netdev_class</span> <span class="o">*</span><span class="n">netdev_class</span><span class="p">);</span>

    <span class="cm">/* ## netdev Functions ## */</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">construct</span><span class="p">)(</span><span class="k">struct</span> <span class="n">netdev</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destruct</span><span class="p">)(</span><span class="k">struct</span> <span class="n">netdev</span> <span class="o">*</span><span class="p">);</span>

    <span class="p">...</span>

    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">rxq_recv</span><span class="p">)(</span><span class="k">struct</span> <span class="n">netdev_rxq</span> <span class="o">*</span><span class="n">rx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dp_packet_batch</span> <span class="o">*</span><span class="n">batch</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">rxq_wait</span><span class="p">)(</span><span class="k">struct</span> <span class="n">netdev_rxq</span> <span class="o">*</span><span class="n">rx</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">rc-&gt;class-&gt;run(rc-&gt;class)</code> will run into specific implementations, for linux
<code class="highlighter-rouge">netdev</code>s, it will call into <code class="highlighter-rouge">netdev_linux_run()</code> in <code class="highlighter-rouge">lib/netdev_linux.c</code>. And
what it does in the callback is <strong>detecting linux network device changes through
netlink, e.g. mtc, src/dst mac changes, and updates these changes to
corresponding <code class="highlighter-rouge">netdev</code></strong>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span>
<span class="nf">netdev_linux_run</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">netdev_class</span> <span class="o">*</span><span class="n">netdev_class</span> <span class="n">OVS_UNUSED</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">netdev_linux_miimon_enabled</span><span class="p">())</span>
        <span class="n">netdev_linux_miimon_run</span><span class="p">();</span>

    <span class="cm">/* Returns a NETLINK_ROUTE socket listening for RTNLGRP_LINK,
     * RTNLGRP_IPV4_IFADDR and RTNLGRP_IPV6_IFADDR changes */</span>
    <span class="n">sock</span> <span class="o">=</span> <span class="n">netdev_linux_notify_sock</span><span class="p">();</span>

    <span class="k">do</span> <span class="p">{</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">nl_sock_recv</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span> <span class="c1">// receive from kernel space</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">rtnetlink_parse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">change</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">netdev_linux_update</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">change</span><span class="p">);</span>
                  <span class="o">|</span>  <span class="c1">// update netdev changes, e.g. mtu, src/dst mac, etc</span>
                  <span class="o">|-</span> <span class="n">netdev_linux_changed</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="n">ENOBUFS</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">netdev_get_devices</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netdev_linux_class</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device_shash</span><span class="p">);</span>
            <span class="n">SHASH_FOR_EACH</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device_shash</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">get_flags</span><span class="p">(</span><span class="n">netdev_</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
                <span class="n">netdev_linux_changed</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Netlink socket family is a Linux kernel interface used for <strong>IPC
between both the kernel and userspace processes, and between different userspace
processes</strong>. Similarly to the Unix domain sockets, and unlike INET sockets,
Netlink communication cannot traverse host boundaries. However, while the Unix
domain sockets use the file system namespace, Netlink processes are addressed by
process identifiers (PIDs).  Netlink is designed and used for transferring
miscellaneous networking information between the kernel space and userspace
processes[3].</p>

<h2 id="summary">Summary</h2>
<ol>
  <li>
    <p><code class="highlighter-rouge">ovs-vswitchd</code> flow diagram</p>

    <p align="center"><img src="/assets/img/ovs-deep-dive/vswitch_flow_diagram.jpg" width="35%" height="35%" /></p>
    <p align="center">Fig.3.1 vswitchd flow diagram</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">ovs-vswitchd</code> iteraction with other modules</p>

    <p align="center"><img src="/assets/img/ovs-deep-dive/vswitchd_2.png" width="65%" height="65%" /></p>
    <p align="center">Fig.4.1 vswitchd internal modules</p>
  </li>
  <li>
    <p>Implementation terms</p>
    <ul>
      <li><code class="highlighter-rouge">ofproto</code>: ovs bridge</li>
      <li><code class="highlighter-rouge">ofproto provider</code>: interface to manage an specific OpenFlow-capable software/hardware switch</li>
      <li><code class="highlighter-rouge">ofproto-dpif</code> - the built-in ofproto provider implementation in OVS</li>
      <li><code class="highlighter-rouge">dpif</code> - a library servers for <code class="highlighter-rouge">ofproto-dpif</code></li>
      <li><code class="highlighter-rouge">netdev</code> - generic abstraction of network devices</li>
      <li><code class="highlighter-rouge">netdev-provider</code> - interface to OS- and platform-specific network devices</li>
    </ul>
  </li>
</ol>

<h2 id="5-event-loop-wait--block">5. event loop: wait &amp; block</h2>

<h2 id="6-ingress-flow-diagram-todo">6. ingress flow diagram (TODO)</h2>

<h2 id="7-egress-flow-diagram-todo">7. egress flow diagram (TODO)</h2>

<h2 id="references">References</h2>
<ol>
  <li><a href="https://www.google.com.hk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=8&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwiy6sCB_pXRAhWKnpQKHblDC2wQFgg-MAc&amp;url=https%3A%2F%2Fnsrc.org%2Fworkshops%2F2014%2Fnznog-sdn%2Fraw-attachment%2Fwiki%2FAgenda%2FOpenVSwitch.pdf&amp;usg=AFQjCNFg9VULvEmHMXQAsuTOE6XLH6WbzQ&amp;sig2=UlVrLltLct2F_xjgnqZiOA">An OpenVSwitch Introduction From NSRC</a></li>
  <li><a href="https://github.com/openvswitch/ovs/blob/master/Documentation/topics/porting.rst">OVS Doc: Porting Guide</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Netlink">Wikipedia: netlink</a></li>
</ol>


  <!-- POST NAVIGATION -->
  <div class="postNav clearfix">
     
      <a class="prev" href="/blog/ovs-deep-dive-0-overview/"><span>&laquo;&nbsp;OVS Deep Dive 0: Overview</span>
      
    </a>
      
      
      <a class="next" href="/blog/ovs-deep-dive-2/"><span>OVS Deep Dive 2: OVSDB&nbsp;&raquo;</span>
       
      </a>
     
  </div>
</div>


         

      </div>
   </div><!-- end .content -->

   <div class="footer">
   <div class="container">
      <p class="copy">&copy; 2016-2019
      <a href="https://arthurchiao.github.io">Arthur Chiao</a>, Powered by
      <a href="http://jekyllrb.com">Jekyll </a>, Theme originated from
      <a href="https://github.com/brianmaierjr/long-haul"> Long Haul.</a>

      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
      <span id="busuanzi_container_site_pv"> Site visits:
          <span id="busuanzi_value_site_pv"></span>, powered by<a href="http://busuanzi.ibruce.info/"> busuanzi</a>
      </span>

      </p>

      <div class="footer-links"> 
         <ul class="noList"> 
            
            <li><a href="https://www.facebook.com/profile.php?id=100014334455077">
                  <svg id="facebook-square" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M82.667,1H17.335C8.351,1,1,8.351,1,17.336v65.329c0,8.99,7.351,16.335,16.334,16.335h65.332 C91.652,99.001,99,91.655,99,82.665V17.337C99,8.353,91.652,1.001,82.667,1L82.667,1z M84.318,50H68.375v42.875H50V50h-8.855V35.973 H50v-9.11c0-12.378,5.339-19.739,19.894-19.739h16.772V22.3H72.967c-4.066-0.007-4.57,2.12-4.57,6.078l-0.023,7.594H86.75 l-2.431,14.027V50z"></path>
                  </svg>
            </a></li>
            
            
            <li><a href="https://linkedin.com/in/yanan-zhao-7691317b?trk=hp-identity-photo">
                  <svg id="linkedin" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M99.001,19.428c-3.606,1.608-7.48,2.695-11.547,3.184c4.15-2.503,7.338-6.466,8.841-11.189 c-3.885,2.318-8.187,4-12.768,4.908c-3.667-3.931-8.893-6.387-14.676-6.387c-11.104,0-20.107,9.054-20.107,20.223 c0,1.585,0.177,3.128,0.52,4.609c-16.71-0.845-31.525-8.895-41.442-21.131C6.092,16.633,5.1,20.107,5.1,23.813 c0,7.017,3.55,13.208,8.945,16.834c-3.296-0.104-6.397-1.014-9.106-2.529c-0.002,0.085-0.002,0.17-0.002,0.255 c0,9.799,6.931,17.972,16.129,19.831c-1.688,0.463-3.463,0.71-5.297,0.71c-1.296,0-2.555-0.127-3.783-0.363 c2.559,8.034,9.984,13.882,18.782,14.045c-6.881,5.424-15.551,8.657-24.971,8.657c-1.623,0-3.223-0.096-4.796-0.282 c8.898,5.738,19.467,9.087,30.82,9.087c36.982,0,57.206-30.817,57.206-57.543c0-0.877-0.02-1.748-0.059-2.617 C92.896,27.045,96.305,23.482,99.001,19.428z"></path>
                  </svg>
            </a></li>
            
            
            <li><a href="https://github.com/ArthurChiao">
                  <svg id="github" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M50,1C22.938,1,1,22.938,1,50s21.938,49,49,49s49-21.938,49-49S77.062,1,50,1z M79.099,79.099 c-3.782,3.782-8.184,6.75-13.083,8.823c-1.245,0.526-2.509,0.989-3.79,1.387v-7.344c0-3.86-1.324-6.699-3.972-8.517 c1.659-0.16,3.182-0.383,4.57-0.67c1.388-0.287,2.855-0.702,4.402-1.245c1.547-0.543,2.935-1.189,4.163-1.938 c1.228-0.75,2.409-1.723,3.541-2.919s2.082-2.552,2.847-4.067s1.372-3.334,1.818-5.455c0.446-2.121,0.67-4.458,0.67-7.01 c0-4.945-1.611-9.155-4.833-12.633c1.467-3.828,1.308-7.991-0.478-12.489l-1.197-0.143c-0.829-0.096-2.321,0.255-4.474,1.053 c-2.153,0.798-4.57,2.105-7.249,3.924c-3.797-1.053-7.736-1.579-11.82-1.579c-4.115,0-8.039,0.526-11.772,1.579 c-1.69-1.149-3.294-2.097-4.809-2.847c-1.515-0.75-2.727-1.26-3.637-1.532c-0.909-0.271-1.754-0.439-2.536-0.503 c-0.782-0.064-1.284-0.079-1.507-0.048c-0.223,0.031-0.383,0.064-0.478,0.096c-1.787,4.53-1.946,8.694-0.478,12.489 c-3.222,3.477-4.833,7.688-4.833,12.633c0,2.552,0.223,4.889,0.67,7.01c0.447,2.121,1.053,3.94,1.818,5.455 c0.765,1.515,1.715,2.871,2.847,4.067s2.313,2.169,3.541,2.919c1.228,0.751,2.616,1.396,4.163,1.938 c1.547,0.543,3.014,0.957,4.402,1.245c1.388,0.287,2.911,0.511,4.57,0.67c-2.616,1.787-3.924,4.626-3.924,8.517v7.487 c-1.445-0.43-2.869-0.938-4.268-1.53c-4.899-2.073-9.301-5.041-13.083-8.823c-3.782-3.782-6.75-8.184-8.823-13.083 C9.934,60.948,8.847,55.56,8.847,50s1.087-10.948,3.231-16.016c2.073-4.899,5.041-9.301,8.823-13.083s8.184-6.75,13.083-8.823 C39.052,9.934,44.44,8.847,50,8.847s10.948,1.087,16.016,3.231c4.9,2.073,9.301,5.041,13.083,8.823 c3.782,3.782,6.75,8.184,8.823,13.083c2.143,5.069,3.23,10.457,3.23,16.016s-1.087,10.948-3.231,16.016 C85.848,70.915,82.88,75.317,79.099,79.099L79.099,79.099z"></path>
                  </svg>
            </a></li>
             
            
            <li><a href="mailto:arthurchiao@hotmail.com">
                  <svg id="mail" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M50,1C22.938,1,1,22.938,1,50s21.938,49,49,49s49-21.938,49-49S77.062,1,50,1z M25.5,25.5h49 c0.874,0,1.723,0.188,2.502,0.542L50,57.544L22.998,26.041C23.777,25.687,24.626,25.499,25.5,25.5L25.5,25.5z M19.375,68.375v-36.75 c0-0.128,0.005-0.256,0.014-0.383l17.96,20.953L19.587,69.958C19.448,69.447,19.376,68.916,19.375,68.375L19.375,68.375z M74.5,74.5 h-49c-0.541,0-1.072-0.073-1.583-0.212l17.429-17.429L50,66.956l8.653-10.096l17.429,17.429C75.572,74.427,75.041,74.5,74.5,74.5 L74.5,74.5z M80.625,68.375c0,0.541-0.073,1.072-0.211,1.583L62.652,52.195l17.96-20.953c0.008,0.127,0.014,0.255,0.014,0.383 L80.625,68.375L80.625,68.375z"></path>
                  </svg>
            </a></li>
            
         </ul>
      </div>
   </div>
</div><!-- end .footer -->

   <!-- Add jQuery and other scripts -->
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src=""><\/script>')</script>
<script src="/assets/js/dropcap.min.js"></script>
<script src="/assets/js/responsive-nav.min.js"></script>
<script src="/assets/js/scripts.js"></script>


</body>

</html>
