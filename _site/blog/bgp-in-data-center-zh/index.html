<!DOCTYPE html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7"><![endif]-->
<!--[if IE 7]><html class="no-js lt-ie9 lt-ie8" <![endif]-->
<!--[if IE 8]><html class="no-js lt-ie9" <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->

<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
       new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
       j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
       'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
       })(window,document,'script','dataLayer','GTM-WP54B9K');</script>
    <!-- End Google Tag Manager -->

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <title>[笔记] BGP in the Data Center (O'Reilly 2017)</title>

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="/assets/img/favicon.ico" />

    <!-- Come and get me RSS readers -->
    <link rel="alternate" type="application/rss+xml" title="ArthurChiao's Blog" href="http://0.0.0.0:4000/feed.xml" />
    
    <!-- Stylesheet -->
    <link rel="stylesheet" href="/assets/css/style.css">
    <!--[if IE 8]><link rel="stylesheet" href="/assets/css/ie.css"><![endif]-->
    <link rel="canonical" href="http://0.0.0.0:4000/blog/bgp-in-data-center-zh/">

    <!-- Modernizr -->
    <script src="/assets/js/modernizr.custom.15390.js" type="text/javascript"></script>

    
</head>


<body>
  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WP54B9K"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->

    <div class="header">
     <div class="container">
         <h1 class="logo"><a href="/">ArthurChiao's Blog</a></h1>
         <nav class="nav-collapse">
             <ul class="noList">
                 
                   
                   
                   <li class="element first  ">
                     <a href="/index.html">Home</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/articles">Articles</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/articles-zh">Articles (中文)</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/categories">Categories</a>
                   </li> 
                 
                   
                   
                   <li class="element   last">
                     <a href="/about">About</a>
                   </li> 
                 
                 <!-- <li> <a href="https://github.com/arthurchiao/reading" target="_blank">Reading</a></li> -->
                 <!-- <li> <a href="https://github.com/arthurchiao/" target="_blank">GitHub</a></li> -->
             </ul>
         </nav>
     </div>
 </div><!-- end .header -->


   <div class="content">
      <div class="container">
         <div class="post">
  
  <h1 class="postTitle">[笔记] BGP in the Data Center (O'Reilly 2017)</h1>
  <p class="meta">2019-04-01 | <span class="time">47</span> Minute Read</p>

  
  
  <h3 id="关于本文">关于本文</h3>

<p>本文是我在读 <a href="https://www.oreilly.com/library/view/bgp-in-the/9781491983416/">BGP in the Data
Center</a> （
O’Reilly, 2017）时的读书笔记。原书很短，只有 90 页不到，但理论和实践兼备，是现代
数据中心和 BGP 入门的很好参考。</p>

<p>作者 Dinesh G. Dutt 是一家网络公司的首席科学家，在网络行业有 20 多年工作经验，曾
是 Cisco Fellow，是 TRILL、VxLAN 等协议的合作者（co-author）之一。</p>

<p>BGP 原本是用于服务供应商（service provider）网络的，并不适用于数据中心，因此进入
到数据中心的 BGP 是经过改造的。本文介绍的就是<strong>数据中心中的</strong> BGP（BGP in the
data center），这与传统BGP 还是有很大不同的。</p>

<p>以下是笔记内容。</p>

<hr />

<ol>
  <li><a href="#chap_1">数据中心网络绪论</a>
    <ul>
      <li>1.1 <a href="#chap_1.1">数据中心网络的需求</a></li>
      <li>1.2 <a href="#chap_1.2">Clos 网络拓扑</a></li>
      <li>1.3 <a href="#chap_1.3">Clos 网络架构</a></li>
      <li>1.4 <a href="#chap_1.4">服务器接入模型</a></li>
      <li>1.5 <a href="#chap_1.5">连接到外部网络</a></li>
      <li>1.6 <a href="#chap_1.6">多租户（或 Cloud）支持</a></li>
      <li>1.7 <a href="#chap_1.7">现代数据中心设计的运维考虑</a></li>
      <li>1.8 <a href="#chap_1.8">选择路由协议</a></li>
    </ul>
  </li>
  <li><a href="#chap_2">BGP 是如何适配到数据中心的</a>
    <ul>
      <li>2.1 <a href="#chap_2.1">几种路由协议</a></li>
      <li>2.2 <a href="#chap_2.2">iBGP 和 eBGP</a></li>
      <li>2.3 <a href="#chap_2.3">ASN</a></li>
      <li>2.4 <a href="#chap_2.4">最优路径算法</a></li>
      <li>2.5 <a href="#chap_2.5">多路径选择</a></li>
      <li>2.6 <a href="#chap_2.6">默认定时器导致的慢收敛</a></li>
      <li>2.7 <a href="#chap_2.7">数据中心默认 BGP 配置</a></li>
      <li>2.8 <a href="#chap_2.8">总结</a></li>
    </ul>
  </li>
  <li><a href="#chap_3">自动化 BGP 配置</a>
    <ul>
      <li>3.1 <a href="#chap_3.1">自动化配置基础</a></li>
      <li>3.2 <a href="#chap_3.2">示例数据中心网络</a></li>
      <li>3.3 <a href="#chap_3.3">自动化传统 BGP 的困难</a></li>
      <li>3.4 <a href="#chap_3.4">路由再分发</a></li>
      <li>3.5 <a href="#chap_3.5">路由策略</a></li>
      <li>3.6 <a href="#chap_3.6">使用接口名作为邻居</a></li>
      <li>3.7 <a href="#chap_3.7">总结</a></li>
    </ul>
  </li>
  <li><a href="#chap_4">其他 BGP 配置</a>
    <ul>
      <li>4.1 <a href="#chap_4.1">接口 IP 和 <code class="highlighter-rouge">remote-as</code></a></li>
      <li>4.2 <a href="#chap_4.2">Numbered Interfaces 数量</a></li>
      <li>4.3 <a href="#chap_4.3">Unnumbered Interfaces</a></li>
      <li>4.4 <a href="#chap_4.4">BGP Unnumbered</a></li>
      <li>4.5 <a href="#chap_4.5"><code class="highlighter-rouge">remote-as</code> 指定 BGP session 类型</a></li>
      <li>4.6 <a href="#chap_4.6">总结</a></li>
    </ul>
  </li>
  <li><a href="#chap_5">BGP 生命周期管理</a>
    <ul>
      <li>5.1 <a href="#chap_5.1">查看配置</a></li>
      <li>5.2 <a href="#chap_5.2">连接到外部网络</a></li>
      <li>5.3 <a href="#chap_5.3">计划节点维护</a></li>
      <li>5.4 <a href="#chap_5.4">Debug BGP</a></li>
      <li>5.5 <a href="#chap_5.6">总结</a></li>
    </ul>
  </li>
  <li><a href="#chap_6">服务器上运行 BGP</a>
    <ul>
      <li>6.1 <a href="#chap_6.1">虚拟服务器的兴起</a></li>
      <li>6.2 <a href="#chap_6.2">和服务器做 Peering 时的 BGP 配置</a></li>
      <li>6.3 <a href="#chap_6.3">在服务器 BGP 软件</a></li>
      <li>6.4 <a href="#chap_6.4">总结</a></li>
    </ul>
  </li>
</ol>

<h3 id="前言">前言</h3>

<p><strong>数据中心中的</strong> BGP 就像一头怪兽（a rather strange beast）。BGP 进入数据中心是
相当意外的（rather unexpected），但现在已经是数据中心路由协议（routing protocol
）的首选。</p>

<p><strong>本书定位</strong>：网络运维人员和工程师，有基本的网络和 BGP 知识，想知道 BGP 在数据中
心是如何应用的。
理解本书内容无需任何 BGP 高级知识，或任何特定路由平台的经验。</p>

<p><strong>本书主要目的</strong>：用一本书囊括数据中心部署 BGP 所需的<strong>理论和实践</strong>（theory and
pratice）。</p>

<p>本书使用的 BGP 软件：<a href="https://frrouting.org">FRRouting</a>。</p>

<p><a name="chap_1"></a></p>

<h2 id="1-数据中心网络绪论">1 数据中心网络绪论</h2>

<p>本章介绍在给定应用需求和预期规模的前提下，如何为现代数据中心设计网络（network
design of a modern data center network）。</p>

<p>和十年前相比，现代数据中心规模更大，网络部署速度要求更快（秒级而不是天级）。这显
著影响了网络的设计和部署。</p>

<p>BGP（Border Gateway Protocol）：<strong>边界网关协议</strong>。</p>

<p>过去的几十年里，连接到互联网（公网）的系统通过 BGP 发现彼此（find one another）
。但是，它也可以用在数据中心内部。现代数据中心中使用最广泛的路由协议就是 BGP。
BGP是标准协议，有很多免费和开源（free and open source，这里 “free” 作者应该是指“免
费”，而不是“自由软件”的“自由”）的软件实现。</p>

<p>本章试图回答以下问题：</p>

<ol>
  <li>现代数据中心网络设计的目标是什么？</li>
  <li>这些目标与其他网络（例如企业网和园区网，enterprise and campus）的设计目标有什么不同？</li>
  <li>数据中心为什么选择 BGP 作为路由协议？</li>
</ol>

<p><a name="chap_1.1"></a></p>

<h3 id="11-数据中心网络的需求">1.1 数据中心网络的需求</h3>

<p><strong>现代数据中心的演进都是由大型互联网公司的需求驱动的</strong>，例如 Google 和 Amazon。</p>

<p>核心需求：</p>

<ol>
  <li>
    <p>服务器到服务器通信越来越多（Increased server-to-server communication）</p>

    <p>单体应用到微服务化的转变，导致南北向流量减少，东西向流量增加。</p>
  </li>
  <li>
    <p>规模（Scale）</p>

    <p>过去，几百台服务器就已经是一个大数据中心；现在，现代数据中心一个机
 房可能就有上万台服务器。</p>
  </li>
  <li>
    <p>弹性（Resilience）</p>

    <p>老式数据中心的设计都是<strong>假设网络是可靠的</strong>，而现代数据中心应用都是<strong>假设网络
 是不可靠的</strong> —— 总会由于各种原因导致网络或机器故障。弹性就是要保证发生故障时
 ，<strong>受影响的范围可控，尽量做到不影响用户体验</strong>。</p>
  </li>
</ol>

<p>现代数据中心网络必须满足以上三方面基本需求。</p>

<p>多租户网络需要额外考虑：支持<strong>虚拟网络的快速部署和拆除</strong>（rapid deployment and
teardown)。</p>

<p>传统网络设计的扩展方式：<strong>scale-in</strong>（垂直扩展），即通过更换性能更高的设备实现。
缺点：</p>

<ol>
  <li>高性能设备特别贵</li>
  <li>这些设备大部分都是两方冗余（two-way redundancy），存在同时挂掉的风险，可用性
不是足够高</li>
  <li>发生故障时，故障范围特别大（尤其是核心设备）</li>
</ol>

<p><a name="chap_1.2"></a></p>

<h3 id="12-clos-网络拓扑">1.2 Clos 网络拓扑</h3>

<p>大型互联网公司最后采用了一种称为 Clos 的架构。Clos 架构最初是贝尔实验室的
Charles Clos 在 1950s 为电话交换网设计的。</p>

<p>可以实现<strong>无阻塞架构</strong>（non-blocking architecture）：上下行带宽都充分利用。</p>

<p align="center"><img src="/assets/img/bgp-in-data-center/1-1.PNG" width="60%" height="60%" /></p>
<p align="center">图 1-1 简单的两级（two-tier） Clos 网络</p>

<p>特点：</p>

<ol>
  <li>
    <p><strong>连接的一致性</strong>（uniformity of connectivity）：任意两个服务器之间都是 3 跳</p>
  </li>
  <li>
    <p><strong>节点都是同构的</strong>（homogeneous）：服务器都是对等的，交换机/路由器也是</p>
  </li>
  <li>
    <p><strong>全连接</strong>（full-mesh）：故障时影响面小（gracefully with failures）；总带宽高
，而且方便扩展，总带宽只受限于 Spine 的接口数量</p>
  </li>
</ol>

<p>注意，在以上模型中，<strong>Spine 仅仅用于连接 Leaf，因此在这种模型中，所有的功能（
functionality）都集中在 Leaf 上</strong>。</p>

<p>扩展方式：<strong>scale-out</strong>（水平扩展）。</p>

<p><strong>最大服务器数量</strong>（无阻塞架构下）：<code class="highlighter-rouge">n * m / 2</code>，其中 <code class="highlighter-rouge">n</code>是一个 Leaf 节点的端口
数量，<code class="highlighter-rouge">m</code> 是一个Spine 节点的端口数量。</p>

<p>典型带宽，分为接入（leaf-server）和互连（leaf-spine）：</p>

<ul>
  <li>接入 10G，互连 40G</li>
  <li>接入 25G，互连 100G</li>
</ul>

<p>受电源限制，单个机柜最大不超过 40 台服务器。</p>

<h4 id="三级-clos-网络">三级 Clos 网络</h4>

<p align="center"><img src="/assets/img/bgp-in-data-center/1-2.PNG" width="60%" height="60%" /></p>
<p align="center">图 1-2 三级（three-tier） Clos 网络</p>

<p>一组 ToR 和 Leaf 组成一个二级 Clos，称为一个 pod 或 cluster；
pod/cluster 作为一个独立单元再和 Spine 组成一个二级 Clos。</p>

<p><strong>最大服务器数量</strong>：<code class="highlighter-rouge">n * n * n /4</code>，其中 <code class="highlighter-rouge">n</code> 是交换机端口数量。</p>

<p>Clos 架构的魅力：无论从哪一级看，每个组成部分都是类似的，可以方便地替换和扩容。</p>

<p>为了解决规模瓶颈，大型互联网公司甚至会考虑 4 级甚至 6 级 Clos 架构。</p>

<h4 id="clos-网络的副作用">Clos 网络的副作用</h4>

<p>由于 Spine 和 Leaf 之间是 full-mesh，网线会特别多，排线会复杂一些。</p>

<p>设备故障影响面比较小，排障和更换设备方便（resilience）。</p>

<p>设备都是对等的，管理比较方便。</p>

<p><a name="chap_1.3"></a></p>

<h3 id="13-clos-network-网络架构">1.3 Clos Network 网络架构</h3>

<p>传统网络架构中，接入层和汇聚层走二层交换，因此需要运行 STP 协议消除二层环路。
如果在 Clos 网络中交换机也走二层，那可用（active）链路就会大大减少，如图 1-3 所
示：</p>

<p align="center"><img src="/assets/img/bgp-in-data-center/1-3.PNG" width="60%" height="60%" /></p>
<p align="center">图 1-3 启用 STP 之后的网络连接</p>

<p>如果有链路发生故障，那可用链路的效率会更低：</p>

<p align="center"><img src="/assets/img/bgp-in-data-center/1-4.PNG" width="60%" height="60%" /></p>
<p align="center">图 1-4 启用 STP 并且一条链路发生故障之后的网络连接</p>

<p>由此可见，<strong>走二层会导致非常低效和不均匀的连接</strong>（highly inefficient and
nonuniform connectivity）。</p>

<p>而另一方面，如果走三层路由，那就可以充分利用 Spine 和 Leaf 之间的 full-mesh
连接。而且路由还可以判断最短路径，或者为了达到更高整体利用率设置特定的路径。</p>

<p>因此，第一个结论：<strong>对于 Spine-Leaf 网络，路由（三层）比交换（二层）更合适</strong>。通
过二层连接的网络称为<strong>桥接网络</strong>（bridged network）；通过路由连接的网络称为<strong>路
由网络</strong>（routed network）。</p>

<p>使用路由的另一个好处是，避免了各种厂商相关的 STP 优化方案（将多条物理链路聚合成
一条虚拟链路提高利用率）。</p>

<p>典型的传统桥接网络需要运行：</p>

<ol>
  <li>STP</li>
  <li>一个单向链路检测协议（虽然现在已经合并到 STP 了）</li>
  <li>一个 VLAN 分发协议</li>
  <li>一个 first-hop 路由协议，例如 HSRP（Host Standby Routing Protocol） 或 VRRP（Virtual Router Redundancy Protocol）</li>
  <li>一个路由协议，用于连接多个桥接网络</li>
  <li>一个独立的单向链路检测协议，用于走路由的链路（routed links）</li>
</ol>

<p>如果是路由网络，那只需要：</p>

<ol>
  <li>一个路由协议（例如 BGP）</li>
  <li>一个单向链路检测协议</li>
</ol>

<p><strong>和服务器直连的路由器（leaf）会充当 anycast gateway（也可以称为分布式网关）</strong>，
此外就不需要其他协议了。</p>

<p>以上，就是 Clos 网络如何实现高度可扩展和弹性伸缩的。</p>

<p><a name="chap_1.4"></a></p>

<h3 id="14-服务器接入模型server-attach-model">1.4 服务器接入模型（Server Attach Model）</h3>

<ul>
  <li><strong>单接入</strong>（single-attach）</li>
  <li><strong>双接入</strong>（dual-attach）</li>
</ul>

<p>大型互联网公司采用<strong>单接入方式</strong>（single-attach servers），即，每个服务器只连接
到单个置顶交换机。这种设计背后的逻辑是：服务器数量足够多，由于网络问题导致单个机
柜挂掉时，影响不是很大。</p>

<p>但是对于小型网络，乃至部分大型公司的网络，挂掉一个机柜带来的影响是不能接受的。
因此这些公司采用<strong>双接入</strong>（dual-attach servers）方式：每个服务器连接到两个置顶
交换机。</p>

<p>双接入方式为了提高链路利用率，会将两个链路聚合成一个虚拟链路，这个技术是厂商相关
的，因此叫法不太一样：</p>

<ol>
  <li>Cisco 叫 vPC（virtual Port Channel）</li>
  <li>Cumulus 叫 CLAG</li>
  <li>Arista 叫 MLAG（Multi-Chassis Link Aggregation Protocol）</li>
</ol>

<p>这<strong>需要宿主机运行链路聚合控制协议（Link Aggreration Control Protocol, LACP）
以创建 bond 链路</strong>。如图 1-5 所示。</p>

<p align="center"><img src="/assets/img/bgp-in-data-center/1-5.PNG" width="60%" height="60%" /></p>
<p align="center">图 1-5 双接入方式下的链路聚合</p>

<p><a name="chap_1.5"></a></p>

<h3 id="15-连接到外部网络connectivity-to-the-external-world">1.5 连接到外部网络（Connectivity to the External World）</h3>

<p>对于<strong>中型或大型网络</strong>，<strong>通过 border leaf</strong> 连接到外网。</p>

<p>主要好处：将数据中心的网络和外部网络隔开（isolate）。数据中心内的路由协议无需和
外部交互（interact），更加稳定和安全。</p>

<p align="center"><img src="/assets/img/bgp-in-data-center/1-6.PNG" width="60%" height="60%" /></p>
<p align="center">图 1-6 通过 border leaf 将一个 Clos 网络连接到外部网络</p>

<p><strong>小型数据中心</strong>出于成本考虑，不会部署单独的 border leaf 节点，而是<strong>通过 Spine</strong> 连接到
外部网络，如图 1-7 所示。需要注意：这种方案中所有 Spine 都需要连接到外部网络，而
不是一部分 Spine。这非常重要，因为 <strong>Clos 网络中所有 Spine 都是对等的</strong>。</p>

<p align="center"><img src="/assets/img/bgp-in-data-center/1-7.PNG" width="60%" height="60%" /></p>
<p align="center">图 1-7 通过 spine 将一个 Clos 网络连接到外部网络</p>

<p><a name="chap_1.6"></a></p>

<h3 id="16-多租户或-cloud支持">1.6 多租户（或 Cloud）支持</h3>

<p>Clos 拓扑也适用于云计算网络，不管是公有云还是私有云。</p>

<p>云计算架构的额外需求：</p>

<ol>
  <li>敏捷性（Agility）：能快速创建/删除虚拟网络</li>
  <li>隔离性（Isolation）：租户之间互相不可见</li>
  <li>规模（Scale）：能够支持大量的租户</li>
</ol>

<p><a name="chap_1.7"></a></p>

<h3 id="17-现代数据中心设计的运维考虑">1.7 现代数据中心设计的运维考虑</h3>

<p>数据中心的设计会影响到数据中心的运维。</p>

<p><strong>自动化是最基本的要求</strong>（Automation is nothing less than a requirement for
basic survial）。在设计的时候要考虑能使自动化运维简单、可重复（simple and
repeatable）。</p>

<p><a name="chap_1.8"></a></p>

<h3 id="18-选择路由协议choice-of-routing-protocol">1.8 选择路由协议（Choice of Routing Protocol）</h3>

<p>对企业网（enterprise network），两种协议比较合适：</p>

<ol>
  <li>OSPF（Open Shortest Path First）</li>
  <li>IS-IS（Intermediate System to Intermediate System）</li>
</ol>

<p>它们都设计用于企业网内部，大部分企业网管理员对此应该很熟悉。</p>

<p>但是，<strong>OSPF 不支持多协议</strong>（例如对 IPv4 和 IPv6 需要运行两个独立协议），因此并没有
被大型互联网厂商采用。</p>

<p>IS-IS 支持 IPv4/IPv6，但是可选的实现比较少。而且，一些管理员认为，IS-IS 这样的链
路状态（link-state）协议不适用于 Clos 这样的富连接（richly connected）网络。</p>

<p>BGP 的特点：</p>

<ol>
  <li>成熟</li>
  <li>支撑着互联网（powers the internet）</li>
  <li>容易理解（fundamentally simple to understand），虽然名声可能不佳（despite its
reputation）</li>
  <li>实现很多，包括很多开源实现</li>
  <li>支持多协议（例如 IPv4/IPv6，MPLS）和 VPN（内置）</li>
</ol>

<p>只需对 BGP 做一些改造，就可以将它高效地应用中数据中心中。微软的 Azure 团队是最早
对 BGP 进行改造用于数据中心的。现在，我接触的大部分客户都是部署 BGP。</p>

<p>在下一章中，我们将看到人们<strong>对传统 BGP 进行了哪些改造</strong>，然后将它应用到数据中心的。</p>

<p><a name="chap_2"></a></p>

<h2 id="2-bgp-是如何适配到数据中心的">2 BGP 是如何适配到数据中心的</h2>

<p>在 BGP 用于数据中心之前，它主要用于<strong>服务提供商网络</strong>（service provider network）。
这导致的一个问题就是，数据中心不能运行 BGP，不然会和底层供应商的网络有冲突。如
果你是网络管理和运维人员，那意识到这一点非常重要。</p>

<p>不同网络场景：</p>

<ul>
  <li>数据中心：高密度连接（dense connectivity）</li>
  <li>服务提供商（连接不同域）：相对低密度连接（relatively sparse connectivity）</li>
</ul>

<p>因此，服务提供商的网络首先是考虑可靠性（stability），其次才是（路由等）变化的快
速通知（rapid notification of changes）。因此，BGP 发送通知的实时性比较低。而在
数据中心中，管理员更希望<strong>路由更新（routing updates）越快越好</strong>。</p>

<p>另外，由于 BGP 自身的设计、行为，以及它作为路径矢量协议（path-verctor protocol）
的特性，单个链路挂掉会导致节点之间发送大量 BGP 消息。</p>

<p>第三个例子，BGP 从多个 ASN 收到一条 prefix（路由网段前缀）之后，最
终只会生成一条最优路径。而在数据中心中，我们希望生成多条路径。</p>

<p>为适配数据中心而对 BGP 进行的改造，见 <a href="">FRC 7938</a>。</p>

<p>本章描述这些改动，以及背后的考虑（rationale for the change）。<strong>这里再次强调，数
据中心使用的 BGP 和传统的 BGP 并不一样，如果不理解这一点，管理员很容易误操作造成
网络故障</strong>。</p>

<p><a name="chap_2.1"></a></p>

<h3 id="21-有几路由协议">2.1 有几路由协议</h3>

<p>传统 BGP 从 OSPF、IS-IS、EIGRP（Enhanced Interior Gateway Routing Protocol） 等
协议接收路由通告，这些称为<strong>内部路由协议</strong>（internal routing protocols），用于控制
企业内的路由。无怪乎很多人当时认为，要在数据中心中落地 BGP，还需要另一个协议。
但实际上，<strong>在数据中心中 BGP 就是（特定的）内部路由协议，不需要再运行另一个协议
了</strong>。</p>

<p><a name="chap_2.2"></a></p>

<h3 id="22-ibgp-和-ebgp">2.2 iBGP 和 eBGP</h3>

<p>数据中心内部是该使用内部网关协议（iBGP）还是外部网关协议（eBGP）？<strong>很多人觉得应
该是 iBGP，因为在数据中心内部，但其实不是</strong>。</p>

<p><strong>数据中心中 eBPG 是使用最广泛的</strong>。原因；</p>

<ol>
  <li>
    <p>主要原因是 eBGP 比 iBGP 更易理解和部署</p>

    <p>iBGP 的最优路径选择算法很复杂，而且存在一些限制，使用、配置、管理复杂。</p>
  </li>
  <li>
    <p>eBGP 的实现比 iBGP 多，选择面比较大</p>
  </li>
</ol>

<p><a name="chap_2.3"></a></p>

<h3 id="23-asn-编号">2.3 ASN 编号</h3>

<p>每个 BGP 节点都有一个 ASN（Autonomous System Number）。ASN 用于<strong>识别路由环境、
判断最优路径、关联路由策略</strong>等等。</p>

<p>ASN 有两个版本：老版用 2 个字节表示，新版用 4 个字节表示。</p>

<p>数据中心 BGP 中 ASN 的分配方式和公网 BGP ASN 的分配方式不同。</p>

<p><strong>公网的 BGP 使用 well-known ASN，但数据中心中使用的一般都是私有 ASN，因为一般不需
要和公网做 peer</strong>。</p>

<h4 id="私有-asn">私有 ASN</h4>

<p>私有 ASN 和 私有网段类似。</p>

<p>但注意：<strong>如果管理员真要用公网 ASN，那也是没人能阻止的</strong>。有两个原因不建议这样做：</p>

<ul>
  <li>造成管理的混乱，包括人和工具</li>
  <li>会将内网信息泄露到公网，造成极大的安全问题</li>
</ul>

<p><strong>私有 ASN 数量</strong>：</p>

<ol>
  <li>老版本（2 字节）：大概 1023 个（64512~65534)</li>
  <li>新版本（4 字节）：大概 95 million（4200000000~4294967294）</li>
</ol>

<h4 id="path-hunting-问题">Path Hunting 问题</h4>

<p>有多种分配 ASN 的方式。</p>

<p>如果采用每个节点一个 ASN 的方案，那会存在一个 count-to-infinity 问题。简单说就是
：每个节点不知道其他节点的物理链路状态（physical link state），因此无法判断一条
路由是真的不通了（节点挂掉）还是通过其他路径还是可达的。</p>

<p>当一个节点挂到后，其他节点陆续撤回（withdraw）可达路由时，导致网络内大量的 BGP消
息。这个问题称为 path hunting。</p>

<p align="center"><img src="/assets/img/bgp-in-data-center/2-1.PNG" width="60%" height="60%" /></p>
<p align="center">图 2-1 一个简单拓扑，解释 path hunting</p>

<h4 id="asn-numbering-model">ASN Numbering Model</h4>

<p>为了避免 path hunting 问题，<strong>Clos 网络内的 ASN 编号模型</strong>如下：</p>

<ol>
  <li>每个 ToR 都有自己的 ASN</li>
  <li>pod 边缘的 leaf 有自己的 ASN，但同一个 pod 内的 leaf，共用同一个 ASN</li>
  <li>pod 之间的 spine，共享一个 ASN</li>
</ol>

<p>图 2-2 是一个三级 Clos 的例子：</p>

<p align="center"><img src="/assets/img/bgp-in-data-center/2-2.PNG" width="60%" height="60%" /></p>
<p align="center">图 2-2 Clos 拓扑 ASN 编号模型示例</p>

<p><strong>这种编号模型是如何解决 path hunting 问题的</strong>：以图 2-1 为例，如果 R2 和 R3 有
相同的 ASN，那 R1 收到 R2 的一条到 10.1.1.1 的消息后，再收到 R3 来的到 10.1.1.1
消息时（检测到有环路），就会拒绝后者。当 R4 挂掉时，消息回撤会很简单。</p>

<p>这种编号模型的缺点：<strong>无法做路由聚合或摘要</strong>（route aggregation or summarization
）。还是拿图 2-1 为例，如果 R2 和 R3 通过直连的服务器总共收集到了 <code class="highlighter-rouge">10.1.1.2/32 ~
10.1.1.250/32</code> 的可达消息。如果 R2 和 R3 做路由聚合，那只需要向 R1 通告一条
<code class="highlighter-rouge">10.1.1.0/24</code> 可达消息，而不用通告 250 次，每次一个 IP。在这种情况下，如果 R2-R4
链路挂了，那 R1 仍然认为<code class="highlighter-rouge">10.1.1.0/24</code> 到 R4 仍然是可达的，因为可以通过<code class="highlighter-rouge">R1-R3-R4</code>
，但实际上有些 IP 是只能通过 R2-R4 才通的。也即路由聚合在这种情况下带来了问题。</p>

<p><a name="chap_2.4"></a></p>

<h3 id="24-最优路径算法">2.4 最优路径算法</h3>

<p>给定一个节点的 prefix，BGP 通过算法判断到这个 node 的最佳路径。</p>

<p>UPDATE 消息会触发最优路径计算过程。可以对 UPDATE 消息做缓存，批量处理，具体取决
于不同 BGP 的实现。</p>

<p>最优路径算法中有 8 个参数，但和数据中心相关的只有一个：<code class="highlighter-rouge">AS_PATH</code>。
可以用下面这句话记这八个参数：</p>

<blockquote>
  <p>Wise Lip Lovers Apply Oral Mediacation Every Night.</p>
</blockquote>

<p>每个字段的意思见图 2-3。</p>

<p align="center"><img src="/assets/img/bgp-in-data-center/2-3.PNG" width="60%" height="60%" /></p>
<p align="center">图 2-3 BGP 最优路径选择标准</p>

<p><a name="chap_2.5"></a></p>

<h3 id="25-多路径选择">2.5 多路径选择</h3>

<p>对于 Clos 这种密集连接型网络，<strong>路由多路径</strong>（route multi-pahting）是构建健壮、
可扩展网络的基本要求。</p>

<p><strong>BGP 支持多路径，包括对等（equal cost）和非对等（unequal cost）多路径</strong>。但支持
程度取决于具体实现。</p>

<p>两条路由相同的判断标准：以上八个条件都相同。其中，AS_PATH 字段一定要 ASN
相同才算相同，只是跳数相同不行。这将多路径分为了两种部署方式。</p>

<p>第一种方式，服务器是双接入的（直连两个 ToR），如图 2-4 所示。在这种情况下，Spine
会收到两条到服务器的路径，分别经过两个 ToR。由于两条 path 的 ASN 不一样，Spine
认为这两个 path 不同（unequal），因此最终会二选一。</p>

<p>第二种方式，服务器内起 VM 或容器，并且在不同服务器内有多个实例，所有实例有相同的
虚 IP （virutal IP）。由于不同服务器连接到了不同 ToR，因此 Spine 会收到多条到虚
IP 的路径，所有路径的跳数相同，但每个路径上的 ASN 不同，因此 Spine 也将它们当作
unequal path 处理。</p>

<p>要解决以上问题有多种方式，最简单的方式：配置最优路径算法，认为跳数相同 AS_PATH
就算相同，不管 ASN 是否相同。</p>

<p align="center"><img src="/assets/img/bgp-in-data-center/2-4.PNG" width="60%" height="60%" /></p>
<p align="center">图 2-4 一个简单拓扑，解释 path hunting</p>

<p><a name="chap_2.6"></a></p>

<h3 id="26-默认定时器导致的慢收敛">2.6 默认定时器导致的慢收敛</h3>

<p>简单来说，BGP 中的几个定时器控制 peer 之间通信的速度。对于 BGP，这些参数的默认值
都是针对<strong>服务提供商环境</strong>优化的，其中<strong>稳定性的优先级高于快速收敛</strong>。而数据中心
则相反，快速收敛的优先级更高。</p>

<p>当一个节点挂掉，或挂掉之后恢复时，有四个定时器影响 BGP 的收敛速度。对这些参数进
行调优，可以使得 BGP 达到内部路由协议（例如 OSFP）的性能。</p>

<ul>
  <li>Advertisement Interval</li>
  <li>Keepalive and Hold Timers</li>
  <li>Connect Timer</li>
</ul>

<h4 id="advertisement-interval">Advertisement Interval</h4>

<p>发布路由通告的间隔。在这个间隔内的事件会被缓存，然后时间到了一起发送。</p>

<p>默认：<strong>eBGP 是 30s，iBGP 是 0s</strong>。</p>

<p>对于密集连接型的数据中心来说，30s 显然太长了，<strong>0s 比较合适</strong>。这会使得 eBGP 的收敛
速度达到 OSFP 这种 IGP 的水平。</p>

<h4 id="keepalive-and-hold-timers">Keepalive and Hold Timers</h4>

<p>每个节点会向它的 peer 发送心跳消息。如果一段时间内（称为 hold time）没收到 peer
的心跳，就会清除所有从这个 peer 收到的消息。</p>

<p>默认：</p>

<ul>
  <li>Keepalive: 60s</li>
  <li>Hold timer: 180s</li>
</ul>

<p>这表示每分钟发一个心跳，如果三分钟之内一个心跳都没收到，就认为 peer 挂了。</p>

<p><strong>数据中心中的三分钟太长了，足以让人过完一生</strong>（Inside the data center, three
minutes is a lifetime）。典型配置：</p>

<ul>
  <li>Keepalive: 3s</li>
  <li>Hold timer: 9s</li>
</ul>

<h4 id="connect-timer">Connect Timer</h4>

<p>节点和 peer 建立连接失败后，再次尝试建立连接之前需要等待的时长。</p>

<p>默认：60s。</p>

<p><a name="chap_2.7"></a></p>

<h3 id="27-数据中心默认-bgp-配置">2.7 数据中心默认 BGP 配置</h3>

<p>很多 BGP 实现的默认配置都是针对服务提供商网络调优的，而不是针对数据中心。</p>

<p>建议：<strong>显示配置用到的参数</strong>（即使某些配置和默认值相同），这样配置一目了然，运维和排障都比较方便。</p>

<p><strong>下面是 FRRouting BGP 的默认配置，我认为是数据中心 BGP 的最优实践。在我参与过的
几乎所有生产环境数据中心都使用的这个配置</strong>：</p>

<ul>
  <li>Multipath enabled for  <code class="highlighter-rouge">eBGP</code> and <code class="highlighter-rouge">iBGP</code></li>
  <li>Advertisement interval: <code class="highlighter-rouge">0s</code></li>
  <li>Keepalive and Hold Timers: <code class="highlighter-rouge">3s</code> and <code class="highlighter-rouge">9s</code></li>
  <li>Logging adjacency changes enabled</li>
</ul>

<p><a name="chap_2.8"></a></p>

<h3 id="28-总结">2.8 总结</h3>

<ul>
  <li>数据中心网络默认部署模型：eBGP</li>
  <li>ASN 编号模型</li>
</ul>

<p>接下来的两章将会把本章学到的知识用到真实 Clos 环境。</p>

<p><a name="chap_3"></a></p>

<h2 id="3-自动化-bgp-配置">3 自动化 BGP 配置</h2>

<p>运维口头禅：<strong>要么自动化，要么去死</strong>（automate or die）。</p>

<p><a name="chap_3.1"></a></p>

<h3 id="31-自动化配置基础">3.1 自动化配置基础</h3>

<p>只要存在模式（pattern），就有可能实现自动化（Automation is possible when there
are patterns）。</p>

<p><a name="chap_3.2"></a></p>

<h3 id="32-示例数据中心网络">3.2 示例数据中心网络</h3>

<p>本书剩余部分将使用图 3-1 所示的拓扑，它代表了当前大部分数据中心网络的拓扑。</p>

<p align="center"><img src="/assets/img/bgp-in-data-center/3-1.PNG" width="60%" height="60%" /></p>
<p align="center">图 3-1 示例数据中心网络</p>

<p>接下来涉及以下节点的配置：</p>

<ul>
  <li>leaf 节点：leaf01 ~ leaf04</li>
  <li>spine 节点：spine01 ~ spine04</li>
  <li>border leaf 节点：exit01 ~ exit02</li>
  <li>服务器：server01 ~ server04</li>
</ul>

<p>除了服务器之外，其他所有节点都是路由器，路由协议是 BGP。</p>

<blockquote>
  <p>A quick reminder: 我们使用的是 Clos 拓扑，因此 Spine 和 Leaf 节点都是路由器。</p>
</blockquote>

<p><a name="chap_3.3"></a></p>

<h3 id="33-自动化传统-bgp-的困难">3.3 自动化传统 BGP 的困难</h3>

<p>配置 3-1 网络：</p>

<p><code class="highlighter-rouge">router bgp 65000</code></p>

<blockquote>
  <p>配置 ASN，并开始了一个 BGP 配置 block（对 FRR）。</p>
</blockquote>

<p><code class="highlighter-rouge">bgp router-id 10.0.254.1</code></p>

<blockquote>
  <p>每个节点要有一个唯一的 router-id。一种比较好的方式是，选择这个节点的 loopback
IP 作为 router-id。</p>
</blockquote>

<p><code class="highlighter-rouge">neighbor peer-group ISL</code></p>

<blockquote>
  <p>在 FRR中，定义配置模板。</p>
</blockquote>

<p><code class="highlighter-rouge">neighbor ISL remote-as 65500</code></p>

<blockquote>
  <p>配置对端 ASN。传统 BGP 配置需要这一项。</p>
</blockquote>

<p><code class="highlighter-rouge">neighbor 169.254.1.0 peer-group ISL</code></p>

<blockquote>
  <p>使用配置模板 ISL 中的参数，和指定 IP 建立连接。</p>
</blockquote>

<p><code class="highlighter-rouge">address-family ipv4 unicast</code></p>

<blockquote>
  <p>BGP 支持多协议，因此需要显式指定希望的路由协议，此处为 ipv4 unicast。</p>
</blockquote>

<p><code class="highlighter-rouge">neighbor ISL activate</code></p>

<blockquote>
  <p>启用。</p>
</blockquote>

<p><code class="highlighter-rouge">network 10.0.254.1/32</code></p>

<blockquote>
  <p>对外通告本节点到 10.0.254.1/32 的路由是可达的。这首先需要确保这条路由在节点的
路由表中是存在的。</p>
</blockquote>

<p><code class="highlighter-rouge">maximum-paths 64</code></p>

<blockquote>
  <p>允许使用多路径。</p>
</blockquote>

<h4 id="leaf-节点核心配置">Leaf 节点核心配置</h4>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// leaf01’s BGP configuration
log file /var/log/frr/frr.log

router bgp 65000
  bgp router-id 10.0.254.1
  bgp log-neighbor-changes
  bgp no default ipv4-unicast
  timers bgp 3 9
  neighbor peer-group ISL
  neighbor ISL remote-as 65500
  neighbor ISL advertisement-interval 0
  neighbor ISL timers connect 5
  neighbor 169.254.1.0 peer-group ISL
  neighbor 169.254.1.64 peer-group ISL
  address-family ipv4 unicast
    neighbor ISL activate
    network 10.0.254.1/32
    network 10.1.1.0/26
    maximum-paths 64
exit-address-family
</code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// leaf02’s BGP configuration
log file /var/log/frr/frr.log

router bgp 65001
  bgp router-id 10.0.254.2
  bgp log-neighbor-changes
  bgp no default ipv4-unicast
  timers bgp 3 9
  neighbor peer-group ISL
  neighbor ISL remote-as 65500
  neighbor ISL advertisement-interval 0
  neighbor ISL timers connect 5
  neighbor 169.254.1.0 peer-group ISL
  neighbor 169.254.1.64 peer-group ISL
  address-family ipv4 unicast
    neighbor ISL activate
    network 10.0.254.1/32
    network 10.1.1.0/26
    maximum-paths 64
exit-address-family
</code></pre></div></div>

<h4 id="spine-节点核心配置">Spine 节点核心配置</h4>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// spine01’s BGP configuration
log file /var/log/frr/frr.log

router bgp 65534
  bgp router-id 10.0.254.254
  bgp log-neighbor-changes
  bgp no default ipv4-unicast
  timers bgp 3 9
  neighbor peer-group ISL
  neighbor ISL advertisement-interval 0
  neighbor ISL timers connect 5
  neighbor 169.254.1.1 remote-as 65000
  neighbor 169.254.1.1 peer-group ISL
  neighbor 169.254.1.3 remote-as 65001
  neighbor 169.254.1.3 peer-group ISL
  neighbor 169.254.1.5 remote-as 65002
  neighbor 169.254.1.5 peer-group ISL
  neighbor 169.254.1.7 remote-as 65003
  neighbor 169.254.1.7 peer-group ISL
  bgp bestpath as-path multipath-relax
  address-family ipv4 unicast
    neighbor ISL activate
    network 10.0.254.254/32
    maximum-paths 64
exit-address-family
</code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// spine02’s BGP configuration
log file /var/log/frr/frr.log

router bgp 65534
  bgp router-id 10.0.254.253
  bgp log-neighbor-changes
  bgp no default ipv4-unicast
  timers bgp 3 9
  neighbor peer-group ISL
  neighbor ISL advertisement-interval 0
  neighbor ISL timers connect 5
  neighbor 169.254.1.1 remote-as 65000
  neighbor 169.254.1.1 peer-group ISL
  neighbor 169.254.1.3 remote-as 65001
  neighbor 169.254.1.3 peer-group ISL
  neighbor 169.254.1.5 remote-as 65002
  neighbor 169.254.1.5 peer-group ISL
  neighbor 169.254.1.7 remote-as 65003
  neighbor 169.254.1.7 peer-group ISL
  bgp bestpath as-path multipath-relax
  address-family ipv4 unicast
    neighbor ISL activate
    network 10.0.254.254/32
    maximum-paths 64
exit-address-family
</code></pre></div></div>

<p>总结自动化会遇到的问题：配置中使用 IP 地址的话，会有很多地方重复；新加或修改 IP
地址时很多地方都要改。</p>

<p>如何解决这个问题？看下面几个工具。</p>

<p><a name="chap_3.4"></a></p>

<h3 id="34-路由再分发redistributes-routes">3.4 路由再分发（Redistributes Routes）</h3>

<p>将一种协议收到的路由以另一种协议再发送出去，称为<strong>路由再分发</strong>（redistributing routes）
。格式：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>resitribute &lt;protocol&gt; route-map &lt;route-map-name&gt;
</code></pre></div></div>

<p><code class="highlighter-rouge">&lt;protocol&gt;</code> 支持：</p>

<ul>
  <li><code class="highlighter-rouge">static</code>：通告（announce）静态配置的路由</li>
  <li><code class="highlighter-rouge">connected</code>：通告和接口地址（interface address）相关联的路由</li>
  <li><code class="highlighter-rouge">kernel</code>：只适用于 Linux。通过路由套件（FRRouting、bird、quagga等）配置的路由
，或通过 iproute2 等工具直接配置在内核的路由</li>
  <li><code class="highlighter-rouge">ospf</code>：通过 OSPF 学习到的路由</li>
  <li><code class="highlighter-rouge">bgp</code>：通过 BGP 学习到的路由</li>
  <li><code class="highlighter-rouge">rip</code>：通过 RIP 学习到的路由</li>
  <li>others, e.g. IS-IS</li>
</ul>

<p>因此，以上 <code class="highlighter-rouge">network &lt;IP&gt;</code> 配置就可以简化成 <code class="highlighter-rouge">redistribute connected</code>，去掉了
hardcode IP。Leaf 节点的配置变成：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>log file /var/log/frr/frr.log
router bgp 65000
  bgp router-id 10.0.254.1
  bgp log-neighbor-changes
  bgp no default ipv4-unicast
  timers bgp 3 9
  neighbor peer-group ISL
  neighbor ISL remote-as 65500
  neighbor ISL advertisement-interval 0
  neighbor ISL timers connect 5
  neighbor 169.254.1.0 peer-group ISL
  neighbor 169.254.1.64 peer-group ISL
  address-family ipv4 unicast
    neighbor ISL activate
    redistribute connected
    maximum-paths 64
exit-address-family
</code></pre></div></div>

<p>但是，<code class="highlighter-rouge">redistribute</code> 方式也有潜在的问题。<strong>如果接口上的 IP 配错了会导致错误的路
由通告</strong>，例如如果接口配置了 8.8.8.8/32，也就是默认 DNS 地址，那所有的 DNS 请求
都会打到这个接口。</p>

<p>解决这个问题需要用到<strong>路由策略（routing policy）</strong>。</p>

<p><a name="chap_3.5"></a></p>

<h3 id="35-路由策略">3.5 路由策略</h3>

<p>用最简单的话来说，路由策略就是规定哪些路由通告可以接受，哪些需要拒绝。</p>

<p>例如，禁止通告上面提到的 <code class="highlighter-rouge">8.8.8.8</code> 问题：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">if </span>prefix equals <span class="s1">'8.8.8.8/32'</span> <span class="k">then </span>reject <span class="k">else </span>accept
</code></pre></div></div>

<p>策略可以写成函数，支持传递参数，例如只接受本地路由：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ACCEPT_DC_LOCAL<span class="o">(</span>prefix<span class="o">)</span>
<span class="o">{</span>
    <span class="k">if </span>prefix belongs to 10.1.0.0/16 <span class="k">then </span>accept
    <span class="k">else if</span> <span class="o">(</span>10.0.254.0/24 contains prefix and
            subnet equals 32<span class="o">)</span> <span class="k">then
    </span>accept
    <span class="k">else </span>reject
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <p>注意：建议所有变量使用小写，因为我见过几乎所有网络配置都是这样的，不要使用
camelCase 等其他格式。</p>
</blockquote>

<h4 id="route-maps">Route-Maps</h4>

<p><code class="highlighter-rouge">route-maps</code> 是实现路由策略的常见方式。Cisco IOS、NXOS，以及开源的 FRRouting、
Arista 等等都支持 <code class="highlighter-rouge">route-maps</code>。<a href="">BIRD</a>软件走的更远，支持一种简单的领域特定语言
（DSL）。</p>

<p><code class="highlighter-rouge">route-maps</code>格式：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>route-map NAME <span class="o">(</span>permit|deny<span class="o">)</span> <span class="o">[</span>sequence_number]
  match classifier
  <span class="nb">set </span>action
</code></pre></div></div>

<p>其中的 <code class="highlighter-rouge">sequence_number</code> 规定了在 <code class="highlighter-rouge">route-maps</code> 内 clause 的匹配优先级。</p>

<p>以下的策略：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>route-map EXCEPT_ISL_ETH0 deny 10
  match interface swp51
route-map EXCEPT_ISL_ETH0 deny 20
  match interface swp52
route-map EXCEPT_ISL_ETH0 deny 30
  match interface eth0
route-map EXCEPT_ISL_ETH0 permit 40
  redistribute connected route-map EXCEPT_ISL_ETH0
</code></pre></div></div>

<p>和以下为代码是等价的：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>EXCEPT_ISL_ETH0<span class="o">(</span>interface<span class="o">)</span>
<span class="o">{</span>
  <span class="k">if </span>interface is not swp51 and
  interface is not swp52 and
  interface is not eth0 <span class="k">then
  </span>redistribute connected
<span class="o">}</span>
</code></pre></div></div>

<h5 id="route-maps-对-bgp-处理的影响"><code class="highlighter-rouge">route-maps</code> 对 BGP 处理的影响</h5>

<p>BGP 是路径矢量协议，因此它在<strong>运行完最优路径算法之后，才会通告路由更新</strong>。</p>

<p><code class="highlighter-rouge">route-maps</code> 会应用到每个收到和发出的包。</p>

<p>如果 BGP 有大量的邻居，同时有大量的和邻居相关的 <code class="highlighter-rouge">route-maps</code>，<strong>最优路径计算过程
将非常慢</strong>，不仅消耗大量 CPU 资源，而且<strong>使得路由通告变慢，即路由收敛变慢</strong>。</p>

<p>解决这个问题的一种方式是使用 <code class="highlighter-rouge">peer-group</code>。将有相同路由策略的邻居放到一个 group
。一般都是由实现完成，不需要手动配置。</p>

<p><a name="chap_3.6"></a></p>

<h3 id="36-使用接口名作为邻居">3.6 使用接口名作为邻居</h3>

<p>FRRouting 的一个特性，可以自动推断出接口的 IP 地址，因此策略中可以指定端口而不是
IP。</p>

<p>Leaf 节点：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// leaf01’s BGP configuration
log file /var/log/frr/frr.log

ip prefix-list DC_LOCAL_SUBNET 5 permit 10.1.0.0/16 le 26
ip prefix-list DC_LOCAL_SUBNET 10 permit 10.0.254.0/24 le 32
route-map ACCEPT_DC_LOCAL permit 10
  match ip-address DC_LOCAL_SUBNET

router bgp 65000
  bgp router-id 10.0.254.1
  bgp log-neighbor-changes
  bgp no default ipv4-unicast
  timers bgp 3 9
  neighbor peer-group ISL
  neighbor ISL remote-as 65500
  neighbor ISL advertisement-interval 0
  neighbor ISL timers connect 5
  neighbor swp51 peer-group ISL
  neighbor swp52 peer-group ISL
  address-family ipv4 unicast
    neighbor ISL activate
    redistribute connected route-map DC_LOCAL
    maximum-paths 64
  exit-address-family
</code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// leaf02’s BGP configuration
log file /var/log/frr/frr.log

ip prefix-list DC_LOCAL_SUBNET 5 permit 10.1.0.0/16 le 26
ip prefix-list DC_LOCAL_SUBNET 10 permit 10.0.254.0/24 le 32
route-map ACCEPT_DC_LOCAL permit 10
  match ip-address DC_LOCAL_SUBNET

router bgp 65001
  bgp router-id 10.0.254.2
  bgp log-neighbor-changes
  bgp no default ipv4-unicast
  timers bgp 3 9
  neighbor peer-group ISL
  neighbor ISL remote-as 65500
  neighbor ISL advertisement-interval 0
  neighbor ISL timers connect 5
  neighbor swp51 peer-group ISL
  neighbor swp52 peer-group ISL
  address-family ipv4 unicast
    neighbor ISL activate
    redistribute connected route-map DC_LOCAL
    maximum-paths 64
  exit-address-family
</code></pre></div></div>

<p>Spine 节点：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>log file /var/log/frr/frr.log

ip prefix-list ACCRT 5 permit 10.1.0.0/16 le 26
ip prefix-list ACCRT 10 permit 10.0.254.0/24 le 32
route-map DC_LOCAL permit 10
  match ip-address ACCRT

router bgp 65500
  bgp router-id 10.0.254.254
  bgp log-neighbor-changes
  bgp no default ipv4-unicast
  timers bgp 3 9
  neighbor peer-group ISL
  neighbor ISL advertisement-interval 0
  neighbor ISL timers connect 5
  neighbor swp1 remote-as 65000
  neighbor swp1 peer-group ISL
  neighbor swp2 remote-as 65001
  neighbor swp2 peer-group ISL
  neighbor swp3 remote-as 65002
  neighbor swp3 peer-group ISL
  neighbor swp4 remote-as 65003
  neighbor swp4 peer-group ISL
  bgp bestpath as-path multipath-relax
  address-family ipv4 unicast
    neighbor ISL activate
    redistribute connected route-map DC_LOCAL
    maximum-paths 64
  exit-address-family
</code></pre></div></div>

<p><a name="chap_3.7"></a></p>

<h3 id="37-总结">3.7 总结</h3>

<p>将配置模板化，避免具体 IP：</p>

<ol>
  <li><code class="highlighter-rouge">redistribute connected</code> 替换 <code class="highlighter-rouge">network &lt;IP&gt;</code></li>
  <li><code class="highlighter-rouge">route-maps</code> 安全策略</li>
  <li>使用接口名而不是接口上的 IP</li>
</ol>

<p>但以上还不够通用，下一章继续。</p>

<p><a name="chap_4"></a></p>

<h2 id="4-其他-bgp-配置">4 其他 BGP 配置</h2>

<p>本章将展示如何通过 <code class="highlighter-rouge">remote-as</code> 彻底去掉配置中的接口的 IP 地址，这将使得 BGP 的配
置非常：</p>

<ol>
  <li>同构（homogeneous）</li>
  <li>无重复（duplication-free）（即不会出现大段大段类似的配置）</li>
</ol>

<p>非常便于自动化。</p>

<p>要实现这个目标，首先需要理解一个<strong>和路由同样古老的概念：unnumbered interfaces</strong>
，以及我们如何将它适配到 BGP。</p>

<ul>
  <li><strong>Numbered Interface</strong>：配置了 IP 地址的接口</li>
  <li><strong>Unnumbered Interface</strong>：没有配置 IP 地址的接口</li>
</ul>

<p><a name="chap_4.1"></a></p>

<h3 id="41-接口-ip-和-remote-as">4.1 接口 IP 和 <code class="highlighter-rouge">remote-as</code></h3>

<p>BGP 基于 TCP/IP 协议，因此需要一个 IP 地址才能建立连接。</p>

<p><strong>在没有为（本地）接口分配IP 地址的情况下，如何确定远端节点的地址呢</strong>？要回答这
个问题，需要理解一个稍微有点冷门的 RFC 协议，以及 IPv6 提供的无状态配置工具（
stateless configuration tools）。同时，这也涉及到了路由问题的核心（real heart of
routing）。</p>

<p>第二个问题是，每个 BGP 配置都需要知道对端 ASN。但依赖这个 ASN 只是为了<strong>以此判断
session 是被 iBGP 还是 eBGP 规则管理</strong>。</p>

<p><a name="chap_4.2"></a></p>

<h3 id="42-numbered-interfaces-数量">4.2 Numbered Interfaces 数量</h3>

<p>是否真需要给每个接口配置一个 IP 地址？</p>

<p>考虑一个简单的两级 Clos：4 个 spine，32 个 leaf，这种规模的网络很常见。对于这个网
络，需要 4 * 32 * 2 = 256 个 IP 地址。如果 leaf 数量变成 96 —— 这种规模也很常见
—— 那总 IP 数量就是 4 * 96 * 2 = 768 个。如果 spine 数量增加到 16 个，那 IP 数量
就变成 3072 个。</p>

<p>可以看到，这种方式下，<strong>所需的 IP 数量随着 spine 和 leaf 数量及接口数量的增加而
急剧增加</strong>。而这些 IP 除了 建立 BGP session 之外没有任何其他用途。为什么不想办法
干掉它们呢？</p>

<blockquote>
  <p>关于 Numbered Interfaces 的哲学思考（Philosophical Aside）</p>

  <p>在传统三层网络中，为每个可寻址的接口（addressable interface endpoint）分配一个
IP 地址是很常见的操作。但这也引出一个问题：这些 IP 地址到底是属于一个接口，还
是这台 node？</p>

  <p>与此相关的一个更实际的问题是：如果一台 node 收到一个 ARP 请求，请求的 IP 是
node 的另外一个接口上的 IP，而并不是接收到 ARP 包的这个接口的 IP，那 node 需要
回 ARP 应答吗？
路由器的回答是 NO。如果想让路由器支持，必须打开“ARP 代理”（proxy-arp）功能。
Linux 的回答是 YES，它这样设计是为了使通信范围尽量大。</p>

  <p>ICMP 的设计进一步强化了接口必须有 IP 地址的思想。数据包转发失败的时候，ICMP 只
汇报有问题的 endpoint 的 IP 地址。它并不会报告其他信息，比如 endpoint 的域名（
DNS name）。这（打印 IP 地址）有什么帮助？traceroute 可以据此判断出哪台 node
的哪个接口出了问题。</p>

  <p>最后，给一根网线两端的接口配置同一网段的两个 IP 地址，是穷人验证网线是否工
作正常的方式。</p>
</blockquote>

<p><a name="chap_4.3"></a></p>

<h3 id="43-unnumbered-interfaces">4.3 Unnumbered Interfaces</h3>

<p><strong>Unnumbered Interface</strong>：没有配置 IP 地址的接口。</p>

<p><strong>注意，这种情况下，接口并不是没有 IP 地址，而是从 node 的其他接口借 IP 地址来用</strong>。
但是，如果被借的那个接口挂了，这个 IP 自然也就不可用了。因此，为了保证借来的 IP 永
远可用，<strong>被借的接口便永远不能挂，这个接口就是：loopback interface</strong>。</p>

<p>路由器能够在 unnumbered interface 上应答 ARP，因为接口可以借 IP。ICMP 和
traceroute 也能正常工作。那么，<strong>这样不就无法区分出一个包是从哪个接口进入
路由器的吗</strong>？</p>

<p><strong>Clos 网络的任意两个 node 之间只有一条链路</strong>，也即，<strong>任何两个 node 之间都只有唯一的
一对接口。因此不会出现上面提到的问题</strong>。如果有多条链路，的确会无法区分从哪个接口
进入路由器，但是多条链路的情况在 Clos 网络中是非常罕见的，原因在第一章分析过。</p>

<p>那么，路由协议是怎么处理 unnumbered interface 的呢？OSPF（运行在 IP 协议之上）可
以正常工作，其 RFC 里面描述了这方面的设计。大部分厂商的实现可能不支持，但
FRRouting 支持。Unnumbered OSPF 已经在很多生产环境部署。IS-IS，不依赖 IP 协议，
也可以在 unnumbered interface 场景下正常工作。</p>

<p><a name="chap_4.4"></a></p>

<h3 id="44-bgp-unnumbered">4.4 BGP Unnumbered</h3>

<p>BGP 到底是如何在接口没有 IP 的情况下正常工作的呢？</p>

<p>在路由协议的世界里有一个“鸡生蛋蛋生鸡”问题。<strong>如果路由协议是用来通告路由可达信息的
，那么它本身是如何知道对端的可达信息的呢？</strong>一些协议通过引入一个链路特定的组播地
址（link-specific multicast address）来解决（组播会限制在链路层）。BGP 不能这样
做，因为它依赖 TCP，而 TCP 需要的是单播而不是组播包。<strong>BGP 的解决方式是：连接路
由器的接口使用一个共享的子网</strong>。</p>

<blockquote>
  <p>同子网的接口之间通信只需要二层，不需要三层。子网之内的路由称为 connected route
，因为子网内都是在链路层直接可达的。</p>
</blockquote>

<p>回到 BGP peer 如何管理通信的问题，传统 eBGP 就是通过 connected route 发现邻居的
，无需其他配置。</p>

<p>那么，我们如何在没有用户配置，以及接口没有配置 IP 地址的情况下，发现对端的 IP 地
址的呢？</p>

<p>这就涉及到了 IPv6，以及一个有点晦涩的标准，<a href="https://tools.ietf.org/html/rfc5549">RFC
5549</a>。</p>

<ul>
  <li>IPv6：开启 LLA 和 RA（无需部署 IPv6 网络就可以用）</li>
  <li>RFC 5549：描述了下一跳为 IPv6 地址的 IPv4 路由</li>
</ul>

<h4 id="ipv6-router-advertisement">IPv6 Router Advertisement</h4>

<p>IPv6 的架构设计是：无需显式配置，网络就可以尽量正常地工作。因此，IPv6 网络中的每个 link
都会自动分配一个 IP 地址，并且是（在链路层）是唯一的，一般是根据 MAC 地址算出来
的。这个地址叫<strong>链路本地地址</strong>（Link Local Address，LLA）。LLA 只能被直连的邻居
访问，并且必须是通过这个 LLA 接口（即不支持 ARP 代理之类的）。</p>

<p>为了使得服务器可以自动发现路由器邻居（neighboring routers），引入了一个新的<strong>链路
层协议</strong>，称为<strong>路由器通告</strong>（Router Advertisement，RA）。启用后，RA 会定期通告接
口的 IPv6 地址，包括 LLA。因此各节点就可以自动发现其他节点的 IPv6 地址了。</p>

<p>现在，服务器和路由器都已经广泛支持 LLA 和 RA。</p>

<p>另外需要注意的是，<strong>使用 IPv6 LLA 并不需要部署 IPv6 网络；这种方案也并不涉及任何隧
道协议。IPv6 LLA 只是用于 BGP 创建连接。只需要开启 LLA 和 RA 功能即可</strong>。</p>

<h4 id="rfc-5594">RFC 5594</h4>

<p>LLA 和 RA 解决了 peer IP 的自动发现和 BGP 连接的建立，但是没有说明节点如何才能到
达 RA 里的路由。
在 BGP 中，这是通过 RA 里面的 NEXTHOP 属性实现的。<strong>如果 IPv4 路由可以使用 IPv6 地
址作为下一跳</strong>，那 unnumbered interface 的目标就能够实现。</p>

<p>BGP 支持多协议，单个连接上允许多种协议族的路由通告与撤回。因此，BGP IPv4 UPDATE
消息可以通过 IPv6 TCP 连接发送，反之亦然。这种方式也不需要任何的隧道技术。</p>

<p>BGP UPDATE 消息说，NEXTHOP 的协议必须与路由通告消息本身所使用的协议相同，即，
IPv4 路由只能通告 IPv4 下一跳，IPv6 路由只能通告 IPv6 下一跳。如果接口上没有
IPv4 地址，那 IPv4 下一跳是哪里呢？这就进入了 RFC 5549。</p>

<p>RFC 5549 解决的问题是：<strong>通过纯 IPv6 网络通告 IPv4 路由，并路由 IPv4 包</strong>（
advertisement of an IPv4 route and routing of an IPv4 packet over a pure IPv6
network）。即，它提供了一种<strong>下一跳是 IPv6 地址的 IPv4 路由</strong>（carray IPv4 routes
with an IPv6 nexthop）。</p>

<p>原理上来说这其实很好理解，因为二层网络中下一跳 IP 只是用来获
取对端的 MAC 地址（IPv4 ARP，IPV6 ND）。因此只要有同一接口上的任意一个地址（不管
是 IPv4 还是 IPv6），就可以获取到对端MAC，然后就可以将包发送到下一跳。</p>

<h4 id="基于-rfc-5549-实现转发">基于 RFC 5549 实现转发</h4>

<p>BGP 网络自动初始化过程：</p>

<p align="center"><img src="/assets/img/bgp-in-data-center/4-1.PNG" width="60%" height="60%" /></p>
<p align="center">图 4-1 BGP unnumbered packet timeline sequence</p>

<p>在 FRRouting 中，BGP 会将最优路由发送到一个叫<strong>路由信息数据库</strong>（Routing
Information Base，RIB）的进程（在FRRouting 中这个进程是 zebra）。</p>

<blockquote>
  <p>RIB 存储所有协议类型的路由，如果到同一路由有多条路径，RIB 会选择距离最短的一条
。</p>
</blockquote>

<p>我们假设收到一条路由通告，路由为 <code class="highlighter-rouge">10.1.1.0/24</code>。通过消息中的 NEXTHOP 可以拿到对
端的 MAC 地址。接下来RIB 会在路由表里将下一跳设为一个保留的（或看起来非法的）
IPv4 地址 169.254.0.1，然后在 ARP表里将这个 IP 地址对应的 MAC 地址设为对端接口的
MAC 地址。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ROUTE: 10.1.1.0/24 via 169.254.0.1 dev swp1
ARP: 169.254.0.1 dev swp1 lladdr 00:00:01:02:03:04 PERMANENT
</code></pre></div></div>

<p><strong>至此，就可以正常转发到这个 IPv4 网段的路由了（虽然路由器两端的接口都没有配置
IPv4 地址）。</strong></p>

<p>如果一段时间内没有收到这条路由的通告，就认为这条路由失效了，会删去上面的两行配置
。</p>

<p>总结：</p>

<ol>
  <li>BGP unnumbered 通过接口的 IPv6 LLA 和 peer 建立 BGP session</li>
  <li>IPv6 LLA 通过 RA 实现自动邻居发现</li>
  <li>RA 不仅包括 LLA 信息，还包括 MAC 信息</li>
  <li>BGP 通过 RFC 5549 实现 IPv4 routes over an IPv6 nexthop（IPv6 LLA）</li>
  <li>RIB 进程在 ARP 表里添加一条静态表项：MAC 地址为 RA 消息中的 MAC 地址，IP 为 一个保留的 IPv4 地址 169.254.0.1（其实是 IPv4 的 LLA）</li>
  <li>BGP 将下一跳是 IPv6 LLA 的 IPv4 路由交给 RIB</li>
  <li>RIB 将 nexthop 改为 169.254.0.1，然后添加到路由表</li>
</ol>

<h4 id="bgp-capability-to-negotiate-rfc-5549-use">BGP Capability to Negotiate RFC 5549 Use</h4>

<p>以 IPv6 作为下一跳的 IPv4 路由毕竟还是和通常的不太一样，因此 RFC 5549 定义了一个
新的能力，叫 <strong>extended nexthop</strong>，然后通过 peering session 进行协商，以判断两边
的 BGP 能力。</p>

<h5 id="互操作性">互操作性</h5>

<p>每个 eBGP peer 在发送路由通告之前，都会将 NEXTHOP 设为自己的 IP 地址。</p>

<p align="center"><img src="/assets/img/bgp-in-data-center/4-2.PNG" width="60%" height="60%" /></p>
<p align="center">图 4-2 基于 RFC 5549 的互操作</p>

<p>图 4-2，假设路由器 B 和 D 支持 RFC 5549，A 和 C 不支持。由于 A 和 C 不支持，因此
B 和 A 之间的接口以及 B 和 C 之间的接口，都需要配置 IPv4 IP 地址。</p>

<p>当 A 通告到 <code class="highlighter-rouge">10.1.1.0/24</code> 可达时，nexthop 地址必须填它自己的 IPv4 地址。当 B 收
到这个消息，进一步通告给 D 和 C 时，分两种情况：</p>

<ul>
  <li>通告给 D 时：nexthop 设置为 B 的 IPv6 LLA</li>
  <li>通告给 C 时：nexthop 设置为 B 的 IPv4 地址</li>
</ul>

<p>反向的类似。</p>

<p><a name="chap_4.5"></a></p>

<h3 id="45-remote-as-指定-bgp-session-类型">4.5 <code class="highlighter-rouge">remote-as</code> 指定 BGP session 类型</h3>

<p>以上配置消除了显示配置 IP 地址。接下来看如何通过 <code class="highlighter-rouge">remote-as</code> 配置 ASN。</p>

<p>配置 ASN 有两个主要目的：</p>

<ol>
  <li>安全考虑：多个管理域（administrative domain）互连，如果连错了，会有很大的安全
问题</li>
  <li>判断 BGP session 到底是 iGBP 还是 eBGP</li>
</ol>

<p>在数据中心内不存在跨管理域的问题，因此安全不是 ASN 的主要目的。因此，数据中心中
ASN 的主要目的就是判断 iBGP 还是 eBGP 控制着 session。</p>

<p>判断方法：<strong>从 BGP OPEN 消息中的 ASN 判断</strong>。</p>

<p><a name="chap_4.6"></a></p>

<h3 id="46-总结">4.6 总结</h3>

<p>通过避免接口的 IP 地址，以及通过 <code class="highlighter-rouge">remote-as</code> 指定 ASN 的类型（iBGP or eBGP），配
置可以简化成下面这样。可以看到，除了 <code class="highlighter-rouge">router bgp &lt;id&gt;</code> 和 <code class="highlighter-rouge">bgp router-id &lt;ip&gt;</code>
这两行需要单独配置之外，其他所有配置都是一样的，不管是对 Spine 还是 Leaf 节点。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// leaf01 configuration

log file /var/log/frr/frr.log

ip prefix-list DC_LOCAL_SUBNET 5 permit 10.1.0.0/16 le 26
ip prefix-list DC_LOCAL_SUBNET 10 permit 10.0.254.0/24 le 32
route-map ACCEPT_DC_LOCAL permit 10
  match ip-address DC_LOCAL_SUBNET

router bgp 65000
  bgp router-id 10.0.254.1
  neighbor peer-group ISL
  neighbor ISL remote-as external
  neighbor swp51 interface peer-group ISL
  neighbor swp52 interface peer-group ISL
  address-family ipv4 unicast
    neighbor ISL activate
    redistribute connected route-map ACCEPT_DC_LOCAL
</code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// spine01 configuration

log file /var/log/frr/frr.log

ip prefix-list DC_LOCAL_SUBNET 5 permit 10.1.0.0/16 le 26
ip prefix-list DC_LOCAL_SUBNET 10 permit 10.0.254.0/24 le 32
route-map ACCEPT_DC_LOCAL permit 10
  match ip-address DC_LOCAL_SUBNET

router bgp 65534
  bgp router-id 10.0.254.254
  neighbor peer-group ISL
  neighbor ISL remote-as external
  neighbor swp1 interface peer-group ISL
  neighbor swp2 interface peer-group ISL
  neighbor swp3 interface peer-group ISL
  neighbor swp4 interface peer-group ISL
  address-family ipv4 unicast
    neighbor ISL activate
    redistribute connected route-map ACCEPT_DC_LOCAL
</code></pre></div></div>

<p>这种配置，很适合用 ansible 之类的工具在多台节点上推了。</p>

<p>下一章：</p>

<ol>
  <li>查看配置</li>
  <li>管理 BGP</li>
  <li>配置 BGP 连接到外部网络</li>
</ol>

<p><a name="chap_5"></a></p>

<h2 id="5-bgp-生命周期管理">5 BGP 生命周期管理</h2>

<p>如何 BGP 配置之后，行为和预期的不一致，怎么排查？本章回答这些问题。</p>

<p><a name="chap_5.1"></a></p>

<h3 id="51-查看配置">5.1 查看配置</h3>

<h4 id="查看-bgp-session-信息">查看 BGP session 信息</h4>

<ul>
  <li><code class="highlighter-rouge">show ip bgp summary</code></li>
  <li><code class="highlighter-rouge">show ip bgp ipv4 unicast summary</code></li>
  <li><code class="highlighter-rouge">show ip bgp ipv6 unicast summary</code></li>
  <li><code class="highlighter-rouge">show ip bgp neighbors &lt;neibhor_name&gt;</code></li>
</ul>

<p align="center"><img src="/assets/img/bgp-in-data-center/5-1.PNG" width="60%" height="60%" /></p>
<p align="center">图 5-1 查看 BGP 网络信息</p>

<h4 id="查看当前路由">查看当前路由</h4>

<ul>
  <li><code class="highlighter-rouge">show ip gbp</code></li>
  <li><code class="highlighter-rouge">show bgp ipv4 unicast</code></li>
  <li><code class="highlighter-rouge">show ip gbp &lt;prefix&gt;</code></li>
</ul>

<p align="center"><img src="/assets/img/bgp-in-data-center/5-2.PNG" width="60%" height="60%" /></p>
<p align="center">图 5-2 查看 BGP 路由信息</p>

<p align="center"><img src="/assets/img/bgp-in-data-center/5-3.PNG" width="60%" height="60%" /></p>
<p align="center">图 5-3 查看 BGP 路由详细信息</p>

<p><a name="chap_5.2"></a></p>

<h3 id="52-连接到外部网络">5.2 连接到外部网络</h3>

<p align="center"><img src="/assets/img/bgp-in-data-center/5-4.PNG" width="60%" height="60%" /></p>
<p align="center">图 5-4 查看 BGP neighbor 详细信息</p>

<p>如图 5-4，两个 border leaf 节点 <code class="highlighter-rouge">exit01</code> 和 <code class="highlighter-rouge">exit02</code> 将数据中心网络连接到互联网
。Border leaf 的两个作用：</p>

<ol>
  <li>去掉私有 ASN（stripping off the private ASNs）</li>
  <li>可能会对数据中心内部路由做聚合，然后将聚合后的路由通告给边界路由器</li>
</ol>

<ul>
  <li>去私有 ASN：<code class="highlighter-rouge">neigbor &lt;neibhor_name&gt; remove-private-AS all</code></li>
  <li>聚合路由：<code class="highlighter-rouge">aggregate-address &lt;summary-route&gt; summary-only</code>，其中
<code class="highlighter-rouge">summary-only</code> 关键字表示，禁止通告单条路由（individual routes），如果没有指定
这个选项，聚合之后的路由和原始路由都会通告出去。</li>
</ul>

<p><a name="chap_5.3"></a></p>

<h3 id="53-计划节点维护">5.3 计划节点维护</h3>

<p>例如，如果计划对 spine01 进行升级，那要通知其他 peer 在计算最优路径时，要绕开
spine01。</p>

<p>第一章介绍过，现代数据中心都会有两个以上 Spine，中型到大型企业网一般都是 4 个
。如果是 4 个 spine，那维护一台时，网络仍然能提供 75% 的容量；如果是两台 spine，
那维护一台时，只能提供 50% 的容量。</p>

<p>如果服务器是双接入的（直连两个 ToR），那只有 50% 的链路利用率。大型互联网公司解
决这个问题的办法是：<strong>改用单接入（single-attach），庞大的机柜数量使得挂掉单个机柜
带来的影响足够小</strong>。另外还采用 16 或 32 spine，这样单个 spine 挂掉，只影响 1/16
或 1/32 的交换机间流量。</p>

<p>最常用的手段：<strong>将 node 的 ASN（重复）加在自己的路由通告里面，这样它的
AS_PATH 跳数就会比其他的路径要多，导致最优路径选择的时候，不会经过这个 node</strong>。</p>

<p>例如，要对 spine02 进行维护：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>route-map SCHED_MAINT permit 10
  <span class="nb">set </span>as-path prepend 65000 65000

neighbor ISL route-map SCHED_MAINT out
</code></pre></div></div>

<p>路由收敛之后，最优路径就会绕开 spine02：</p>

<p align="center"><img src="/assets/img/bgp-in-data-center/5-5.PNG" width="60%" height="60%" /></p>
<p align="center">图 5-5 最优路由绕开了 spine02</p>

<p>这种方式是比较通用的；另外也有一些其他方式完成类似功能，但不是所有实现都支持。</p>

<p><a name="chap_5.4"></a></p>

<h3 id="54-debug-bgp">5.4 Debug BGP</h3>

<p>打开 debug 开关，查看日志等。因实现而异。</p>

<p><a name="chap_5.5"></a></p>

<h3 id="55-总结">5.5 总结</h3>

<p><a name="chap_5"></a></p>

<h2 id="6-服务器上运行-bgp">6 服务器上运行 BGP</h2>

<p>现代数据中心颠覆了我们以往对计算和网络的所有认知。不管是 NoSQL 数据库、新
应用架构或微服务的出现，还是 Clos 网络用路由代替桥接做底层通信的方式，都为
以前既成的设计思想画上了句号。而这也影响了防火墙和负载均衡器等服务的部署。</p>

<p>本章将看到<strong>一种新网络模型</strong>：<strong>路由过程如何（从硬件交换设备）进入到了服务器内部</strong>，
以及我们如何对服务器做 BGP 配置以使它们和 ToR 或 leaf 通信。</p>

<p>传统来说，网络管理员的管理边界是 ToR，服务器内部的配置和管理由服务器管理员负责。
而在现代数据中心中，两种管理员已经开始合并为一种管理员，或者至少，网络管理员的管
理边界以及深入到了服务器内部。</p>

<p><a name="chap_6.1"></a></p>

<h3 id="61-虚拟服务器的兴起">6.1 虚拟服务器的兴起</h3>

<p>传统数据中心中，<strong>桥接和路由的边界</strong>，以及 <strong>L2-L3 网关</strong>，都是部署防火
墙和负载均衡器的地方。这些物理边界和传统的客户端/服务器模型边界也是比较匹配的。</p>

<p>Clos 网络打破了这些自然边界，使得以上部署模型都失效了。</p>

<p>新的数据中心中，服务都是跑在物理服务器内的虚拟机内，或者是没有虚拟化的物理
服务器。这些虚拟机都能够快速的创建和删除，随着应用流量而扩缩容。</p>

<h4 id="anycast-地址">Anycast 地址</h4>

<p>虚拟机会出现在数据中心的任意服务器内，因此 IP 不再会固定到单个机柜或路由器，多个
机柜可能会通告同一个 IP。通过路由的 ECMP 转发功能，包会被转发到最近的一个节点。
这种被多个实例同时通告的 IP 称为<strong>任播</strong>（Anycast） IP 地址。
它们属于单播（unicast）IP 地址，因此他们的目标是单个终点（作为对比，组播和广播的
目标是多个终点），但是，这个终点是路由过程（routing）决定的，从多个提供相关服务
的实例中选择一个。</p>

<p>ToR 如何发现或通告（discover or advertise）anycast IP？</p>

<p><a name="chap_6.2"></a></p>

<h3 id="62-交换机和服务器做-bgp-peering-的模型">6.2 交换机和服务器做 BGP Peering 的模型</h3>

<p>置顶交换机和服务器做 BGP Peering 有两种模型：</p>

<ol>
  <li>BGP unnumbered model，第 4 章介绍过了</li>
  <li>依赖 BGP 的一种称为动态邻居（dynamic neighbors）的特性</li>
</ol>

<p>接下来比较两种模型的异同。</p>

<p>两者相同的地方：</p>

<ul>
  <li>ASN 分配</li>
  <li>路由交换模型</li>
</ul>

<h4 id="asn-分配">ASN 分配</h4>

<p>最常见的部署方式：所有服务器共用一个 ASN。</p>

<p>优点：</p>

<ol>
  <li>配置和自动化简单</li>
  <li>从服务器识别和过滤路由简单</li>
</ol>

<p>缺点：</p>

<ol>
  <li>如果不仅仅是通过到达服务器的默认路由（more than the default route to the host
），那服务器上的配置会变得复杂</li>
  <li>跟踪哪个服务器通告出的路由比较困难，因为所有的服务器使用相同的 ASN</li>
</ol>

<p>第二种方案：<strong>直连相同 ToR 的服务器共用同一个 ASN</strong>，不同 ToR 下面的服务器使用不同
的 ASN。相当于每个机柜一个 ASN。</p>

<p>优点：<strong>服务器变成了新的 Clos 层</strong>（服务器和置顶交换机 full-mesh，确实是 Clos 架构的新的一层）。</p>

<p>缺点：和上面第一种方案缺点类似，不过现在每个 ASN 的范围缩小到了一个机柜。</p>

<p>第三种方案：每个服务器一个 ASN。我知道确实有一些人这样做，但是我觉得这样粒度细过
头了（overkill）。</p>

<p>优点：</p>

<ol>
  <li>完美映射到 Clos 网络模型，每个服务器都变成一个网络节点</li>
  <li>很容易判断路由是从哪个服务器通告出来的</li>
</ol>

<p>缺点：</p>

<ol>
  <li>ASN 数量和服务器数量一样多，考虑到服务器的数量成千上万，ASN 管理和维护会是一个潜在问题</li>
  <li>由于 ASN 数量非常多，必须得使用四字节 ASN 版本，可能和其他两字节 BGP 存在兼容性问题</li>
</ol>

<h4 id="路由交换模型">路由交换模型</h4>

<p>现在在网络层面，服务器也是一个路由器，和 leaf、spine 并没有区别，因此必须做好安全
控制。</p>

<p>第一，<strong>对服务器通告的路由，ToR 要能确定接受哪些，拒绝哪些</strong>。
例如：如果服务器通告了一个错误或非法路由，就会将部分流量引导到错误的地方。</p>

<p>第二，<strong>确保 ToR 不要将服务器当作（可以转发大量网络流量的）中间节点</strong>，服务器扛
不住这种硬件网络级别的流量。</p>

<p>第三，<strong>和服务器直连的路由器只通告默认路由，这样做是为
了避免路由器将太多路由通告到服务器，撑爆服务器的路由表</strong>，或影响最佳路由决策等等。</p>

<p>要满足以上条件，就需要用到我们第 3 章介绍的路由策略（routing policies）。例如，
下面是实现以上需求的路由策略：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ip prefix-list ANYCAST_VIP <span class="nb">seq </span>5 permit 10.1.1.1/32
ip prefix-list ANYCAST_VIP <span class="nb">seq </span>10 permit 20.5.10.110/32

ip prefix-list DEFONLY <span class="nb">seq </span>5 permit 0.0.0.0/0

route-map ACCEPT_ONLY_ANYCAST permit 10
  match ip address prefix-list ANYCAST_VIP

route-map ADVERTISE_DEFONLY permit 10
  match ip address prefix-list DEFONLY

neighbor server route-map ACCEPT_ONLY_ANYCAST <span class="k">in
</span>neighbor server route-map ADVERTISE_DEFONLY out
neighbor server default-originate
</code></pre></div></div>

<p>其中，</p>

<ul>
  <li><code class="highlighter-rouge">neighbor server route-map ACCEPT_ONLY_ANYCAST in</code> 实现了：从 server 来的路由通告，只接受 <code class="highlighter-rouge">ANYCAST_VIP</code>里面有的 anycast IP</li>
  <li><code class="highlighter-rouge">neighbor server route-map ADVERTISE_DEFONLY out</code> 实现了：只对 server 通告默认路由</li>
</ul>

<p><a name="chap_6.3"></a></p>

<h3 id="63-边界服务器-bgp-peering-方案">6.3 边界服务器 BGP Peering 方案</h3>

<p>部署<strong>防火墙和负载均衡器</strong>的 BGP 模型。有两种：</p>

<ul>
  <li>动态邻居（dynamic neighbors）</li>
  <li>BGP unnumbered</li>
</ul>

<h4 id="动态邻居">动态邻居</h4>

<p>BGP 默认监听所有 IP 过来的 TCP 连接请求。动态邻居是 BGP 的一个特性，可以指定<strong>只监听特
定网段过来的连接请求</strong>。</p>

<p>例如，一个机柜里的服务器一般都是同一网段。假设为 <code class="highlighter-rouge">10.1.0.0/26</code>。那对 ToR 做以下
配置，它就只会接受 <code class="highlighter-rouge">10.1.0.0/26</code> 网段的过来的、ASN 是 65530 的 peer 的建立连
接请求。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>neighbor servers peer-group
neighbor servers remote-as 65530
bgp listen range 10.1.0.0/26 peer-group servers
</code></pre></div></div>

<p>同理，对服务器做如下配置，可以限制它只和 ToR 建立连接：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>neighbor ISL peer-group
neighbor ISL remote-as external
neighbor 10.1.0.1 peer-group ISL
</code></pre></div></div>

<p>但是，动态邻居特性目前不支持针对接口做配置，例如不支持 <code class="highlighter-rouge">bgp listen interface
vlan10 peer-group servers</code>。</p>

<p>可以限制动态邻居的数量：<code class="highlighter-rouge">neighbor listen limit &lt;limit number&gt;</code>。</p>

<p>主要优点：和单接入服务器模型非常匹配，并且服务器要是通过 PXE（Preboot Execution
Environment）启动的。如图 6-1。</p>

<p align="center"><img src="/assets/img/bgp-in-data-center/6-1.PNG" width="60%" height="60%" /></p>
<p align="center">图 6-1 BGP 动态邻居模型</p>

<h4 id="bgp-unnumbered">BGP Unnumbered</h4>

<p>路由器和服务器之间也支持 BGP unnumbered，和第四章介绍的路由器之间的 unnumbered
类似。这种方式的拓扑如图 6-2：</p>

<p align="center"><img src="/assets/img/bgp-in-data-center/6-2.PNG" width="60%" height="60%" /></p>
<p align="center">图 6-2 BGP unnumbered 模型</p>

<p>动态邻居模型基于共享子网，而 unnumbered 模型不需要共享子网。和路由器类似，服务器
的 IP 地址和接口是没有关系的，一般配置为 loopback 地址。每个服务器可以分配一个
/32 地址。因为通告 IPv6 LLA 和路由器做 peer，因此无需共享的子网。</p>

<p>ToR 配置：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>neighbor peer-group servers
neighbor servers remote-as external
neighbor swp1 peer-group servers
neighbor swp2 peer-group servers
...
</code></pre></div></div>

<p>服务器配置：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>neighbor eth0 remote-as external
</code></pre></div></div>

<p>优点：</p>

<ol>
  <li>纯路由网络（服务器和置顶交换机也是路由），完全去掉了桥接</li>
  <li>单接入服务器、双接入服务器都支持，却不需要运行任何厂商相关的 multinode LACP</li>
</ol>

<p>缺点：</p>

<ol>
  <li>不支持 DHCPv4 或 PXE，因为 PXE-boot 过程中没有路由协议栈，而交换机不知道如何
转发包到特定的服务器</li>
</ol>

<p>有办法解决这个问题，但这超出了本身讨论的范围。</p>

<h4 id="服务器上可用的路由软件">服务器上可用的路由软件</h4>

<p>如果你是网络设计的老兵，你会意识到服务器上跑的 BGP 其实只是一个 GBP speaker，不
需要最优路径计算、将路由添加到路由表等全套 BGP 功能。大型互联网公司意识到了这一
点，因此他们会运行一些能作为 BGP speaker 的软件，例如 <a href="">ExaBGP</a>。</p>

<p>更注重全功能的软件有 <a href="https://bird.network.cz/">FRRouting</a>  和
<a href="https://bird.network.cz/">BIRD</a>。FRRouting 对 BGP unnumbered 和动态邻居两种模型
都支持。</p>

<p><a name="chap_6.4"></a></p>

<h3 id="64-总结">6.4 总结</h3>

<p>本章展示了如何将 BGP 扩展到服务器内部。</p>


  <!-- POST NAVIGATION -->
  <div class="postNav clearfix">
     
      <a class="prev" href="/blog/are-you-a-software-architect-zh/"><span>&laquo;&nbsp;[译] 你是一名软件架构师吗？</span>
      
    </a>
      
      
      <a class="next" href="/blog/internet-routing-architecture-zh/"><span>[笔记] Internet Routing Architecture (Cisco Press, 2000)&nbsp;&raquo;</span>
       
      </a>
     
  </div>
</div>


         

      </div>
   </div><!-- end .content -->

   <div class="footer">
   <div class="container">
      <p class="copy">&copy; 2016-2019
      <a href="https://arthurchiao.github.io">Arthur Chiao</a>, Powered by
      <a href="http://jekyllrb.com">Jekyll </a>, Theme originated from
      <a href="https://github.com/brianmaierjr/long-haul"> Long Haul.</a>

      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
      <span id="busuanzi_container_site_pv"> Site visits:
          <span id="busuanzi_value_site_pv"></span>, powered by<a href="http://busuanzi.ibruce.info/"> busuanzi</a>
      </span>

      </p>

      <div class="footer-links"> 
         <ul class="noList"> 
            
            <li><a href="https://www.facebook.com/profile.php?id=100014334455077">
                  <svg id="facebook-square" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M82.667,1H17.335C8.351,1,1,8.351,1,17.336v65.329c0,8.99,7.351,16.335,16.334,16.335h65.332 C91.652,99.001,99,91.655,99,82.665V17.337C99,8.353,91.652,1.001,82.667,1L82.667,1z M84.318,50H68.375v42.875H50V50h-8.855V35.973 H50v-9.11c0-12.378,5.339-19.739,19.894-19.739h16.772V22.3H72.967c-4.066-0.007-4.57,2.12-4.57,6.078l-0.023,7.594H86.75 l-2.431,14.027V50z"></path>
                  </svg>
            </a></li>
            
            
            <li><a href="https://linkedin.com/in/yanan-zhao-7691317b?trk=hp-identity-photo">
                  <svg id="linkedin" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M99.001,19.428c-3.606,1.608-7.48,2.695-11.547,3.184c4.15-2.503,7.338-6.466,8.841-11.189 c-3.885,2.318-8.187,4-12.768,4.908c-3.667-3.931-8.893-6.387-14.676-6.387c-11.104,0-20.107,9.054-20.107,20.223 c0,1.585,0.177,3.128,0.52,4.609c-16.71-0.845-31.525-8.895-41.442-21.131C6.092,16.633,5.1,20.107,5.1,23.813 c0,7.017,3.55,13.208,8.945,16.834c-3.296-0.104-6.397-1.014-9.106-2.529c-0.002,0.085-0.002,0.17-0.002,0.255 c0,9.799,6.931,17.972,16.129,19.831c-1.688,0.463-3.463,0.71-5.297,0.71c-1.296,0-2.555-0.127-3.783-0.363 c2.559,8.034,9.984,13.882,18.782,14.045c-6.881,5.424-15.551,8.657-24.971,8.657c-1.623,0-3.223-0.096-4.796-0.282 c8.898,5.738,19.467,9.087,30.82,9.087c36.982,0,57.206-30.817,57.206-57.543c0-0.877-0.02-1.748-0.059-2.617 C92.896,27.045,96.305,23.482,99.001,19.428z"></path>
                  </svg>
            </a></li>
            
            
            <li><a href="https://github.com/ArthurChiao">
                  <svg id="github" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M50,1C22.938,1,1,22.938,1,50s21.938,49,49,49s49-21.938,49-49S77.062,1,50,1z M79.099,79.099 c-3.782,3.782-8.184,6.75-13.083,8.823c-1.245,0.526-2.509,0.989-3.79,1.387v-7.344c0-3.86-1.324-6.699-3.972-8.517 c1.659-0.16,3.182-0.383,4.57-0.67c1.388-0.287,2.855-0.702,4.402-1.245c1.547-0.543,2.935-1.189,4.163-1.938 c1.228-0.75,2.409-1.723,3.541-2.919s2.082-2.552,2.847-4.067s1.372-3.334,1.818-5.455c0.446-2.121,0.67-4.458,0.67-7.01 c0-4.945-1.611-9.155-4.833-12.633c1.467-3.828,1.308-7.991-0.478-12.489l-1.197-0.143c-0.829-0.096-2.321,0.255-4.474,1.053 c-2.153,0.798-4.57,2.105-7.249,3.924c-3.797-1.053-7.736-1.579-11.82-1.579c-4.115,0-8.039,0.526-11.772,1.579 c-1.69-1.149-3.294-2.097-4.809-2.847c-1.515-0.75-2.727-1.26-3.637-1.532c-0.909-0.271-1.754-0.439-2.536-0.503 c-0.782-0.064-1.284-0.079-1.507-0.048c-0.223,0.031-0.383,0.064-0.478,0.096c-1.787,4.53-1.946,8.694-0.478,12.489 c-3.222,3.477-4.833,7.688-4.833,12.633c0,2.552,0.223,4.889,0.67,7.01c0.447,2.121,1.053,3.94,1.818,5.455 c0.765,1.515,1.715,2.871,2.847,4.067s2.313,2.169,3.541,2.919c1.228,0.751,2.616,1.396,4.163,1.938 c1.547,0.543,3.014,0.957,4.402,1.245c1.388,0.287,2.911,0.511,4.57,0.67c-2.616,1.787-3.924,4.626-3.924,8.517v7.487 c-1.445-0.43-2.869-0.938-4.268-1.53c-4.899-2.073-9.301-5.041-13.083-8.823c-3.782-3.782-6.75-8.184-8.823-13.083 C9.934,60.948,8.847,55.56,8.847,50s1.087-10.948,3.231-16.016c2.073-4.899,5.041-9.301,8.823-13.083s8.184-6.75,13.083-8.823 C39.052,9.934,44.44,8.847,50,8.847s10.948,1.087,16.016,3.231c4.9,2.073,9.301,5.041,13.083,8.823 c3.782,3.782,6.75,8.184,8.823,13.083c2.143,5.069,3.23,10.457,3.23,16.016s-1.087,10.948-3.231,16.016 C85.848,70.915,82.88,75.317,79.099,79.099L79.099,79.099z"></path>
                  </svg>
            </a></li>
             
            
            <li><a href="mailto:arthurchiao@hotmail.com">
                  <svg id="mail" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M50,1C22.938,1,1,22.938,1,50s21.938,49,49,49s49-21.938,49-49S77.062,1,50,1z M25.5,25.5h49 c0.874,0,1.723,0.188,2.502,0.542L50,57.544L22.998,26.041C23.777,25.687,24.626,25.499,25.5,25.5L25.5,25.5z M19.375,68.375v-36.75 c0-0.128,0.005-0.256,0.014-0.383l17.96,20.953L19.587,69.958C19.448,69.447,19.376,68.916,19.375,68.375L19.375,68.375z M74.5,74.5 h-49c-0.541,0-1.072-0.073-1.583-0.212l17.429-17.429L50,66.956l8.653-10.096l17.429,17.429C75.572,74.427,75.041,74.5,74.5,74.5 L74.5,74.5z M80.625,68.375c0,0.541-0.073,1.072-0.211,1.583L62.652,52.195l17.96-20.953c0.008,0.127,0.014,0.255,0.014,0.383 L80.625,68.375L80.625,68.375z"></path>
                  </svg>
            </a></li>
            
         </ul>
      </div>
   </div>
</div><!-- end .footer -->

   <!-- Add jQuery and other scripts -->
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src=""><\/script>')</script>
<script src="/assets/js/dropcap.min.js"></script>
<script src="/assets/js/responsive-nav.min.js"></script>
<script src="/assets/js/scripts.js"></script>


</body>

</html>
