<!DOCTYPE html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7"><![endif]-->
<!--[if IE 7]><html class="no-js lt-ie9 lt-ie8" <![endif]-->
<!--[if IE 8]><html class="no-js lt-ie9" <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->

<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
       new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
       j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
       'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
       })(window,document,'script','dataLayer','GTM-WP54B9K');</script>
    <!-- End Google Tag Manager -->

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <title>[译] Linux网络栈监控和调优：发送数据 3</title>

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="/assets/img/favicon.ico" />

    <!-- Come and get me RSS readers -->
    <link rel="alternate" type="application/rss+xml" title="ArthurChiao's Blog" href="http://0.0.0.0:4000/feed.xml" />
    
    <!-- Stylesheet -->
    <link rel="stylesheet" href="/assets/css/style.css">
    <!--[if IE 8]><link rel="stylesheet" href="/assets/css/ie.css"><![endif]-->
    <link rel="canonical" href="http://0.0.0.0:4000/blog/tuning-stack-tx-zh-3/">

    <!-- Modernizr -->
    <script src="/assets/js/modernizr.custom.15390.js" type="text/javascript"></script>

    
</head>


<body>
  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WP54B9K"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->

    <div class="header">
     <div class="container">
         <h1 class="logo"><a href="/">ArthurChiao's Blog</a></h1>
         <nav class="nav-collapse">
             <ul class="noList">
                 
                   
                   
                   <li class="element first  ">
                     <a href="/index.html">Home</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/articles">Articles</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/articles-zh">Articles (中文)</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/categories">Categories</a>
                   </li> 
                 
                   
                   
                   <li class="element   last">
                     <a href="/about">About</a>
                   </li> 
                 
                 <!-- <li> <a href="https://github.com/arthurchiao/reading" target="_blank">Reading</a></li> -->
                 <!-- <li> <a href="https://github.com/arthurchiao/" target="_blank">GitHub</a></li> -->
             </ul>
         </nav>
     </div>
 </div><!-- end .header -->


   <div class="content">
      <div class="container">
         <div class="post">
  
  <h1 class="postTitle">[译] Linux网络栈监控和调优：发送数据 3</h1>
  <p class="meta">2018-12-17 | <span class="time">37</span> Minute Read</p>

  
  
  <h2 id="5-udp协议层">5 UDP协议层</h2>

<h3 id="51-udp_sendmsg">5.1 <code class="highlighter-rouge">udp_sendmsg</code></h3>

<p>这个函数定义在
<a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/udp.c#L845-L1088">net/ipv4/udp.c</a>
，函数非常长，我们分段来看。</p>

<h4 id="511-udp-corking软木塞">5.1.1 UDP corking（软木塞）</h4>

<p>在变量声明和基本错误检查之后，<code class="highlighter-rouge">udp_sendmsg</code>所做的第一件事就是检查socket是否“
塞住”了（corked）。 UDP corking是一项优化技术，允许内核将多次数据累积成单个数据报发
送。在用户程序中有两种方法可以启用此选项：</p>

<ol>
  <li>使用<code class="highlighter-rouge">setsockopt</code>系统调用设置socket的<code class="highlighter-rouge">UDP_CORK</code>选项</li>
  <li>程序调用<code class="highlighter-rouge">send</code>，<code class="highlighter-rouge">sendto</code>或<code class="highlighter-rouge">sendmsg</code>时，带<code class="highlighter-rouge">MSG_MORE</code>参数</li>
</ol>

<p>详细信息参考 <a href="http://man7.org/linux/man-pages/man7/udp.7.html">UDP man page</a>和
<a href="http://man7.org/linux/man-pages/man2/send.2.html"><code class="highlighter-rouge">send/sendto/sendmsg</code> man
page</a>。</p>

<p><code class="highlighter-rouge">udp_sendmsg</code>代码检查<code class="highlighter-rouge">up-&gt;pending</code>以确定socket当前是否已被塞住(corked)，如果是，
则直接跳到<code class="highlighter-rouge">do_append_data</code>进行数据追加(append)。 我们将在稍后看到如何追加数据。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">udp_sendmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
                <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>

    <span class="cm">/* variables and error checking ... */</span>

  <span class="n">fl4</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">inet</span><span class="o">-&gt;</span><span class="n">cork</span><span class="p">.</span><span class="n">fl</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ip4</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">up</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">)</span> <span class="p">{</span>
          <span class="cm">/*
           * There are pending frames.
           * The socket lock must be held while it's corked.
           */</span>
          <span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">up</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">))</span> <span class="p">{</span>
                  <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">up</span><span class="o">-&gt;</span><span class="n">pending</span> <span class="o">!=</span> <span class="n">AF_INET</span><span class="p">))</span> <span class="p">{</span>
                          <span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
                          <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
                  <span class="p">}</span>
                  <span class="k">goto</span> <span class="n">do_append_data</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div></div>

<h4 id="512-获取目的ip地址和端口">5.1.2 获取目的IP地址和端口</h4>

<p>接下来获取目标地址和端口，有两个可能的来源：</p>

<ol>
  <li>如果之前socket已经建立连接，那socket本身就存储了目标地址</li>
  <li>地址通过辅助结构（<code class="highlighter-rouge">struct msghdr</code>）传入，正如我们在<code class="highlighter-rouge">sendto</code>的内核代码中看到的那样</li>
</ol>

<p>具体逻辑：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 *      Get and verify the address.
 */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_name</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="n">usin</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_name</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_namelen</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">usin</span><span class="p">))</span>
                  <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">usin</span><span class="o">-&gt;</span><span class="n">sin_family</span> <span class="o">!=</span> <span class="n">AF_INET</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">if</span> <span class="p">(</span><span class="n">usin</span><span class="o">-&gt;</span><span class="n">sin_family</span> <span class="o">!=</span> <span class="n">AF_UNSPEC</span><span class="p">)</span>
                          <span class="k">return</span> <span class="o">-</span><span class="n">EAFNOSUPPORT</span><span class="p">;</span>
          <span class="p">}</span>

          <span class="n">daddr</span> <span class="o">=</span> <span class="n">usin</span><span class="o">-&gt;</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">;</span>
          <span class="n">dport</span> <span class="o">=</span> <span class="n">usin</span><span class="o">-&gt;</span><span class="n">sin_port</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">dport</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                  <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">TCP_ESTABLISHED</span><span class="p">)</span>
                  <span class="k">return</span> <span class="o">-</span><span class="n">EDESTADDRREQ</span><span class="p">;</span>
          <span class="n">daddr</span> <span class="o">=</span> <span class="n">inet</span><span class="o">-&gt;</span><span class="n">inet_daddr</span><span class="p">;</span>
          <span class="n">dport</span> <span class="o">=</span> <span class="n">inet</span><span class="o">-&gt;</span><span class="n">inet_dport</span><span class="p">;</span>
          <span class="cm">/* Open fast path for connected socket.
             Route will not be used, if at least one option is set.
           */</span>
          <span class="n">connected</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>是的，你没看错，UDP代码中出现了<code class="highlighter-rouge">TCP_ESTABLISHED</code>！UDP socket的状态使用了TCP状态
来描述，不知道是好是坏。</p>

<p>回想前面我们看到用户程序调用<code class="highlighter-rouge">sendto</code>时，内核如何替用户初始化一个<code class="highlighter-rouge">struct msghdr</code>
变量。上面的代码显示了内核如何解析该变量以便设置<code class="highlighter-rouge">daddr</code>和<code class="highlighter-rouge">dport</code>。</p>

<p>如果没有<code class="highlighter-rouge">struct msghdr</code>变量，内核函数到达<code class="highlighter-rouge">udp_sendmsg</code>函数时，会从socket本身检索
目标地址和端口，并将socket标记为“已连接”。</p>

<h4 id="513-socket发送bookkeeping和打时间戳">5.1.3 Socket发送：bookkeeping和打时间戳</h4>

<p>接下来，获取存储在socket上的源地址、设备索引（device index）和时间戳选项（例
如<code class="highlighter-rouge">SOCK_TIMESTAMPING_TX_HARDWARE</code>, <code class="highlighter-rouge">SOCK_TIMESTAMPING_TX_SOFTWARE</code>,
<code class="highlighter-rouge">SOCK_WIFI_STATUS</code>）：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ipc</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">inet</span><span class="o">-&gt;</span><span class="n">inet_saddr</span><span class="p">;</span>

<span class="n">ipc</span><span class="p">.</span><span class="n">oif</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_bound_dev_if</span><span class="p">;</span>

<span class="n">sock_tx_timestamp</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ipc</span><span class="p">.</span><span class="n">tx_flags</span><span class="p">);</span>
</code></pre></div></div>

<h4 id="514-辅助消息ancillary-messages">5.1.4 辅助消息（Ancillary messages）</h4>

<p>除了发送或接收数据包之外，<code class="highlighter-rouge">sendmsg</code>和<code class="highlighter-rouge">recvmsg</code>系统调用还允许用户设置或请求辅助数
据。用户程序可以通过将请求信息组织成<code class="highlighter-rouge">struct msghdr</code>类型变量来利用此辅助数据。一些辅
助数据类型记录在<a href="http://man7.org/linux/man-pages/man7/ip.7.html">IP man page</a>中
。</p>

<p>辅助数据的一个常见例子是<code class="highlighter-rouge">IP_PKTINFO</code>。对于<code class="highlighter-rouge">sendmsg</code>，<code class="highlighter-rouge">IP_PKTINFO</code>允许程序在发送
数据时设置一个<code class="highlighter-rouge">in_pktinfo</code>变量。程序可以通过填写<code class="highlighter-rouge">struct in_pktinfo</code>变量中的字段
来指定要在packet上使用的源地址。如果程序是监听多个IP地址的服务端程序，那这是一个
很有用的选项。在这种情况下，服务端可能想使用客户端连接服务端的那个IP地址来回复客
户端，<code class="highlighter-rouge">IP_PKTINFO</code>非常适合这种场景。</p>

<p><code class="highlighter-rouge">setsockopt</code>可以在<strong>socket级别</strong>设置发送包的
<a href="https://en.wikipedia.org/wiki/Time_to_live#IP_packets">IP_TTL</a>和
<a href="https://en.wikipedia.org/wiki/Type_of_service">IP_TOS</a>。而辅助消息允
许在每个<strong>数据包级别</strong>设置TTL和TOS值。Linux内核会使用一个<a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/route.c#L179-L197">数组
</a>将TOS
转换为优先级，后者会影响数据包如何以及合适从qdisc中发送出去。我们稍后会了解到这
意味着什么。</p>

<p>我们可以看到内核如何在UDP socket上处理<code class="highlighter-rouge">sendmsg</code>的辅助消息：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_controllen</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">ip_cmsg_send</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">msg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ipc</span><span class="p">,</span>
                           <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span> <span class="o">==</span> <span class="n">AF_INET6</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ipc</span><span class="p">.</span><span class="n">opt</span><span class="p">)</span>
                <span class="n">free</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">connected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>解析辅助消息的工作是由<code class="highlighter-rouge">ip_cmsg_send</code>完成的，定义在
<a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/ip_sockglue.c#L190-L241">net/ipv4/ip_sockglue.c</a>
。注意，传递一个未初始化的辅助数据，将会把这个socket标记为“未建立连接的”（译者注
：因为从5.1.2的代码可以看出，有辅助消息时优先处理辅助消息，没有辅助消息才从socket
里面拿信息）。</p>

<h4 id="515-设置自定义-ip-选项">5.1.5 设置自定义 IP 选项</h4>

<p>接下来，<code class="highlighter-rouge">sendmsg</code>将检查用户是否通过辅助消息设置了的任何自定义IP选项。如果设置了
，将使用这些自定义值；如果没有，那就使用socket中（已经在用）的参数：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ipc</span><span class="p">.</span><span class="n">opt</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">ip_options_rcu</span> <span class="o">*</span><span class="n">inet_opt</span><span class="p">;</span>

        <span class="n">rcu_read_lock</span><span class="p">();</span>
        <span class="n">inet_opt</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">inet</span><span class="o">-&gt;</span><span class="n">inet_opt</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">inet_opt</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">opt_copy</span><span class="p">,</span> <span class="n">inet_opt</span><span class="p">,</span>
                       <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">inet_opt</span><span class="p">)</span> <span class="o">+</span> <span class="n">inet_opt</span><span class="o">-&gt;</span><span class="n">opt</span><span class="p">.</span><span class="n">optlen</span><span class="p">);</span>
                <span class="n">ipc</span><span class="p">.</span><span class="n">opt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">opt_copy</span><span class="p">.</span><span class="n">opt</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>接下来，该函数检查是否设置了源记录路由（source record route, SRR）IP选项。
SRR有两种类型：<a href="https://en.wikipedia.org/wiki/Loose_Source_Routing">宽松源记录路由和严格源记录路由</a>。
如果设置了此选项，则会记录第一跳地址并将其保存到<code class="highlighter-rouge">faddr</code>，并将socket标记为“未连接”。
这将在后面用到：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ipc</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">faddr</span> <span class="o">=</span> <span class="n">daddr</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">ipc</span><span class="p">.</span><span class="n">opt</span> <span class="o">&amp;&amp;</span> <span class="n">ipc</span><span class="p">.</span><span class="n">opt</span><span class="o">-&gt;</span><span class="n">opt</span><span class="p">.</span><span class="n">srr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">daddr</span><span class="p">)</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
        <span class="n">faddr</span> <span class="o">=</span> <span class="n">ipc</span><span class="p">.</span><span class="n">opt</span><span class="o">-&gt;</span><span class="n">opt</span><span class="p">.</span><span class="n">faddr</span><span class="p">;</span>
        <span class="n">connected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>处理完SRR选项后，将处理TOS选项，这可以从辅助消息中获取，或者从socket当前值中获取。
然后检查：</p>

<ol>
  <li>是否（使用<code class="highlighter-rouge">setsockopt</code>）在socket上设置了<code class="highlighter-rouge">SO_DONTROUTE</code>，或</li>
  <li>是否（调用<code class="highlighter-rouge">sendto</code>或<code class="highlighter-rouge">sendmsg</code>时）指定了<code class="highlighter-rouge">MSG_DONTROUTE</code>标志，或</li>
  <li>是否已设置了<code class="highlighter-rouge">is_strictroute</code>，表示需要严格的
<a href="http://www.networksorcery.com/enp/protocol/ip/option009.htm">SRR</a></li>
</ol>

<p>任何一个为真，<code class="highlighter-rouge">tos</code>字段的<code class="highlighter-rouge">RTO_ONLINK</code>位将置1，并且socket被视为“未连接”：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tos</span> <span class="o">=</span> <span class="n">get_rttos</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipc</span><span class="p">,</span> <span class="n">inet</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_LOCALROUTE</span><span class="p">)</span> <span class="o">||</span>
    <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">MSG_DONTROUTE</span><span class="p">)</span> <span class="o">||</span>
    <span class="p">(</span><span class="n">ipc</span><span class="p">.</span><span class="n">opt</span> <span class="o">&amp;&amp;</span> <span class="n">ipc</span><span class="p">.</span><span class="n">opt</span><span class="o">-&gt;</span><span class="n">opt</span><span class="p">.</span><span class="n">is_strictroute</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">tos</span> <span class="o">|=</span> <span class="n">RTO_ONLINK</span><span class="p">;</span>
        <span class="n">connected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="516-多播或单播multicast-or-unicast">5.1.6 多播或单播（Multicast or unicast）</h4>

<p>接下来代码开始处理multicast。这有点复杂，因为用户可以通过<code class="highlighter-rouge">IP_PKTINFO</code>辅助消息
来指定发送包的源地址或设备号，如前所述。</p>

<p>如果目标地址是多播地址：</p>

<ol>
  <li>将多播设备（device）的索引（index）设置为发送（写）这个packet的设备索引，并且</li>
  <li>packet的源地址将设置为multicast源地址</li>
</ol>

<p>如果目标地址不是一个组播地址，则发送packet的设备制定为<code class="highlighter-rouge">inet-&gt;uc_index</code>（单播），
除非用户使用<code class="highlighter-rouge">IP_PKTINFO</code>辅助消息覆盖了它。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">ipv4_is_multicast</span><span class="p">(</span><span class="n">daddr</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ipc</span><span class="p">.</span><span class="n">oif</span><span class="p">)</span>
                <span class="n">ipc</span><span class="p">.</span><span class="n">oif</span> <span class="o">=</span> <span class="n">inet</span><span class="o">-&gt;</span><span class="n">mc_index</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">saddr</span><span class="p">)</span>
                <span class="n">saddr</span> <span class="o">=</span> <span class="n">inet</span><span class="o">-&gt;</span><span class="n">mc_addr</span><span class="p">;</span>
        <span class="n">connected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ipc</span><span class="p">.</span><span class="n">oif</span><span class="p">)</span>
        <span class="n">ipc</span><span class="p">.</span><span class="n">oif</span> <span class="o">=</span> <span class="n">inet</span><span class="o">-&gt;</span><span class="n">uc_index</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="517-路由">5.1.7 路由</h4>

<p>现在开始路由！</p>

<p>UDP层中处理路由的代码以<strong>快速路径</strong>（fast path）开始。 如果socket已连接，则直接尝试获取路由：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">connected</span><span class="p">)</span>
        <span class="n">rt</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rtable</span> <span class="o">*</span><span class="p">)</span><span class="n">sk_dst_check</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>

<p>如果socket未连接，或者虽然已连接，但路由辅助函数<code class="highlighter-rouge">sk_dst_check</code>认定路由已过期，则代码将进入<strong>慢速路径</strong>（slow
path）以生成一条路由记录。首先调用<code class="highlighter-rouge">flowi4_init_output</code>构造一个描述此UDP流的变量：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">rt</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

        <span class="n">fl4</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fl4_stack</span><span class="p">;</span>
        <span class="n">flowi4_init_output</span><span class="p">(</span><span class="n">fl4</span><span class="p">,</span> <span class="n">ipc</span><span class="p">.</span><span class="n">oif</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_mark</span><span class="p">,</span> <span class="n">tos</span><span class="p">,</span>
                           <span class="n">RT_SCOPE_UNIVERSE</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_protocol</span><span class="p">,</span>
                           <span class="n">inet_sk_flowi_flags</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">|</span><span class="n">FLOWI_FLAG_CAN_SLEEP</span><span class="p">,</span>
                           <span class="n">faddr</span><span class="p">,</span> <span class="n">saddr</span><span class="p">,</span> <span class="n">dport</span><span class="p">,</span> <span class="n">inet</span><span class="o">-&gt;</span><span class="n">inet_sport</span><span class="p">);</span>
</code></pre></div></div>

<p>然后，socket及其flow实例会传递给安全子系统，这样<a href="https://en.wikipedia.org/wiki/Security-Enhanced_Linux">SELinux</a>或<a href="https://en.wikipedia.org/wiki/Smack_(software)">SMACK</a>这样的系统就可以在flow实例上设置安全ID。
接下来，<code class="highlighter-rouge">ip_route_output_flow</code>将调用IP路由代码，创建一个路由实例：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">security_sk_classify_flow</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flowi4_to_flowi</span><span class="p">(</span><span class="n">fl4</span><span class="p">));</span>
<span class="n">rt</span> <span class="o">=</span> <span class="n">ip_route_output_flow</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">fl4</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
</code></pre></div></div>

<p>如果创建路由实例失败，并且返回码是 <code class="highlighter-rouge">ENETUNREACH</code>,
则<code class="highlighter-rouge">OUTNOROUTES</code>计数器将会加1。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">rt</span><span class="p">))</span> <span class="p">{</span>
  <span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">rt</span><span class="p">);</span>
  <span class="n">rt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENETUNREACH</span><span class="p">)</span>
    <span class="n">IP_INC_STATS</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">IPSTATS_MIB_OUTNOROUTES</span><span class="p">);</span>
  <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这些统计计数器所在的源文件、其他可用的计数器及其含义，将将在下面的UDP监控部分讨
论。</p>

<p>接下来，如果是广播路由，但socket的<code class="highlighter-rouge">SOCK_BROADCAST</code>选项未设置，则处理过程终止。
如果socket被视为“已连接”，则路由实例将缓存到socket上：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
<span class="k">if</span> <span class="p">((</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">rt_flags</span> <span class="o">&amp;</span> <span class="n">RTCF_BROADCAST</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
    <span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_BROADCAST</span><span class="p">))</span>
        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">connected</span><span class="p">)</span>
        <span class="n">sk_dst_set</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">dst_clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">));</span>
</code></pre></div></div>

<h4 id="518-msg_confirm-阻止arp缓存过期">5.1.8 <code class="highlighter-rouge">MSG_CONFIRM</code>: 阻止ARP缓存过期</h4>

<p>如果调用<code class="highlighter-rouge">send</code>, <code class="highlighter-rouge">sendto</code>或<code class="highlighter-rouge">sendmsg</code>的时候指定了<code class="highlighter-rouge">MSG_CONFIRM</code>参数，UDP协议层将会如下处理：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span><span class="o">&amp;</span><span class="n">MSG_CONFIRM</span><span class="p">)</span>
          <span class="k">goto</span> <span class="n">do_confirm</span><span class="p">;</span>
<span class="n">back_from_confirm</span><span class="o">:</span>
</code></pre></div></div>

<p>该标志提示系统去确认一下ARP缓存条目是否仍然有效，防止其被垃圾回收。
<code class="highlighter-rouge">do_confirm</code>标签位于此函数末尾处，很简单：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">do_confirm:</span>
        <span class="n">dst_confirm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span><span class="o">&amp;</span><span class="n">MSG_PROBE</span><span class="p">)</span> <span class="o">||</span> <span class="n">len</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">back_from_confirm</span><span class="p">;</span>
        <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">dst_confirm</code>函数只是在相应的缓存条目上设置一个标记位，稍后当查询邻居缓存并找到
条目时将检查该标志，我们后面一些会看到。此功能通常用于UDP网络应用程序，以减少
不必要的ARP流量。</p>

<p>此代码确认缓存条目然后跳回<code class="highlighter-rouge">back_from_confirm</code>标签。</p>

<p>一旦<code class="highlighter-rouge">do_confirm</code>代码跳回到<code class="highlighter-rouge">back_from_confirm</code>（或者之前就没有执行到<code class="highlighter-rouge">do_confirm</code>
），代码接下来将处理UDP cork和uncorked情况。</p>

<h4 id="519-uncorked-udp-sockets快速路径准备待发送数据">5.1.9 uncorked UDP sockets快速路径：准备待发送数据</h4>

<p>如果不需要corking，数据就可以封装到一个<code class="highlighter-rouge">struct sk_buff</code>实例中并传递给
<code class="highlighter-rouge">udp_send_skb</code>，离IP协议层更进了一步。这是通过调用<code class="highlighter-rouge">ip_make_skb</code>来完成的。</p>

<p>注意，先前通过调用<code class="highlighter-rouge">ip_route_output_flow</code>生成的路由条目也会一起传进来，
它将保存到skb里，稍后在IP协议层中被使用。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Lockless fast path for the non-corking case. */</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">corkreq</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">skb</span> <span class="o">=</span> <span class="n">ip_make_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">fl4</span><span class="p">,</span> <span class="n">getfrag</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span> <span class="n">ulen</span><span class="p">,</span>
                          <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">udphdr</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ipc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rt</span><span class="p">,</span>
                          <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span><span class="p">);</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
                <span class="n">err</span> <span class="o">=</span> <span class="n">udp_send_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">fl4</span><span class="p">);</span>
        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">ip_make_skb</code>函数将创建一个skb，其中需要考虑到很多的事情，例如：</p>

<ol>
  <li><a href="https://blog.packagecloud.io/eng/2017/02/06/monitoring-tuning-linux-networking-stack-sending-data/Maximum_transmission_unit">MTU</a></li>
  <li>UDP corking（如果启用）</li>
  <li>UDP Fragmentation Offloading（<a href="https://wiki.linuxfoundation.org/networking/ufo">UFO</a>）</li>
  <li>Fragmentation（分片）：如果硬件不支持UFO，但是要传输的数据大于MTU，需要软件做分片</li>
</ol>

<p>大多数网络设备驱动程序不支持UFO，因为网络硬件本身不支持此功能。我们来看下这段代码，先看corking禁用的情况，启用的情况我们更后面再看。</p>

<h5 id="ip_make_skb"><code class="highlighter-rouge">ip_make_skb</code></h5>

<p>定义在<a href="">net/ipv4/ip_output.c</a>，这个函数有点复杂。</p>

<p>构建skb的时候，<code class="highlighter-rouge">ip_make_skb</code>依赖的底层代码需要使用一个corking变量和一个queue变量
，skb将通过queue变量传入。如果socket未被cork，则会传入一个假的corking变量和一个
空队列。</p>

<p>我们来看看假corking变量和空队列是如何初始化的：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">ip_make_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="cm">/* more args */</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">inet_cork</span> <span class="n">cork</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">queue</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_PROBE</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="n">__skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">);</span>

        <span class="n">cork</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">cork</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">cork</span><span class="p">.</span><span class="n">opt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">ip_setup_cork</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cork</span><span class="p">,</span> <span class="cm">/* more args */</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
</code></pre></div></div>

<p>如上所示，cork和queue都是在栈上分配的，<code class="highlighter-rouge">ip_make_skb</code>根本不需要它。
<code class="highlighter-rouge">ip_setup_cork</code>初始化cork变量。接下来，调用<code class="highlighter-rouge">__ip_append_data</code>并传入cork和queue变
量：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">err</span> <span class="o">=</span> <span class="n">__ip_append_data</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">fl4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cork</span><span class="p">,</span>
                       <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">task_frag</span><span class="p">,</span> <span class="n">getfrag</span><span class="p">,</span>
                       <span class="n">from</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">transhdrlen</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
</code></pre></div></div>

<p>我们将在后面看到这个函数是如何工作的，因为不管socket是否被cork，最后都会执行它。</p>

<p>现在，我们只需要知道<code class="highlighter-rouge">__ip_append_data</code>将创建一个skb，向其追加数据，并将该skb添加
到传入的queue变量中。如果追加数据失败，则调用<code class="highlighter-rouge">__ip_flush_pending_frame</code>丢弃数据
并向上返回错误（指针类型）：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">__ip_flush_pending_frames</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cork</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>最后，如果没有发生错误，<code class="highlighter-rouge">__ip_make_skb</code>将skb出队，添加IP选项，并返回一个准备好传
递给更底层发送的skb：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">return</span> <span class="n">__ip_make_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">fl4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cork</span><span class="p">);</span>
</code></pre></div></div>

<h5 id="发送数据">发送数据</h5>

<p>如果没有错误，skb就会交给<code class="highlighter-rouge">udp_send_skb</code>，后者会继续将其传给下一层协议，IP协议：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">udp_send_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">fl4</span><span class="p">);</span>
<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
</code></pre></div></div>

<p>如果有错误，错误计数就会有相应增加。后面的“错误计数”部分会详细介绍。</p>

<h4 id="5110-没有被cork的数据时的慢路径">5.1.10 没有被cork的数据时的慢路径</h4>

<p>如果使用了UDP corking，但之前没有数据被cork，则慢路径开始：</p>

<ol>
  <li>对socket加锁</li>
  <li>检查应用程序是否有bug：已经被cork的socket是否再次被cork</li>
  <li>设置该UDP flow的一些参数，为corking做准备</li>
  <li>将要发送的数据追加到现有数据</li>
</ol>

<p><code class="highlighter-rouge">udp_sendmsg</code>代码继续向下看，就是这一逻辑：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">up</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">))</span> <span class="p">{</span>
          <span class="cm">/* The socket is already corked while preparing it. */</span>
          <span class="cm">/* ... which is an evident application bug. --ANK */</span>
          <span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

          <span class="n">LIMIT_NETDEBUG</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="n">pr_fmt</span><span class="p">(</span><span class="s">"cork app bug 2</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
          <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
          <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="cm">/*
   *      Now cork the socket to pend data.
   */</span>
  <span class="n">fl4</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">inet</span><span class="o">-&gt;</span><span class="n">cork</span><span class="p">.</span><span class="n">fl</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ip4</span><span class="p">;</span>
  <span class="n">fl4</span><span class="o">-&gt;</span><span class="n">daddr</span> <span class="o">=</span> <span class="n">daddr</span><span class="p">;</span>
  <span class="n">fl4</span><span class="o">-&gt;</span><span class="n">saddr</span> <span class="o">=</span> <span class="n">saddr</span><span class="p">;</span>
  <span class="n">fl4</span><span class="o">-&gt;</span><span class="n">fl4_dport</span> <span class="o">=</span> <span class="n">dport</span><span class="p">;</span>
  <span class="n">fl4</span><span class="o">-&gt;</span><span class="n">fl4_sport</span> <span class="o">=</span> <span class="n">inet</span><span class="o">-&gt;</span><span class="n">inet_sport</span><span class="p">;</span>
  <span class="n">up</span><span class="o">-&gt;</span><span class="n">pending</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>

<span class="n">do_append_data</span><span class="o">:</span>
  <span class="n">up</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">ulen</span><span class="p">;</span>
  <span class="n">err</span> <span class="o">=</span> <span class="n">ip_append_data</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">fl4</span><span class="p">,</span> <span class="n">getfrag</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span> <span class="n">ulen</span><span class="p">,</span>
                       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">udphdr</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ipc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rt</span><span class="p">,</span>
                       <span class="n">corkreq</span> <span class="o">?</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span><span class="o">|</span><span class="n">MSG_MORE</span> <span class="o">:</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span><span class="p">);</span>
</code></pre></div></div>

<h5 id="ip_append_data"><code class="highlighter-rouge">ip_append_data</code></h5>

<p>这个函数简单封装了<code class="highlighter-rouge">__ip_append_data</code>，在调用后者之前，做了两件重要的事情：</p>

<ol>
  <li>检查是否从用户传入了<code class="highlighter-rouge">MSG_PROBE</code>标志。该标志表示用户不想真正发送数据，只是做路
径探测（例如，确定<a href="https://en.wikipedia.org/wiki/Path_MTU_Discovery">PMTU</a>）</li>
  <li>检查socket的发送队列是否为空。如果为空，意味着没有cork数据等待处理，因此调用
<code class="highlighter-rouge">ip_setup_cork</code>来设置corking</li>
</ol>

<p>一旦处理了上述条件，就调用<code class="highlighter-rouge">__ip_append_data</code>函数，该函数包含用于将数据处理成数据
包的大量逻辑。</p>

<h5 id="__ip_append_data"><code class="highlighter-rouge">__ip_append_data</code></h5>

<p>如果socket是corked，则从<code class="highlighter-rouge">ip_append_data</code>调用此函数；如果socket未被cork，则从
<code class="highlighter-rouge">ip_make_skb</code>调用此函数。在任何一种情况下，函数都将分配一个新缓冲区来存储传入
的数据，或者将数据附加到现有数据中。</p>

<p>这种工作的方式围绕socket的发送队列。等待发送的现有数据（例如，如果socket被cork）
将在队列中有一个对应条目，可以被追加数据。</p>

<p>这个函数很复杂;它执行很多计算以确定如何构造传递给下面的网络层的skb。</p>

<p>该函数的重点包括：</p>

<ol>
  <li>如果硬件支持，则处理UDP Fragmentation Offload（UFO）。绝大多数网络硬件不支持
UFO。如果你的网卡驱动程序支持它，它将设置<code class="highlighter-rouge">NETIF_F_UFO</code>标记位</li>
  <li>处理支持分散/收集（
<a href="https://en.wikipedia.org/wiki/Vectored_I/O">scatter/gather</a>）IO的网卡。许多
卡都支持此功能，并使用<code class="highlighter-rouge">NETIF_F_SG</code>标志进行通告。支持该特性的网卡可以处理数据
被分散到多个buffer的数据包;内核不需要花时间将多个缓冲区合并成一个缓冲区中。避
免这种额外的复制会提升性能，大多数网卡都支持此功能</li>
  <li>通过调用<code class="highlighter-rouge">sock_wmalloc</code>跟踪发送队列的大小。当分配新的skb时，skb的大小由创建它
的socket计费（charge），并计入socket发送队列的已分配字节数。如果发送队列已经
没有足够的空间（超过计费限制），则skb并分配失败并返回错误。我们将在下面的调优
部分中看到如何设置socket发送队列大小（txqueuelen）</li>
  <li>更新错误统计信息。此函数中的任何错误都会增加“discard”计数。我们将在下面的监控部分中
看到如何读取此值</li>
</ol>

<p>函数执行成功后返回0，以及一个适用于网络设备传输的skb。</p>

<p>在unorked情况下，持有skb的queue被作为参数传递给上面描述的<code class="highlighter-rouge">__ip_make_skb</code>，在那里
它被出队并通过<code class="highlighter-rouge">udp_send_skb</code>发送到更底层。</p>

<p>在cork的情况下，<code class="highlighter-rouge">__ip_append_data</code>的返回值向上传递。数据位于发送队列中，直到
<code class="highlighter-rouge">udp_sendmsg</code>确定是时候调用<code class="highlighter-rouge">udp_push_pending_frames</code>来完成skb，后者会进一步调用
<code class="highlighter-rouge">udp_send_skb</code>。</p>

<h5 id="flushing-corked-sockets">Flushing corked sockets</h5>

<p>现在，<code class="highlighter-rouge">udp_sendmsg</code>会继续，检查<code class="highlighter-rouge">__ip_append_skb</code>的返回值（错误码）：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="n">udp_flush_pending_frames</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">corkreq</span><span class="p">)</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">udp_push_pending_frames</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_queue</span><span class="p">)))</span>
        <span class="n">up</span><span class="o">-&gt;</span><span class="n">pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
</code></pre></div></div>

<p>我们来看看每个情况：</p>

<ol>
  <li>如果出现错误（错误为非零），则调用<code class="highlighter-rouge">udp_flush_pending_frames</code>，这将取消cork并从socket的发送队列中删除所有数据</li>
  <li>如果在未指定<code class="highlighter-rouge">MSG_MORE</code>的情况下发送此数据，则调用<code class="highlighter-rouge">udp_push_pending_frames</code>，它将数据传递到更下面的网络层</li>
  <li>如果发送队列为空，请将socket标记为不再cork</li>
</ol>

<p>如果追加操作完成并且有更多数据要进入cork，则代码将做一些清理工作，并返回追加数据的长度：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ip_rt_put</span><span class="p">(</span><span class="n">rt</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">free</span><span class="p">)</span>
        <span class="n">kfree</span><span class="p">(</span><span class="n">ipc</span><span class="p">.</span><span class="n">opt</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
</code></pre></div></div>

<p>这就是内核如何处理corked UDP sockets的。</p>

<h4 id="5111-error-accounting">5.1.11 Error accounting</h4>

<p>如果：</p>

<ol>
  <li>non-corking快速路径创建skb失败，或<code class="highlighter-rouge">udp_send_skb</code>返回错误，或</li>
  <li><code class="highlighter-rouge">ip_append_data</code>无法将数据附加到corked UDP socket，或</li>
  <li>当<code class="highlighter-rouge">udp_push_pending_frames</code>调用<code class="highlighter-rouge">udp_send_skb</code>发送corked skb时后者返回错误</li>
</ol>

<p>仅当返回的错误是<code class="highlighter-rouge">ENOBUFS</code>（内核无可用内存）或socket已设置<code class="highlighter-rouge">SOCK_NOSPACE</code>（发送队
列已满）时，<code class="highlighter-rouge">SNDBUFERRORS</code>统计信息才会增加：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * ENOBUFS = no kernel mem, SOCK_NOSPACE = no sndbuf space.  Reporting
 * ENOBUFS might not be good (it's not tunable per se), but otherwise
 * we don't have a good statistic (IpOutDiscards but it can be too many
 * things).  We could add another new stat but at least for now that
 * seems like overkill.
 */</span>
<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOBUFS</span> <span class="o">||</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">SOCK_NOSPACE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">UDP_INC_STATS_USER</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span>
                        <span class="n">UDP_MIB_SNDBUFERRORS</span><span class="p">,</span> <span class="n">is_udplite</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
</code></pre></div></div>

<p>我们接下来会在监控小节里看到如何读取这些计数。</p>

<h3 id="52-udp_send_skb">5.2 <code class="highlighter-rouge">udp_send_skb</code></h3>

<p><code class="highlighter-rouge">udp_sendmsg</code>通过调用<code class="highlighter-rouge">udp_send_skb</code>函数将skb送到下一网络层，在本例中是IP协议层。 这个函数做了一些重要的事情：</p>

<ol>
  <li>向skb添加UDP头</li>
  <li>处理校验和：软件校验和，硬件校验和或无校验和（如果禁用）</li>
  <li>调用<code class="highlighter-rouge">ip_send_skb</code>将skb发送到IP协议层</li>
  <li>更新发送成功或失败的统计计数器</li>
</ol>

<p>让我们来看看。首先，创建UDP头：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">udp_send_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flowi4</span> <span class="o">*</span><span class="n">fl4</span><span class="p">)</span>
<span class="p">{</span>
                <span class="cm">/* useful variables ... */</span>

        <span class="cm">/*
         * Create a UDP header
         */</span>
        <span class="n">uh</span> <span class="o">=</span> <span class="n">udp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
        <span class="n">uh</span><span class="o">-&gt;</span><span class="n">source</span> <span class="o">=</span> <span class="n">inet</span><span class="o">-&gt;</span><span class="n">inet_sport</span><span class="p">;</span>
        <span class="n">uh</span><span class="o">-&gt;</span><span class="n">dest</span> <span class="o">=</span> <span class="n">fl4</span><span class="o">-&gt;</span><span class="n">fl4_dport</span><span class="p">;</span>
        <span class="n">uh</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
        <span class="n">uh</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<p>接下来，处理校验和。有几种情况：</p>

<ol>
  <li>首先处理<a href="https://en.wikipedia.org/wiki/UDP-Lite">UDP-Lite</a>校验和</li>
  <li>接下来，如果socket校验和选项被关闭（<code class="highlighter-rouge">setsockopt</code>带<code class="highlighter-rouge">SO_NO_CHECK</code>参数），它将被标记为校
验和关闭</li>
  <li>接下来，如果硬件支持UDP校验和，则将调用<code class="highlighter-rouge">udp4_hwcsum</code>来设置它。请注意，如果数
据包是分段的，内核将在软件中生成校验和，你可以在
<a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/udp.c#L720-L763">udp4_hwcsum</a>
的源代码中看到这一点</li>
  <li>最后，通过调用<code class="highlighter-rouge">udp_csum</code>生成软件校验和</li>
</ol>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">is_udplite</span><span class="p">)</span>                                  <span class="cm">/*     UDP-Lite      */</span>
        <span class="n">csum</span> <span class="o">=</span> <span class="n">udplite_csum</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_no_check</span> <span class="o">==</span> <span class="n">UDP_CSUM_NOXMIT</span><span class="p">)</span> <span class="p">{</span>   <span class="cm">/* UDP csum disabled */</span>

        <span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_NONE</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">send</span><span class="p">;</span>

<span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* UDP hardware csum */</span>

        <span class="n">udp4_hwcsum</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">fl4</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span> <span class="n">fl4</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">);</span>
        <span class="k">goto</span> <span class="n">send</span><span class="p">;</span>

<span class="p">}</span> <span class="k">else</span>
        <span class="n">csum</span> <span class="o">=</span> <span class="n">udp_csum</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
</code></pre></div></div>

<p>接下来，添加了<a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol#IPv4_Pseudo_Header">伪头
</a>：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">uh</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span> <span class="n">csum_tcpudp_magic</span><span class="p">(</span><span class="n">fl4</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span> <span class="n">fl4</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
                              <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_protocol</span><span class="p">,</span> <span class="n">csum</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">uh</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">uh</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span> <span class="n">CSUM_MANGLED_0</span><span class="p">;</span>
</code></pre></div></div>

<p>如果校验和为0，则根据<a href="https://tools.ietf.org/html/rfc768">RFC 768</a>，校验为全1（
transmitted  as all ones (the equivalent  in one’s complement  arithmetic)）。最
后，将skb传递给IP协议层并增加统计计数：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">send:</span>
  <span class="n">err</span> <span class="o">=</span> <span class="n">ip_send_skb</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">skb</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOBUFS</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">inet</span><span class="o">-&gt;</span><span class="n">recverr</span><span class="p">)</span> <span class="p">{</span>
                  <span class="n">UDP_INC_STATS_USER</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span>
                                     <span class="n">UDP_MIB_SNDBUFERRORS</span><span class="p">,</span> <span class="n">is_udplite</span><span class="p">);</span>
                  <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span>
          <span class="n">UDP_INC_STATS_USER</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span>
                             <span class="n">UDP_MIB_OUTDATAGRAMS</span><span class="p">,</span> <span class="n">is_udplite</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
</code></pre></div></div>

<p>如果<code class="highlighter-rouge">ip_send_skb</code>成功，将更新<code class="highlighter-rouge">OUTDATAGRAMS</code>统计。如果IP协议层报告错误，并且错误
是<code class="highlighter-rouge">ENOBUFS</code>（内核缺少内存）而且错误queue（<code class="highlighter-rouge">inet-&gt;recverr</code>）没有启用，则更新
<code class="highlighter-rouge">SNDBUFERRORS</code>。</p>

<p>在继续讨论IP协议层之前，让我们先看看如何在Linux内核中监视和调优UDP协议层。</p>

<h3 id="53-监控udp层统计">5.3 监控：UDP层统计</h3>

<p>两个非常有用的获取UDP协议统计文件：</p>

<ul>
  <li><code class="highlighter-rouge">/proc/net/snmp</code></li>
  <li><code class="highlighter-rouge">/proc/net/udp</code></li>
</ul>

<h4 id="procnetsnmp">/proc/net/snmp</h4>

<p>监控UDP协议层统计：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cat</span> /proc/net/snmp | <span class="nb">grep </span>Udp<span class="se">\:</span>
Udp: InDatagrams NoPorts InErrors OutDatagrams RcvbufErrors SndbufErrors
Udp: 16314 0 0 17161 0 0
</code></pre></div></div>

<p>要准确地理解这些计数，你需要仔细地阅读内核代码。一些类型的错误计数并不是只出现在
一种计数中，而可能是出现在多个计数中。</p>

<ul>
  <li><code class="highlighter-rouge">InDatagrams</code>: Incremented when recvmsg was used by a userland program to read datagram. Also incremented when a UDP packet is encapsulated and sent back for processing.</li>
  <li><code class="highlighter-rouge">NoPorts</code>: Incremented when UDP packets arrive destined for a port where no program is listening.</li>
  <li><code class="highlighter-rouge">InErrors</code>: Incremented in several cases: no memory in the receive queue, when a bad checksum is seen, and if sk_add_backlog fails to add the datagram.</li>
  <li><code class="highlighter-rouge">OutDatagrams</code>: Incremented when a UDP packet is handed down without error to the IP protocol layer to be sent.</li>
  <li><code class="highlighter-rouge">RcvbufErrors</code>: Incremented when sock_queue_rcv_skb reports that no memory is available; this happens if sk-&gt;sk_rmem_alloc is greater than or equal to sk-&gt;sk_rcvbuf.</li>
  <li><code class="highlighter-rouge">SndbufErrors</code>: Incremented if the IP protocol layer reported an error when trying to send the packet and no error queue has been setup. Also incremented if no send queue space or kernel memory are available.</li>
  <li><code class="highlighter-rouge">InCsumErrors</code>: Incremented when a UDP checksum failure is detected. Note that in all cases I could find, InCsumErrors is incremented at the same time as InErrors. Thus, InErrors - InCsumErros should yield the count of memory related errors on the receive side.</li>
</ul>

<p>注意，UDP协议层发现的某些错误会出现在其他协议层的统计信息中。一个例子：路由错误
。 <code class="highlighter-rouge">udp_sendmsg</code>发现的路由错误将导致IP协议层的<code class="highlighter-rouge">OutNoRoutes</code>统计增加。</p>

<h4 id="procnetudp">/proc/net/udp</h4>

<p>监控UDP socket统计：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cat</span> /proc/net/udp
  sl  local_address rem_address   st tx_queue rx_queue <span class="nb">tr </span>tm-&gt;when retrnsmt   uid  <span class="nb">timeout </span>inode ref pointer drops
  515: 00000000:B346 00000000:0000 07 00000000:00000000 00:00000000 00000000   104        0 7518 2 0000000000000000 0
  558: 00000000:0371 00000000:0000 07 00000000:00000000 00:00000000 00000000     0        0 7408 2 0000000000000000 0
  588: 0100007F:038F 00000000:0000 07 00000000:00000000 00:00000000 00000000     0        0 7511 2 0000000000000000 0
  769: 00000000:0044 00000000:0000 07 00000000:00000000 00:00000000 00000000     0        0 7673 2 0000000000000000 0
  812: 00000000:006F 00000000:0000 07 00000000:00000000 00:00000000 00000000     0        0 7407 2 0000000000000000 0
</code></pre></div></div>

<p>每一列的意思：</p>

<ul>
  <li><code class="highlighter-rouge">sl</code>: Kernel hash slot for the socket</li>
  <li><code class="highlighter-rouge">local_address</code>: Hexadecimal local address of the socket and port number, separated by :.</li>
  <li><code class="highlighter-rouge">rem_address</code>: Hexadecimal remote address of the socket and port number, separated by :.</li>
  <li><code class="highlighter-rouge">st</code>: The state of the socket. Oddly enough, the UDP protocol layer seems to use some TCP socket states. In the example above, 7 is TCP_CLOSE.</li>
  <li><code class="highlighter-rouge">tx_queue</code>: The amount of memory allocated in the kernel for outgoing UDP datagrams.</li>
  <li><code class="highlighter-rouge">rx_queue</code>: The amount of memory allocated in the kernel for incoming UDP datagrams.</li>
  <li><code class="highlighter-rouge">tr</code>, tm-&gt;when, retrnsmt: These fields are unused by the UDP protocol layer.</li>
  <li><code class="highlighter-rouge">uid</code>: The effective user id of the user who created this socket.</li>
  <li><code class="highlighter-rouge">timeout</code>: Unused by the UDP protocol layer.</li>
  <li><code class="highlighter-rouge">inode</code>: The inode number corresponding to this socket. You can use this to help you determine which user process has this socket open. Check /proc/[pid]/fd, which will contain symlinks to socket[:inode].</li>
  <li><code class="highlighter-rouge">ref</code>: The current reference count for the socket.</li>
  <li><code class="highlighter-rouge">pointer</code>: The memory address in the kernel of the struct sock.</li>
  <li><code class="highlighter-rouge">drops</code>: The number of datagram drops associated with this socket. Note that this does not include any drops related to sending datagrams (on corked UDP sockets or otherwise); this is only incremented in receive paths as of the kernel version examined by this blog post.</li>
</ul>

<p>打印这些计数的代码在<a href="https://github.com/torvalds/linux/blob/master/net/ipv4/udp.c#L2396-L2431">net/ipv4/udp.c</a>。</p>

<h3 id="54-调优socket发送队列内存大小">5.4 调优：socket发送队列内存大小</h3>

<p>发送队列（也叫“写队列”）的最大值可以通过设置<code class="highlighter-rouge">net.core.wmem_max sysctl</code>进行修改。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>sysctl <span class="nt">-w</span> net.core.wmem_max<span class="o">=</span>8388608
</code></pre></div></div>

<p><code class="highlighter-rouge">sk-&gt;sk_write_queue</code>用<code class="highlighter-rouge">net.core.wmem_default</code>初始化, 这个值也可以调整。</p>

<p>调整初始发送buffer大小：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>sysctl <span class="nt">-w</span> net.core.wmem_default<span class="o">=</span>8388608
</code></pre></div></div>

<p>也可以通过从应用程序调用<code class="highlighter-rouge">setsockopt</code>并传递<code class="highlighter-rouge">SO_SNDBUF</code>来设置<code class="highlighter-rouge">sk-&gt;sk_write_queue</code>
。通过<code class="highlighter-rouge">setsockopt</code>设置的最大值是<code class="highlighter-rouge">net.core.wmem_max</code>。</p>

<p>不过，可以通过<code class="highlighter-rouge">setsockopt</code>并传递<code class="highlighter-rouge">SO_SNDBUFFORCE</code>来覆盖<code class="highlighter-rouge">net.core.wmem_max</code>限制，
这需要<code class="highlighter-rouge">CAP_NET_ADMIN</code>权限。</p>

<p>每次调用<code class="highlighter-rouge">__ip_append_data</code>分配skb时，<code class="highlighter-rouge">sk-&gt;sk_wmem_alloc</code>都会递增。正如我们所看到
的，UDP数据报传输速度很快，通常不会在发送队列中花费太多时间。</p>


  <!-- POST NAVIGATION -->
  <div class="postNav clearfix">
     
      <a class="prev" href="/blog/tuning-stack-tx-zh-2/"><span>&laquo;&nbsp;[译] Linux网络栈监控和调优：发送数据 2</span>
      
    </a>
      
      
      <a class="next" href="/blog/tuning-stack-tx-zh-4/"><span>[译] Linux网络栈监控和调优：发送数据 4&nbsp;&raquo;</span>
       
      </a>
     
  </div>
</div>


         

      </div>
   </div><!-- end .content -->

   <div class="footer">
   <div class="container">
      <p class="copy">&copy; 2016-2019
      <a href="https://arthurchiao.github.io">Arthur Chiao</a>, Powered by
      <a href="http://jekyllrb.com">Jekyll </a>, Theme originated from
      <a href="https://github.com/brianmaierjr/long-haul"> Long Haul.</a>

      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
      <span id="busuanzi_container_site_pv"> Site visits:
          <span id="busuanzi_value_site_pv"></span>, powered by<a href="http://busuanzi.ibruce.info/"> busuanzi</a>
      </span>

      </p>

      <div class="footer-links"> 
         <ul class="noList"> 
            
            <li><a href="https://www.facebook.com/profile.php?id=100014334455077">
                  <svg id="facebook-square" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M82.667,1H17.335C8.351,1,1,8.351,1,17.336v65.329c0,8.99,7.351,16.335,16.334,16.335h65.332 C91.652,99.001,99,91.655,99,82.665V17.337C99,8.353,91.652,1.001,82.667,1L82.667,1z M84.318,50H68.375v42.875H50V50h-8.855V35.973 H50v-9.11c0-12.378,5.339-19.739,19.894-19.739h16.772V22.3H72.967c-4.066-0.007-4.57,2.12-4.57,6.078l-0.023,7.594H86.75 l-2.431,14.027V50z"></path>
                  </svg>
            </a></li>
            
            
            <li><a href="https://linkedin.com/in/yanan-zhao-7691317b?trk=hp-identity-photo">
                  <svg id="linkedin" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M99.001,19.428c-3.606,1.608-7.48,2.695-11.547,3.184c4.15-2.503,7.338-6.466,8.841-11.189 c-3.885,2.318-8.187,4-12.768,4.908c-3.667-3.931-8.893-6.387-14.676-6.387c-11.104,0-20.107,9.054-20.107,20.223 c0,1.585,0.177,3.128,0.52,4.609c-16.71-0.845-31.525-8.895-41.442-21.131C6.092,16.633,5.1,20.107,5.1,23.813 c0,7.017,3.55,13.208,8.945,16.834c-3.296-0.104-6.397-1.014-9.106-2.529c-0.002,0.085-0.002,0.17-0.002,0.255 c0,9.799,6.931,17.972,16.129,19.831c-1.688,0.463-3.463,0.71-5.297,0.71c-1.296,0-2.555-0.127-3.783-0.363 c2.559,8.034,9.984,13.882,18.782,14.045c-6.881,5.424-15.551,8.657-24.971,8.657c-1.623,0-3.223-0.096-4.796-0.282 c8.898,5.738,19.467,9.087,30.82,9.087c36.982,0,57.206-30.817,57.206-57.543c0-0.877-0.02-1.748-0.059-2.617 C92.896,27.045,96.305,23.482,99.001,19.428z"></path>
                  </svg>
            </a></li>
            
            
            <li><a href="https://github.com/ArthurChiao">
                  <svg id="github" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M50,1C22.938,1,1,22.938,1,50s21.938,49,49,49s49-21.938,49-49S77.062,1,50,1z M79.099,79.099 c-3.782,3.782-8.184,6.75-13.083,8.823c-1.245,0.526-2.509,0.989-3.79,1.387v-7.344c0-3.86-1.324-6.699-3.972-8.517 c1.659-0.16,3.182-0.383,4.57-0.67c1.388-0.287,2.855-0.702,4.402-1.245c1.547-0.543,2.935-1.189,4.163-1.938 c1.228-0.75,2.409-1.723,3.541-2.919s2.082-2.552,2.847-4.067s1.372-3.334,1.818-5.455c0.446-2.121,0.67-4.458,0.67-7.01 c0-4.945-1.611-9.155-4.833-12.633c1.467-3.828,1.308-7.991-0.478-12.489l-1.197-0.143c-0.829-0.096-2.321,0.255-4.474,1.053 c-2.153,0.798-4.57,2.105-7.249,3.924c-3.797-1.053-7.736-1.579-11.82-1.579c-4.115,0-8.039,0.526-11.772,1.579 c-1.69-1.149-3.294-2.097-4.809-2.847c-1.515-0.75-2.727-1.26-3.637-1.532c-0.909-0.271-1.754-0.439-2.536-0.503 c-0.782-0.064-1.284-0.079-1.507-0.048c-0.223,0.031-0.383,0.064-0.478,0.096c-1.787,4.53-1.946,8.694-0.478,12.489 c-3.222,3.477-4.833,7.688-4.833,12.633c0,2.552,0.223,4.889,0.67,7.01c0.447,2.121,1.053,3.94,1.818,5.455 c0.765,1.515,1.715,2.871,2.847,4.067s2.313,2.169,3.541,2.919c1.228,0.751,2.616,1.396,4.163,1.938 c1.547,0.543,3.014,0.957,4.402,1.245c1.388,0.287,2.911,0.511,4.57,0.67c-2.616,1.787-3.924,4.626-3.924,8.517v7.487 c-1.445-0.43-2.869-0.938-4.268-1.53c-4.899-2.073-9.301-5.041-13.083-8.823c-3.782-3.782-6.75-8.184-8.823-13.083 C9.934,60.948,8.847,55.56,8.847,50s1.087-10.948,3.231-16.016c2.073-4.899,5.041-9.301,8.823-13.083s8.184-6.75,13.083-8.823 C39.052,9.934,44.44,8.847,50,8.847s10.948,1.087,16.016,3.231c4.9,2.073,9.301,5.041,13.083,8.823 c3.782,3.782,6.75,8.184,8.823,13.083c2.143,5.069,3.23,10.457,3.23,16.016s-1.087,10.948-3.231,16.016 C85.848,70.915,82.88,75.317,79.099,79.099L79.099,79.099z"></path>
                  </svg>
            </a></li>
             
            
            <li><a href="mailto:arthurchiao@hotmail.com">
                  <svg id="mail" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M50,1C22.938,1,1,22.938,1,50s21.938,49,49,49s49-21.938,49-49S77.062,1,50,1z M25.5,25.5h49 c0.874,0,1.723,0.188,2.502,0.542L50,57.544L22.998,26.041C23.777,25.687,24.626,25.499,25.5,25.5L25.5,25.5z M19.375,68.375v-36.75 c0-0.128,0.005-0.256,0.014-0.383l17.96,20.953L19.587,69.958C19.448,69.447,19.376,68.916,19.375,68.375L19.375,68.375z M74.5,74.5 h-49c-0.541,0-1.072-0.073-1.583-0.212l17.429-17.429L50,66.956l8.653-10.096l17.429,17.429C75.572,74.427,75.041,74.5,74.5,74.5 L74.5,74.5z M80.625,68.375c0,0.541-0.073,1.072-0.211,1.583L62.652,52.195l17.96-20.953c0.008,0.127,0.014,0.255,0.014,0.383 L80.625,68.375L80.625,68.375z"></path>
                  </svg>
            </a></li>
            
         </ul>
      </div>
   </div>
</div><!-- end .footer -->

   <!-- Add jQuery and other scripts -->
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src=""><\/script>')</script>
<script src="/assets/js/dropcap.min.js"></script>
<script src="/assets/js/responsive-nav.min.js"></script>
<script src="/assets/js/scripts.js"></script>


</body>

</html>
