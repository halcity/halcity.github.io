<!DOCTYPE html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7"><![endif]-->
<!--[if IE 7]><html class="no-js lt-ie9 lt-ie8" <![endif]-->
<!--[if IE 8]><html class="no-js lt-ie9" <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->

<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
       new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
       j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
       'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
       })(window,document,'script','dataLayer','GTM-WP54B9K');</script>
    <!-- End Google Tag Manager -->

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <title>[译] Linux网络栈监控和调优：接收数据 3</title>

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="/assets/img/favicon.ico" />

    <!-- Come and get me RSS readers -->
    <link rel="alternate" type="application/rss+xml" title="ArthurChiao's Blog" href="http://0.0.0.0:4000/feed.xml" />
    
    <!-- Stylesheet -->
    <link rel="stylesheet" href="/assets/css/style.css">
    <!--[if IE 8]><link rel="stylesheet" href="/assets/css/ie.css"><![endif]-->
    <link rel="canonical" href="http://0.0.0.0:4000/blog/tuning-stack-rx-zh-3/">

    <!-- Modernizr -->
    <script src="/assets/js/modernizr.custom.15390.js" type="text/javascript"></script>

    
</head>


<body>
  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WP54B9K"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->

    <div class="header">
     <div class="container">
         <h1 class="logo"><a href="/">ArthurChiao's Blog</a></h1>
         <nav class="nav-collapse">
             <ul class="noList">
                 
                   
                   
                   <li class="element first  ">
                     <a href="/index.html">Home</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/articles">Articles</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/articles-zh">Articles (中文)</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/categories">Categories</a>
                   </li> 
                 
                   
                   
                   <li class="element   last">
                     <a href="/about">About</a>
                   </li> 
                 
                 <!-- <li> <a href="https://github.com/arthurchiao/reading" target="_blank">Reading</a></li> -->
                 <!-- <li> <a href="https://github.com/arthurchiao/" target="_blank">GitHub</a></li> -->
             </ul>
         </nav>
     </div>
 </div><!-- end .header -->


   <div class="content">
      <div class="container">
         <div class="post">
  
  <h1 class="postTitle">[译] Linux网络栈监控和调优：接收数据 3</h1>
  <p class="meta">2018-12-05 | <span class="time">11</span> Minute Read</p>

  
  
  <h2 id="9-从netif_receive_skb进入协议栈">9 从<code class="highlighter-rouge">netif_receive_skb</code>进入协议栈</h2>

<p>重新捡起我们前面已经几次提到过的<code class="highlighter-rouge">netif_receive_skb</code>，这个函数在好几个地方被调用
。两个最重要的地方（前面都看到过了）：</p>

<ul>
  <li><code class="highlighter-rouge">napi_skb_finish</code>：当packet不需要被合并到已经存在的某个GRO flow的时候</li>
  <li><code class="highlighter-rouge">napi_gro_complete</code>：协议层提示需要flush当前的flow的时候</li>
</ul>

<p>提示：<code class="highlighter-rouge">netif_receive_skb</code>和它调用的函数都运行在软中断处理循环（softirq
processing loop）的上下文中，因此这里的时间会记录到<code class="highlighter-rouge">top</code>命令看到的<code class="highlighter-rouge">si</code>或者
<code class="highlighter-rouge">sitime</code>字段。</p>

<p><code class="highlighter-rouge">netif_receive_skb</code>首先会检查用户有没有设置一个接收时间戳选项（sysctl），这个选
项决定在packet在到达backlog queue之前还是之后打时间戳。如果启用，那立即打时间戳
，在RPS之前（CPU和backlog queue绑定）；如果没有启用，那只有在它进入到backlog
queue之后才会打时间戳。如果RPS开启了，那这个选项可以将打时间戳的任务分散个其他
CPU，但会带来一些延迟。</p>

<h3 id="91-调优-收包打时间戳rx-packet-timestamping">9.1 调优: 收包打时间戳（RX packet timestamping）</h3>

<p>你可以调整包被收到后，何时给它打时间戳。</p>

<p>关闭收包打时间戳：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>sysctl <span class="nt">-w</span> net.core.netdev_tstamp_prequeue<span class="o">=</span>0
</code></pre></div></div>

<p>默认是1。</p>

<h2 id="10-netif_receive_skb">10 <code class="highlighter-rouge">netif_receive_skb</code></h2>

<p>处理完时间戳后，<code class="highlighter-rouge">netif_receive_skb</code>会根据RPS是否启用来做不同的事情。我们先来看简
单情况，RPS未启用。</p>

<h3 id="101-不使用rps默认">10.1 不使用RPS（默认）</h3>

<p>如果RPS没启用，会调用<code class="highlighter-rouge">__netif_receive_skb</code>，它做一些bookkeeping工作，进而调用
<code class="highlighter-rouge">__netif_receive_skb_core</code>，将数据移动到离协议栈更近一步。</p>

<p><code class="highlighter-rouge">__netif_receive_skb_core</code>工作的具体细节我们稍后再看，先看一下RPS启用的情况下的
代码调用关系，它也会调到这个函数的。</p>

<h3 id="102-使用rps">10.2 使用RPS</h3>

<p>如果RPS启用了，它会做一些计算，判断使用哪个CPU的backlog queue，这个过程由
<code class="highlighter-rouge">get_rps_cpu</code>函数完成。
<a href="https://github.com/torvalds/linux/blob/v3.13/net/core/dev.c#L3199-L3200">net/core/dev.c</a>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cpu</span> <span class="o">=</span> <span class="n">get_rps_cpu</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rflow</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">ret</span> <span class="o">=</span> <span class="n">enqueue_to_backlog</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rflow</span><span class="o">-&gt;</span><span class="n">last_qtail</span><span class="p">);</span>
  <span class="n">rcu_read_unlock</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">get_rps_cpu</code>会考虑前面提到的RFS和aRFS设置，以此选出一个合适的CPU，通过调用
<code class="highlighter-rouge">enqueue_to_backlog</code>将数据放到它的backlog queue。</p>

<h3 id="103-enqueue_to_backlog">10.3 <code class="highlighter-rouge">enqueue_to_backlog</code></h3>

<p>首先从远端CPU的<code class="highlighter-rouge">struct softnet_data</code>实例获取backlog queue长度。如果backlog大于
<code class="highlighter-rouge">netdev_max_backlog</code>，或者超过了flow limit，直接drop，并更新<code class="highlighter-rouge">softnet_data</code>的drop
统计。注意这是远端CPU的统计。</p>

<p><a href="https://github.com/torvalds/linux/blob/v3.13/net/core/dev.c#L3199-L3200">net/core/dev.c</a>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">qlen</span> <span class="o">=</span> <span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">input_pkt_queue</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">qlen</span> <span class="o">&lt;=</span> <span class="n">netdev_max_backlog</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">skb_flow_limit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">qlen</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">input_pkt_queue</span><span class="p">))</span> <span class="p">{</span>
<span class="n">enqueue</span><span class="o">:</span>
            <span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">input_pkt_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
            <span class="n">input_queue_tail_incr_save</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">qtail</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">NET_RX_SUCCESS</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* Schedule NAPI for backlog device */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__test_and_set_bit</span><span class="p">(</span><span class="n">NAPI_STATE_SCHED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">backlog</span><span class="p">.</span><span class="n">state</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rps_ipi_queued</span><span class="p">(</span><span class="n">sd</span><span class="p">))</span>
                <span class="n">____napi_schedule</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">backlog</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">goto</span> <span class="n">enqueue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">sd</span><span class="o">-&gt;</span><span class="n">dropped</span><span class="o">++</span><span class="p">;</span>

    <span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">enqueue_to_backlog</code>被调用的地方很少。在基于RPS处理包的地方，以及<code class="highlighter-rouge">netif_rx</code>，会
调用到它。大部分驱动都不应该使用<code class="highlighter-rouge">netif_rx</code>，而应该是用<code class="highlighter-rouge">netif_receive_skb</code>。如果
你没用到RPS，你的驱动也没有使用<code class="highlighter-rouge">netif_rx</code>，那增大<code class="highlighter-rouge">backlog</code>并不会带来益处，因为它
根本没被用到。</p>

<p>注意：检查你的驱动，如果它调用了<code class="highlighter-rouge">netif_receive_skb</code>，而且你没用RPS，那增大
<code class="highlighter-rouge">netdev_max_backlog</code>并不会带来任何性能提升，因为没有数据包会被送到
<code class="highlighter-rouge">input_pkt_queue</code>。</p>

<p>如果<code class="highlighter-rouge">input_pkt_queue</code>足够小，而flow limit（后面会介绍）也还没达到（或者被禁掉了
），那数据包将会被放到队列。这里的逻辑有点funny，但大致可以归为为：</p>

<ul>
  <li>如果backlog是空的：如果远端CPU NAPI实例没有运行，并且IPI没有被加到队列，那就
触发一个IPI加到队列，然后调用<code class="highlighter-rouge">____napi_schedule</code>进一步处理</li>
  <li>如果backlog非空，或者远端CPU NAPI实例正在运行，那就enqueue包</li>
</ul>

<p>这里使用了<code class="highlighter-rouge">goto</code>，所以代码看起来有点tricky。</p>

<p><a href="https://github.com/torvalds/linux/blob/v3.13/net/core/dev.c#L3201-L3218">net/core/dev.c</a>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">if</span> <span class="p">(</span><span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">input_pkt_queue</span><span class="p">))</span> <span class="p">{</span>
<span class="n">enqueue</span><span class="o">:</span>
         <span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">input_pkt_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
         <span class="n">input_queue_tail_incr_save</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">qtail</span><span class="p">);</span>
         <span class="n">rps_unlock</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
         <span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
         <span class="k">return</span> <span class="n">NET_RX_SUCCESS</span><span class="p">;</span>
 <span class="p">}</span>

 <span class="cm">/* Schedule NAPI for backlog device
  * We can use non atomic operation since we own the queue lock
  */</span>
 <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__test_and_set_bit</span><span class="p">(</span><span class="n">NAPI_STATE_SCHED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">backlog</span><span class="p">.</span><span class="n">state</span><span class="p">))</span> <span class="p">{</span>
         <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rps_ipi_queued</span><span class="p">(</span><span class="n">sd</span><span class="p">))</span>
                 <span class="n">____napi_schedule</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">backlog</span><span class="p">);</span>
 <span class="p">}</span>
 <span class="k">goto</span> <span class="n">enqueue</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="flow-limits">Flow limits</h4>

<p>RPS在不同CPU之间分发packet，但是，如果一个flow特别大，会出现单个CPU被打爆，而
其他CPU无事可做（饥饿）的状态。因此引入了flow limit特性，放到一个backlog队列的属
于同一个flow的包的数量不能超过一个阈值。这可以保证即使有一个很大的flow在大量收包
，小flow也能得到及时的处理。</p>

<p>检查flow limit的代码，<a href="https://github.com/torvalds/linux/blob/v3.13/net/core/dev.c#L3199-L3200">net/core/dev.c</a>：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">qlen</span> <span class="o">&lt;=</span> <span class="n">netdev_max_backlog</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">skb_flow_limit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">qlen</span><span class="p">))</span> <span class="p">{</span>
</code></pre></div></div>

<p>默认，flow limit功能是关掉的。要打开flow limit，你需要指定一个bitmap（类似于RPS
的bitmap）。</p>

<h4 id="监控由于input_pkt_queue打满或flow-limit导致的丢包">监控：由于<code class="highlighter-rouge">input_pkt_queue</code>打满或flow limit导致的丢包</h4>

<p>在<code class="highlighter-rouge">/proc/net/softnet_stat</code>里面的dropped列计数，包含本节提到的原因导致的drop。</p>

<h4 id="调优">调优</h4>

<h5 id="tuning-adjusting-netdev_max_backlog-to-prevent-drops">Tuning: Adjusting netdev_max_backlog to prevent drops</h5>

<p>在调整这个值之前，请先阅读前面的“注意”。</p>

<p>如果你使用了RPS，或者你的驱动调用了<code class="highlighter-rouge">netif_rx</code>，那增加<code class="highlighter-rouge">netdev_max_backlog</code>可以改
善在<code class="highlighter-rouge">enqueue_to_backlog</code>里的丢包：</p>

<p>例如：increase backlog to 3000 with sysctl.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>sysctl <span class="nt">-w</span> net.core.netdev_max_backlog<span class="o">=</span>3000
</code></pre></div></div>

<p>默认值是1000。</p>

<h5 id="tuning-adjust-the-napi-weight-of-the-backlog-poll-loop">Tuning: Adjust the NAPI weight of the backlog poll loop</h5>

<p><code class="highlighter-rouge">net.core.dev_weight</code>决定了backlog poll loop可以消耗的整体budget（参考前面更改
<code class="highlighter-rouge">net.core.netdev_budget</code>的章节）：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>sysctl <span class="nt">-w</span> net.core.dev_weight<span class="o">=</span>600
</code></pre></div></div>

<p>默认值是64。</p>

<p>记住，backlog处理逻辑和设备驱动的<code class="highlighter-rouge">poll</code>函数类似，都是在软中断（softirq）的上下文
中执行，因此受整体budget和处理时间的限制，前面已经分析过了。</p>

<h5 id="tuning-enabling-flow-limits-and-tuning-flow-limit-hash-table-size">Tuning: Enabling flow limits and tuning flow limit hash table size</h5>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>sysctl <span class="nt">-w</span> net.core.flow_limit_table_len<span class="o">=</span>8192
</code></pre></div></div>

<p>默认值是4096.</p>

<p>这只会影响新分配的flow hash table。所以，如果你想增加table size的话，应该在打开
flow limit功能之前设置这个值。</p>

<p>打开flow limit功能的方式是，在<code class="highlighter-rouge">/proc/sys/net/core/flow_limit_cpu_bitmap</code>中指定一
个bitmask，和通过bitmask打开RPS的操作类似。</p>

<h3 id="103-处理backlog队列napi-poller">10.3 处理backlog队列：NAPI poller</h3>

<p>每个CPU都有一个backlog queue，其加入到NAPI实例的方式和驱动差不多，都是注册一个
<code class="highlighter-rouge">poll</code>方法，在软中断的上下文中处理包。此外，还提供了一个<code class="highlighter-rouge">weight</code>，这也和驱动类似
。</p>

<p>注册发生在网络系统初始化的时候。</p>

<p><a href="https://github.com/torvalds/linux/blob/v3.13/net/core/dev.c#L6952-L6955">net/core/dev.c</a>的<code class="highlighter-rouge">net_dev_init</code>函数：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sd-&gt;backlog.poll = process_backlog;
sd-&gt;backlog.weight = weight_p;
sd-&gt;backlog.gro_list = NULL;
sd-&gt;backlog.gro_count = 0;
</code></pre></div></div>

<p>backlog NAPI实例和设备驱动NAPI实例的不同之处在于，它的weight是可以调节的，而设备
驱动是hardcode 64。在下面的调优部分，我们会看到如何用sysctl调整这个设置。</p>

<h3 id="104-process_backlog">10.4 <code class="highlighter-rouge">process_backlog</code></h3>

<p><code class="highlighter-rouge">process_backlog</code>是一个循环，它会一直运行直至<code class="highlighter-rouge">weight</code>（前面介绍了）用完，或者
backlog里没有数据了。</p>

<p>backlog queue里的数据取出来，传递给<code class="highlighter-rouge">__netif_receive_skb</code>。这个函数做的事情和RPS
关闭的情况下做的事情一样。即，<code class="highlighter-rouge">__netif_receive_skb</code>做一些bookkeeping工作，然后调
用<code class="highlighter-rouge">__netif_receive_skb_core</code>将数据发送给更上面的协议层。</p>

<p><code class="highlighter-rouge">process_backlog</code>和NAPI之间遵循的合约，和驱动和NAPI之间的合约相同：NAPI is
disabled if the total weight will not be used. The poller is restarted with the
call to <code class="highlighter-rouge">____napi_schedule</code> from <code class="highlighter-rouge">enqueue_to_backlog</code> as described above.</p>

<p>函数返回接收完成的数据帧数量（在代码中是变量<code class="highlighter-rouge">work</code>），<code class="highlighter-rouge">net_rx_action</code>（前面介绍了
）将会从budget（通过<code class="highlighter-rouge">net.core.netdev_budget</code>可以调整，前面介绍了）里减去这个值。</p>

<h3 id="105-__netif_receive_skb_core将数据送到抓包点tap或协议层">10.5 <code class="highlighter-rouge">__netif_receive_skb_core</code>：将数据送到抓包点（tap）或协议层</h3>

<p><code class="highlighter-rouge">__netif_receive_skb_core</code>完成将数据送到协议栈的繁重工作（the heavy lifting of
delivering the data)。在它做这件事之前，会先检查是否有packet tap（探测点）插入，
这些tap用于抓包。例如，<code class="highlighter-rouge">AF_PACKET</code>地址族可以做这种事情，一般通过<code class="highlighter-rouge">libpcap</code>这个库
。</p>

<p>如果存在抓包点（tap），数据就先发送到那里，然后才送到协议层。</p>

<h3 id="106-送到抓包点tap">10.6 送到抓包点（tap）</h3>

<p>如果有packet tap（通常通过<code class="highlighter-rouge">libpcap</code>），packet会送到那里。
<a href="https://github.com/torvalds/linux/blob/v3.13/net/core/dev.c#L3548-L3554">net/core/dev.c</a>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">ptype</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptype_all</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptype</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">||</span> <span class="n">ptype</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">==</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pt_prev</span><span class="p">)</span>
      <span class="n">ret</span> <span class="o">=</span> <span class="n">deliver_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">pt_prev</span><span class="p">,</span> <span class="n">orig_dev</span><span class="p">);</span>
    <span class="n">pt_prev</span> <span class="o">=</span> <span class="n">ptype</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如何你对packet如何经过pcap有兴趣，可以阅读<a href="https://github.com/torvalds/linux/blob/v3.13/net/packet/af_packet.c">net/packet/af_packet.c</a>。</p>

<h3 id="107-送到协议层">10.7 送到协议层</h3>

<p>处理完taps之后，<code class="highlighter-rouge">__netif_receive_skb_core</code>将数据发送到协议层。它会从数据包中取出
协议信息，然后遍历注册在这个协议上的回调函数列表。</p>

<p>可以看<code class="highlighter-rouge">__netif_receive_skb_core</code>函数，<a href="https://github.com/torvalds/linux/blob/v3.13/net/core/dev.c#L3548-L3554">net/core/dev.c</a>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">type</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">;</span>
<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">ptype</span><span class="p">,</span>
                <span class="o">&amp;</span><span class="n">ptype_base</span><span class="p">[</span><span class="n">ntohs</span><span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PTYPE_HASH_MASK</span><span class="p">],</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ptype</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">type</span> <span class="o">&amp;&amp;</span>
            <span class="p">(</span><span class="n">ptype</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">==</span> <span class="n">null_or_dev</span> <span class="o">||</span> <span class="n">ptype</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">==</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">||</span>
             <span class="n">ptype</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">==</span> <span class="n">orig_dev</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">pt_prev</span><span class="p">)</span>
                        <span class="n">ret</span> <span class="o">=</span> <span class="n">deliver_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">pt_prev</span><span class="p">,</span> <span class="n">orig_dev</span><span class="p">);</span>
                <span class="n">pt_prev</span> <span class="o">=</span> <span class="n">ptype</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面的<code class="highlighter-rouge">ptype_base</code>是一个hash table，定义在<a href="https://github.com/torvalds/linux/blob/v3.13/net/core/dev.c#L146">net/core/dev.c</a>中:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">list_head</span> <span class="n">ptype_base</span><span class="p">[</span><span class="n">PTYPE_HASH_SIZE</span><span class="p">]</span> <span class="n">__read_mostly</span><span class="p">;</span>
</code></pre></div></div>

<p>每种协议在上面的hash table的一个slot里，添加一个过滤器到列表里。这个列表的头用如
下函数获取：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="nf">ptype_head</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">packet_type</span> <span class="o">*</span><span class="n">pt</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_ALL</span><span class="p">))</span>
                <span class="k">return</span> <span class="o">&amp;</span><span class="n">ptype_all</span><span class="p">;</span>
        <span class="k">else</span>
                <span class="k">return</span> <span class="o">&amp;</span><span class="n">ptype_base</span><span class="p">[</span><span class="n">ntohs</span><span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PTYPE_HASH_MASK</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>添加的时候用<code class="highlighter-rouge">dev_add_pack</code>这个函数。这就是协议层如何注册自身，用于处理相应协议的
网络数据的。</p>

<p>现在，你已经知道了数据是如何从卡进入到协议层的了。</p>


  <!-- POST NAVIGATION -->
  <div class="postNav clearfix">
     
      <a class="prev" href="/blog/tuning-stack-rx-zh-2/"><span>&laquo;&nbsp;[译] Linux网络栈监控和调优：接收数据 2</span>
      
    </a>
      
      
      <a class="next" href="/blog/tuning-stack-rx-zh-4/"><span>[译] Linux网络栈监控和调优：接收数据 4&nbsp;&raquo;</span>
       
      </a>
     
  </div>
</div>


         

      </div>
   </div><!-- end .content -->

   <div class="footer">
   <div class="container">
      <p class="copy">&copy; 2016-2019
      <a href="https://arthurchiao.github.io">Arthur Chiao</a>, Powered by
      <a href="http://jekyllrb.com">Jekyll </a>, Theme originated from
      <a href="https://github.com/brianmaierjr/long-haul"> Long Haul.</a>

      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
      <span id="busuanzi_container_site_pv"> Site visits:
          <span id="busuanzi_value_site_pv"></span>, powered by<a href="http://busuanzi.ibruce.info/"> busuanzi</a>
      </span>

      </p>

      <div class="footer-links"> 
         <ul class="noList"> 
            
            <li><a href="https://www.facebook.com/profile.php?id=100014334455077">
                  <svg id="facebook-square" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M82.667,1H17.335C8.351,1,1,8.351,1,17.336v65.329c0,8.99,7.351,16.335,16.334,16.335h65.332 C91.652,99.001,99,91.655,99,82.665V17.337C99,8.353,91.652,1.001,82.667,1L82.667,1z M84.318,50H68.375v42.875H50V50h-8.855V35.973 H50v-9.11c0-12.378,5.339-19.739,19.894-19.739h16.772V22.3H72.967c-4.066-0.007-4.57,2.12-4.57,6.078l-0.023,7.594H86.75 l-2.431,14.027V50z"></path>
                  </svg>
            </a></li>
            
            
            <li><a href="https://linkedin.com/in/yanan-zhao-7691317b?trk=hp-identity-photo">
                  <svg id="linkedin" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M99.001,19.428c-3.606,1.608-7.48,2.695-11.547,3.184c4.15-2.503,7.338-6.466,8.841-11.189 c-3.885,2.318-8.187,4-12.768,4.908c-3.667-3.931-8.893-6.387-14.676-6.387c-11.104,0-20.107,9.054-20.107,20.223 c0,1.585,0.177,3.128,0.52,4.609c-16.71-0.845-31.525-8.895-41.442-21.131C6.092,16.633,5.1,20.107,5.1,23.813 c0,7.017,3.55,13.208,8.945,16.834c-3.296-0.104-6.397-1.014-9.106-2.529c-0.002,0.085-0.002,0.17-0.002,0.255 c0,9.799,6.931,17.972,16.129,19.831c-1.688,0.463-3.463,0.71-5.297,0.71c-1.296,0-2.555-0.127-3.783-0.363 c2.559,8.034,9.984,13.882,18.782,14.045c-6.881,5.424-15.551,8.657-24.971,8.657c-1.623,0-3.223-0.096-4.796-0.282 c8.898,5.738,19.467,9.087,30.82,9.087c36.982,0,57.206-30.817,57.206-57.543c0-0.877-0.02-1.748-0.059-2.617 C92.896,27.045,96.305,23.482,99.001,19.428z"></path>
                  </svg>
            </a></li>
            
            
            <li><a href="https://github.com/ArthurChiao">
                  <svg id="github" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M50,1C22.938,1,1,22.938,1,50s21.938,49,49,49s49-21.938,49-49S77.062,1,50,1z M79.099,79.099 c-3.782,3.782-8.184,6.75-13.083,8.823c-1.245,0.526-2.509,0.989-3.79,1.387v-7.344c0-3.86-1.324-6.699-3.972-8.517 c1.659-0.16,3.182-0.383,4.57-0.67c1.388-0.287,2.855-0.702,4.402-1.245c1.547-0.543,2.935-1.189,4.163-1.938 c1.228-0.75,2.409-1.723,3.541-2.919s2.082-2.552,2.847-4.067s1.372-3.334,1.818-5.455c0.446-2.121,0.67-4.458,0.67-7.01 c0-4.945-1.611-9.155-4.833-12.633c1.467-3.828,1.308-7.991-0.478-12.489l-1.197-0.143c-0.829-0.096-2.321,0.255-4.474,1.053 c-2.153,0.798-4.57,2.105-7.249,3.924c-3.797-1.053-7.736-1.579-11.82-1.579c-4.115,0-8.039,0.526-11.772,1.579 c-1.69-1.149-3.294-2.097-4.809-2.847c-1.515-0.75-2.727-1.26-3.637-1.532c-0.909-0.271-1.754-0.439-2.536-0.503 c-0.782-0.064-1.284-0.079-1.507-0.048c-0.223,0.031-0.383,0.064-0.478,0.096c-1.787,4.53-1.946,8.694-0.478,12.489 c-3.222,3.477-4.833,7.688-4.833,12.633c0,2.552,0.223,4.889,0.67,7.01c0.447,2.121,1.053,3.94,1.818,5.455 c0.765,1.515,1.715,2.871,2.847,4.067s2.313,2.169,3.541,2.919c1.228,0.751,2.616,1.396,4.163,1.938 c1.547,0.543,3.014,0.957,4.402,1.245c1.388,0.287,2.911,0.511,4.57,0.67c-2.616,1.787-3.924,4.626-3.924,8.517v7.487 c-1.445-0.43-2.869-0.938-4.268-1.53c-4.899-2.073-9.301-5.041-13.083-8.823c-3.782-3.782-6.75-8.184-8.823-13.083 C9.934,60.948,8.847,55.56,8.847,50s1.087-10.948,3.231-16.016c2.073-4.899,5.041-9.301,8.823-13.083s8.184-6.75,13.083-8.823 C39.052,9.934,44.44,8.847,50,8.847s10.948,1.087,16.016,3.231c4.9,2.073,9.301,5.041,13.083,8.823 c3.782,3.782,6.75,8.184,8.823,13.083c2.143,5.069,3.23,10.457,3.23,16.016s-1.087,10.948-3.231,16.016 C85.848,70.915,82.88,75.317,79.099,79.099L79.099,79.099z"></path>
                  </svg>
            </a></li>
             
            
            <li><a href="mailto:arthurchiao@hotmail.com">
                  <svg id="mail" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M50,1C22.938,1,1,22.938,1,50s21.938,49,49,49s49-21.938,49-49S77.062,1,50,1z M25.5,25.5h49 c0.874,0,1.723,0.188,2.502,0.542L50,57.544L22.998,26.041C23.777,25.687,24.626,25.499,25.5,25.5L25.5,25.5z M19.375,68.375v-36.75 c0-0.128,0.005-0.256,0.014-0.383l17.96,20.953L19.587,69.958C19.448,69.447,19.376,68.916,19.375,68.375L19.375,68.375z M74.5,74.5 h-49c-0.541,0-1.072-0.073-1.583-0.212l17.429-17.429L50,66.956l8.653-10.096l17.429,17.429C75.572,74.427,75.041,74.5,74.5,74.5 L74.5,74.5z M80.625,68.375c0,0.541-0.073,1.072-0.211,1.583L62.652,52.195l17.96-20.953c0.008,0.127,0.014,0.255,0.014,0.383 L80.625,68.375L80.625,68.375z"></path>
                  </svg>
            </a></li>
            
         </ul>
      </div>
   </div>
</div><!-- end .footer -->

   <!-- Add jQuery and other scripts -->
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src=""><\/script>')</script>
<script src="/assets/js/dropcap.min.js"></script>
<script src="/assets/js/responsive-nav.min.js"></script>
<script src="/assets/js/scripts.js"></script>


</body>

</html>
