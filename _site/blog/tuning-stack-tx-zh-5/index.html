<!DOCTYPE html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7"><![endif]-->
<!--[if IE 7]><html class="no-js lt-ie9 lt-ie8" <![endif]-->
<!--[if IE 8]><html class="no-js lt-ie9" <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->

<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
       new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
       j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
       'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
       })(window,document,'script','dataLayer','GTM-WP54B9K');</script>
    <!-- End Google Tag Manager -->

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <title>[译] Linux网络栈监控和调优：发送数据 5</title>

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="/assets/img/favicon.ico" />

    <!-- Come and get me RSS readers -->
    <link rel="alternate" type="application/rss+xml" title="ArthurChiao's Blog" href="http://0.0.0.0:4000/feed.xml" />
    
    <!-- Stylesheet -->
    <link rel="stylesheet" href="/assets/css/style.css">
    <!--[if IE 8]><link rel="stylesheet" href="/assets/css/ie.css"><![endif]-->
    <link rel="canonical" href="http://0.0.0.0:4000/blog/tuning-stack-tx-zh-5/">

    <!-- Modernizr -->
    <script src="/assets/js/modernizr.custom.15390.js" type="text/javascript"></script>

    
</head>


<body>
  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WP54B9K"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->

    <div class="header">
     <div class="container">
         <h1 class="logo"><a href="/">ArthurChiao's Blog</a></h1>
         <nav class="nav-collapse">
             <ul class="noList">
                 
                   
                   
                   <li class="element first  ">
                     <a href="/index.html">Home</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/articles">Articles</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/articles-zh">Articles (中文)</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/categories">Categories</a>
                   </li> 
                 
                   
                   
                   <li class="element   last">
                     <a href="/about">About</a>
                   </li> 
                 
                 <!-- <li> <a href="https://github.com/arthurchiao/reading" target="_blank">Reading</a></li> -->
                 <!-- <li> <a href="https://github.com/arthurchiao/" target="_blank">GitHub</a></li> -->
             </ul>
         </nav>
     </div>
 </div><!-- end .header -->


   <div class="content">
      <div class="container">
         <div class="post">
  
  <h1 class="postTitle">[译] Linux网络栈监控和调优：发送数据 5</h1>
  <p class="meta">2018-12-17 | <span class="time">23</span> Minute Read</p>

  
  
  <h2 id="7-linux-netdevice-子系统">7 Linux netdevice 子系统</h2>

<p>在继续跟进<code class="highlighter-rouge">dev_queue_xmit</code>发送数据包之前，让我们花点时间介绍几个将在下一部分中出
现的重要概念。</p>

<h3 id="71-linux-traffic-control流量控制">7.1 Linux traffic control（流量控制）</h3>

<p>Linux支持称为流量控制（<a href="http://tldp.org/HOWTO/Traffic-Control-HOWTO/intro.html">traffic
control</a>）的功能。此功能
允许系统管理员控制数据包如何从机器发送出去。本文不会深入探讨Linux流量控制
的各个方面的细节。<a href="http://tldp.org/HOWTO/Traffic-Control-HOWTO/">这篇文档</a>对流量
控制系统、它如何控制流量，及其其特性进行了深入的介绍。</p>

<p>这里介绍一些值得一提的概念，使后面的代码更容易理解。</p>

<p>流量控制系统包含几组不同的queue system，每种有不同的排队特征。各个排队系统通常称
为qdisc，也称为排队规则。你可以将qdisc视为<strong>调度程序</strong>; qdisc决定数据包的发送时
间和方式。</p>

<p>在Linux上，每个device都有一个与之关联的默认qdisc。对于仅支持单发送队列的网卡，使
用默认的qdisc <code class="highlighter-rouge">pfifo_fast</code>。支持多个发送队列的网卡使用mq的默认qdisc。可以运行<code class="highlighter-rouge">tc
qdisc</code>来查看系统qdisc信息。</p>

<p>某些设备支持硬件流量控制，这允许管理员将流量控制offload到网络硬件，节省系统的
CPU资源。</p>

<p>现在已经介绍了这些概念，让我们从
<a href="https://github.com/torvalds/linux/blob/v3.13/net/core/dev.c#L2890-L2894">net/core/dev.c</a>
继续<code class="highlighter-rouge">dev_queue_xmit</code>。</p>

<h3 id="72-dev_queue_xmit-and-__dev_queue_xmit">7.2 <code class="highlighter-rouge">dev_queue_xmit</code> and <code class="highlighter-rouge">__dev_queue_xmit</code></h3>

<p><code class="highlighter-rouge">dev_queue_xmit</code>简单封装了<code class="highlighter-rouge">__dev_queue_xmit</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">dev_queue_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">__dev_queue_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dev_queue_xmit</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">__dev_queue_xmit</code>才是干脏活累活的地方。我们<a href="https://github.com/torvalds/linux/blob/v3.13/net/core/dev.c#L2808-L2825">一段段
</a>来看：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">__dev_queue_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">accel_priv</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

        <span class="n">skb_reset_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

        <span class="cm">/* Disable soft irqs for various locks below. Also
         * stops preemption for RCU.
         */</span>
        <span class="n">rcu_read_lock_bh</span><span class="p">();</span>

        <span class="n">skb_update_prio</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
</code></pre></div></div>

<p>开始的逻辑：</p>

<ol>
  <li>声明变量</li>
  <li>调用<code class="highlighter-rouge">skb_reset_mac_header</code>，准备发送skb。这会重置skb内部的指针，使得ether头可
以被访问</li>
  <li>调用<code class="highlighter-rouge">rcu_read_lock_bh</code>，为接下来的读操作加锁。更多关于使用RCU安全访问数据的信
息，可以参考<a href="https://www.kernel.org/doc/Documentation/RCU/checklist.txt">这里</a></li>
  <li>调用<code class="highlighter-rouge">skb_update_prio</code>，如果启用了<a href="https://github.com/torvalds/linux/blob/v3.13/Documentation/cgroups/net_prio.txt">网络优先级cgroup</a>，这会设置skb的优先级</li>
</ol>

<p>现在，我们来看更复杂的部分：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="n">txq</span> <span class="o">=</span> <span class="n">netdev_pick_tx</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">accel_priv</span><span class="p">);</span>
</code></pre></div></div>

<p>这会选择发送队列。本文后面会看到，一些网卡支持多发送队列。我们来看这是如何工作的。</p>

<h4 id="721-netdev_pick_tx">7.2.1 <code class="highlighter-rouge">netdev_pick_tx</code></h4>

<p><code class="highlighter-rouge">netdev_pick_tx</code>定义在<a href="https://github.com/torvalds/linux/blob/v3.13/net/core/flow_dissector.c#L397-L417">net/core/flow_dissector.c</a>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="nf">netdev_pick_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
                                    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
                                    <span class="kt">void</span> <span class="o">*</span><span class="n">accel_priv</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">queue_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">real_num_tx_queues</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="o">*</span><span class="n">ops</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_select_queue</span><span class="p">)</span>
                        <span class="n">queue_index</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_select_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span>
                                                            <span class="n">accel_priv</span><span class="p">);</span>
                <span class="k">else</span>
                        <span class="n">queue_index</span> <span class="o">=</span> <span class="n">__netdev_pick_tx</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">accel_priv</span><span class="p">)</span>
                        <span class="n">queue_index</span> <span class="o">=</span> <span class="n">dev_cap_txqueue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">queue_index</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">skb_set_queue_mapping</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">queue_index</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">netdev_get_tx_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">queue_index</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如上所示，如果网络设备仅支持单个TX队列，则会跳过复杂的代码，直接返回单个TX队列。
大多高端服务器上使用的设备都有多个TX队列。具有多个TX队列的设备有两种情况：</p>

<ol>
  <li>驱动程序实现<code class="highlighter-rouge">ndo_select_queue</code>，以硬件或feature-specific的方式更智能地选择TX队列</li>
  <li>驱动程序没有实现<code class="highlighter-rouge">ndo_select_queue</code>，这种情况需要内核自己选择设备</li>
</ol>

<p>从3.13内核开始，没有多少驱动程序实现<code class="highlighter-rouge">ndo_select_queue</code>。bnx2x和ixgbe驱动程序实
现了此功能，但仅用于以太网光纤通道（<a href="https://en.wikipedia.org/wiki/Fibre_Channel_over_Ethernet">FCoE</a>）。鉴于此，我们假设网络设备没有实现
<code class="highlighter-rouge">ndo_select_queue</code>和/或没有使用FCoE。在这种情况下，内核将使用<code class="highlighter-rouge">__netdev_pick_tx</code>
选择tx队列。</p>

<p>一旦<code class="highlighter-rouge">__netdev_pick_tx</code>确定了队列号，<code class="highlighter-rouge">skb_set_queue_mapping</code>将缓存该值（稍后将在
流量控制代码中使用），<code class="highlighter-rouge">netdev_get_tx_queue</code>将查找并返回指向该队列的指针。让我们
看一下<code class="highlighter-rouge">__netdev_pick_tx</code>在返回<code class="highlighter-rouge">__dev_queue_xmit</code>之前的工作原理。</p>

<h4 id="722-__netdev_pick_tx">7.2.2 <code class="highlighter-rouge">__netdev_pick_tx</code></h4>

<p>我们来看内核如何选择TX队列。
<a href="https://github.com/torvalds/linux/blob/v3.13/net/core/flow_dissector.c#L375-L395">net/core/flow_dissector.c</a>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">u16</span> <span class="nf">__netdev_pick_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">queue_index</span> <span class="o">=</span> <span class="n">sk_tx_queue_get</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">queue_index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">ooo_okay</span> <span class="o">||</span>
            <span class="n">queue_index</span> <span class="o">&gt;=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">real_num_tx_queues</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">new_index</span> <span class="o">=</span> <span class="n">get_xps_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">new_index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="n">new_index</span> <span class="o">=</span> <span class="n">skb_tx_hash</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">queue_index</span> <span class="o">!=</span> <span class="n">new_index</span> <span class="o">&amp;&amp;</span> <span class="n">sk</span> <span class="o">&amp;&amp;</span>
                    <span class="n">rcu_access_pointer</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_dst_cache</span><span class="p">))</span>
                        <span class="n">sk_tx_queue_set</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">new_index</span><span class="p">);</span>

                <span class="n">queue_index</span> <span class="o">=</span> <span class="n">new_index</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">queue_index</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>代码首先调用<code class="highlighter-rouge">sk_tx_queue_get</code>检查发送队列是否已经缓存在socket上，如果尚未缓存，
则返回-1。</p>

<p>下一个if语句检查是否满足以下任一条件：</p>

<ol>
  <li><code class="highlighter-rouge">queue_index &lt; 0</code>：表示尚未设置TX queue的情况</li>
  <li><code class="highlighter-rouge">ooo_okay</code>标志是否非零：如果不为0，则表示现在允许无序（out of order）数据包。
协议层必须正确地地设置此标志。当flow的所有outstanding（需要确认的？）数据包都
已确认时，TCP协议层将设置此标志。当发生这种情况时，内核可以为此数据包选择不同
的TX队列。UDP协议层不设置此标志 - 因此UDP数据包永远不会将<code class="highlighter-rouge">ooo_okay</code>设置为非零
值。</li>
  <li>TX queue index大于TX queue数量：如果用户最近通过ethtool更改了设备上的队列数，
则会发生这种情况。稍后会详细介绍。</li>
</ol>

<p>以上任何一种情况，都表示没有找到合适的TX queue，因此接下来代码会进入慢路径以继续
寻找合适的发送队列。首先调用<code class="highlighter-rouge">get_xps_queue</code>，它会使用一个由用户配置的TX queue到
CPU的映射，这称为XPS（Transmit Packet Steering ，发送数据包控制），我们将更详细
地了解XPS是什么以及它如何工作。</p>

<p>如果内核不支持XPS，或者系统管理员未配置XPS，或者配置的映射引用了无效队列，
<code class="highlighter-rouge">get_xps_queue</code>返回-1，则代码将继续调用<code class="highlighter-rouge">skb_tx_hash</code>。</p>

<p>一旦XPS或内核使用<code class="highlighter-rouge">skb_tx_hash</code>自动选择了发送队列，<code class="highlighter-rouge">sk_tx_queue_set</code>会将队列缓存
在socket对象上，然后返回。让我们看看XPS，以及<code class="highlighter-rouge">skb_tx_hash</code>在继续调用
<code class="highlighter-rouge">dev_queue_xmit</code>之前是如何工作的。</p>

<h5 id="transmit-packet-steering-xps">Transmit Packet Steering (XPS)</h5>

<p>发送数据包控制（XPS）是一项功能，允许系统管理员配置哪些CPU可以处理网卡的哪些发送
队列。XPS的主要目的是<strong>避免处理发送请求时的锁竞争</strong>。使用XPS还可以减少缓存驱逐，
避免<a href="https://en.wikipedia.org/wiki/Non-uniform_memory_access">NUMA</a>机器上的远程
内存访问等。</p>

<p>可以查看内核有关XPS的<a href="https://github.com/torvalds/linux/blob/v3.13/Documentation/networking/scaling.txt#L364-L422">文档
</a>
了解其如何工作的更多信息。我们后面会介绍如何调整系统的XPS，现在，你只需要知道
配置XPS，系统管理员需要定义TX queue到CPU的映射（bitmap形式）。</p>

<p>上面代码中，<code class="highlighter-rouge">get_xps_queue</code>将查询这个用户指定的映射，以确定应使用哪个发送
队列。如果<code class="highlighter-rouge">get_xps_queue</code>返回-1，则将改为使用<code class="highlighter-rouge">skb_tx_hash</code>。</p>

<h5 id="skb_tx_hash"><code class="highlighter-rouge">skb_tx_hash</code></h5>

<p>如果XPS未包含在内核中，或XPS未配置，或配置的队列不可用（可能因为用户调整了队列数
），<code class="highlighter-rouge">skb_tx_hash</code>将接管以确定应在哪个队列上发送数据。准确理解<code class="highlighter-rouge">skb_tx_hash</code>的工作
原理非常重要，具体取决于你的发送负载。请注意，这段代码已经随时间做过一些更新，因
此如果你使用的内核版本与本文不同，则应直接查阅相应版本的j内核源代码。</p>

<p>让我们看看它是如何工作的，来自
<a href="https://github.com/torvalds/linux/blob/v3.13/include/linux/netdevice.h#L2331-L2340">include/linux/netdevice.h</a>
：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Returns a Tx hash for the given packet when dev-&gt;real_num_tx_queues is used
 * as a distribution range limit for the returned value.
 */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">skb_tx_hash</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
                              <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">__skb_tx_hash</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">real_num_tx_queues</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>直接调用了<code class="highlighter-rouge"> __skb_tx_hash</code>, <a href="https://github.com/torvalds/linux/blob/v3.13/net/core/flow_dissector.c#L239-L271">net/core/flow_dissector.c</a>：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Returns a Tx hash based on the given packet descriptor a Tx queues' number
 * to be used as a distribution range.
 */</span>
<span class="n">u16</span> <span class="nf">__skb_tx_hash</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
                  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_tx_queues</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">u32</span> <span class="n">hash</span><span class="p">;</span>
        <span class="n">u16</span> <span class="n">qoffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">u16</span> <span class="n">qcount</span> <span class="o">=</span> <span class="n">num_tx_queues</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">skb_rx_queue_recorded</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">hash</span> <span class="o">=</span> <span class="n">skb_get_rx_queue</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">hash</span> <span class="o">&gt;=</span> <span class="n">num_tx_queues</span><span class="p">))</span>
                        <span class="n">hash</span> <span class="o">-=</span> <span class="n">num_tx_queues</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">hash</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>这个函数中的第一个if是一个有趣的短路。函数名<code class="highlighter-rouge">skb_rx_queue_recorded</code>有点误导。skb
有一个<code class="highlighter-rouge">queue_mapping</code>字段，rx和tx都会用到这个字段。无论如何，如果系统正在接收数
据包并将其转发到其他地方，则此if语句都为<code class="highlighter-rouge">true</code>。否则，代码将继续向下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_tc</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">u8</span> <span class="n">tc</span> <span class="o">=</span> <span class="n">netdev_get_prio_tc_map</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">);</span>
                <span class="n">qoffset</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tc_to_txq</span><span class="p">[</span><span class="n">tc</span><span class="p">].</span><span class="n">offset</span><span class="p">;</span>
                <span class="n">qcount</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tc_to_txq</span><span class="p">[</span><span class="n">tc</span><span class="p">].</span><span class="n">count</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>要理解这段代码，首先要知道，程序可以设置socket上发送的数据的优先级。这可以通过
<code class="highlighter-rouge">setsockopt</code>带<code class="highlighter-rouge">SOL_SOCKET</code>和<code class="highlighter-rouge">SO_PRIORITY</code>选项来完成。有关<code class="highlighter-rouge">SO_PRIORITY</code>的更多信息
，请参见<a href="http://man7.org/linux/man-pages/man7/socket.7.html">socket (7) man
page</a>。</p>

<p>请注意，如果使用<code class="highlighter-rouge">setsockopt</code>带<code class="highlighter-rouge">IP_TOS</code>选项来设置在socket上发送的IP包的TOS标志（
或者作为辅助消息传递给<code class="highlighter-rouge">sendmsg</code>，在数据包级别设置），内核会将其转换为
<code class="highlighter-rouge">skb-&gt;priority</code>。</p>

<p>如前所述，一些网络设备支持基于硬件的流量控制系统。<strong>如果num_tc不为零，则表示此设
备支持基于硬件的流量控制</strong>。这种情况下，将查询一个<strong>packet priority到该硬件支持
的流量控制</strong>的映射，根据此映射选择适当的流量类型（traffic class）。</p>

<p>接下来，将计算出该traffic class的TX queue的范围，它将用于确定发送队列。</p>

<p>如果<code class="highlighter-rouge">num_tc</code>为零（网络设备不支持硬件流量控制），则<code class="highlighter-rouge">qcount</code>和<code class="highlighter-rouge">qoffset</code>变量分
别设置为发送队列数和0。</p>

<p>使用<code class="highlighter-rouge">qcount</code>和<code class="highlighter-rouge">qoffset</code>，将计算发送队列的index：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_hash</span><span class="p">)</span>
                <span class="n">hash</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_hash</span><span class="p">;</span>
        <span class="k">else</span>
                <span class="n">hash</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">u16</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">;</span>
        <span class="n">hash</span> <span class="o">=</span> <span class="n">__flow_hash_1word</span><span class="p">(</span><span class="n">hash</span><span class="p">);</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="p">(((</span><span class="n">u64</span><span class="p">)</span> <span class="n">hash</span> <span class="o">*</span> <span class="n">qcount</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">+</span> <span class="n">qoffset</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__skb_tx_hash</span><span class="p">);</span>
</code></pre></div></div>

<p>最后，通过<code class="highlighter-rouge">__netdev_pick_tx</code>返回选出的TX queue index。</p>

<h3 id="73-继续__dev_queue_xmit">7.3 继续<code class="highlighter-rouge">__dev_queue_xmit</code></h3>

<p>至此已经选到了合适的发送队列。</p>

<p>继续<code class="highlighter-rouge">__dev_queue_xmit can continue</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="n">q</span> <span class="o">=</span> <span class="n">rcu_dereference_bh</span><span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">qdisc</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NET_CLS_ACT
</span>        <span class="n">skb</span><span class="o">-&gt;</span><span class="n">tc_verd</span> <span class="o">=</span> <span class="n">SET_TC_AT</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">tc_verd</span><span class="p">,</span> <span class="n">AT_EGRESS</span><span class="p">);</span>
<span class="cp">#endif
</span>        <span class="n">trace_net_dev_queue</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">enqueue</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">rc</span> <span class="o">=</span> <span class="n">__dev_xmit_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">txq</span><span class="p">);</span>
                <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>首先获取与此队列关联的qdisc。回想一下，之前我们看到单发送队列设备的默认类型是
<code class="highlighter-rouge">pfifo_fast</code> qdisc，而对于多队列设备，默认类型是<code class="highlighter-rouge">mq</code> qdisc。</p>

<p>接下来，如果内核中已启用数据包分类API，则代码会为packet分配traffic class。 接下
来，检查disc是否有合适的队列来存放packet。像<code class="highlighter-rouge">noqueue</code>这样的qdisc没有队列。 如果
有队列，则代码调用<code class="highlighter-rouge">__dev_xmit_skb</code>继续处理数据，然后跳转到此函数的末尾。我们很快
就会看到<code class="highlighter-rouge">__dev_xmit_skb</code>。现在，让我们看看如果没有队列会发生什么，从一个非常有用
的注释开始：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="cm">/* The device has no queue. Common case for software devices:
           loopback, all the sorts of tunnels...

           Really, it is unlikely that netif_tx_lock protection is necessary
           here.  (f.e. loopback and IP tunnels are clean ignoring statistics
           counters.)
           However, it is possible, that they rely on protection
           made by us here.

           Check this and shot the lock. It is not prone from deadlocks.
           Either shot noqueue qdisc, it is even simpler 8)
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_UP</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span> <span class="cm">/* ok because BHs are off */</span>
</code></pre></div></div>

<p>正如注释所示，<strong>唯一可以拥有”没有队列的qdisc”的设备是环回设备和隧道设备</strong>。如果
设备当前处于运行状态，则获取当前CPU，然后判断此设备队列上的发送锁是否由此CPU拥有
：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                <span class="k">if</span> <span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">xmit_lock_owner</span> <span class="o">!=</span> <span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>

                        <span class="k">if</span> <span class="p">(</span><span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">xmit_recursion</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">RECURSION_LIMIT</span><span class="p">)</span>
                                <span class="k">goto</span> <span class="n">recursion_alert</span><span class="p">;</span>
</code></pre></div></div>

<p>如果发送锁不由此CPU拥有，则在此处检查per-CPU计数器变量<code class="highlighter-rouge">xmit_recursion</code>，判断其是
否超过<code class="highlighter-rouge">RECURSION_LIMIT</code>。 一个程序可能会在这段代码这里持续发送数据，然后被抢占，
调度程序选择另一个程序来运行。第二个程序也可能驻留在此持续发送数据。因此，
<code class="highlighter-rouge">xmit_recursion</code>计数器用于确保在此处竞争发送数据的程序不超过<code class="highlighter-rouge">RECURSION_LIMIT</code>个
。</p>

<p>我们继续：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                        <span class="n">HARD_TX_LOCK</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">txq</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

                        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_xmit_stopped</span><span class="p">(</span><span class="n">txq</span><span class="p">))</span> <span class="p">{</span>
                                <span class="n">__this_cpu_inc</span><span class="p">(</span><span class="n">xmit_recursion</span><span class="p">);</span>
                                <span class="n">rc</span> <span class="o">=</span> <span class="n">dev_hard_start_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">txq</span><span class="p">);</span>
                                <span class="n">__this_cpu_dec</span><span class="p">(</span><span class="n">xmit_recursion</span><span class="p">);</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">dev_xmit_complete</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span> <span class="p">{</span>
                                        <span class="n">HARD_TX_UNLOCK</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">txq</span><span class="p">);</span>
                                        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
                                <span class="p">}</span>
                        <span class="p">}</span>
                        <span class="n">HARD_TX_UNLOCK</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">txq</span><span class="p">);</span>
                        <span class="n">net_crit_ratelimited</span><span class="p">(</span><span class="s">"Virtual device %s asks to queue packet!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                                             <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="cm">/* Recursion is detected! It is possible,
                         * unfortunately
                         */</span>
<span class="n">recursion_alert</span><span class="o">:</span>
                        <span class="n">net_crit_ratelimited</span><span class="p">(</span><span class="s">"Dead loop on virtual device %s, fix it urgently!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                                             <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
                <span class="p">}</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>接下来的代码首先尝试获取发送锁，然后检查要使用的设备的发送队列是否被停用。如果没
有停用，则更新<code class="highlighter-rouge">xmit_recursion</code>计数，然后将数据向下传递到更靠近发送的设备。我们稍
后会更详细地看到<code class="highlighter-rouge">dev_hard_start_xmit</code>。</p>

<p>或者，如果当前CPU是发送锁定的拥有者，或者如果<code class="highlighter-rouge">RECURSION_LIMIT</code>被命中，则不进行发
送，而会打印告警日志。</p>

<p>函数剩余部分的代码设置错误码并返回。</p>

<p>由于我们对真正的以太网设备感兴趣，让我们来看一下之前就需要跟进去的
<code class="highlighter-rouge">__dev_xmit_skb</code>函数，这是发送主线上的函数。</p>

<h3 id="74-__dev_xmit_skb">7.4 <code class="highlighter-rouge">__dev_xmit_skb</code></h3>

<p>现在我们带着排队规则<code class="highlighter-rouge">qdisc</code>、网络设备<code class="highlighter-rouge">dev</code>和发送队列<code class="highlighter-rouge">txq</code>三个变量来到
<code class="highlighter-rouge">__dev_xmit_skb</code>，
<a href="https://github.com/torvalds/linux/blob/v3.13/net/core/dev.c#L2684-L2745">net/core/dev.c</a>
：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__dev_xmit_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
                                 <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
                                 <span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">spinlock_t</span> <span class="o">*</span><span class="n">root_lock</span> <span class="o">=</span> <span class="n">qdisc_lock</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
        <span class="n">bool</span> <span class="n">contended</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

        <span class="n">qdisc_pkt_len_init</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
        <span class="n">qdisc_calculate_pkt_len</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
        <span class="cm">/*
         * Heuristic to force contended enqueues to serialize on a
         * separate lock before trying to get qdisc main lock.
         * This permits __QDISC_STATE_RUNNING owner to get the lock more often
         * and dequeue packets faster.
         */</span>
        <span class="n">contended</span> <span class="o">=</span> <span class="n">qdisc_is_running</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">contended</span><span class="p">))</span>
                <span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">busylock</span><span class="p">);</span>
</code></pre></div></div>

<p>代码首先使用<code class="highlighter-rouge">qdisc_pkt_len_init</code>和<code class="highlighter-rouge">qdisc_calculate_pkt_len</code>来计算数据的准确长度
，稍后qdisc会用到该值。 对于硬件offload（例如UFO）这是必需的，因为添加的额外的头
信息，硬件offload的时候回用到。</p>

<p>接下来，使用另一个锁来帮助减少qdisc主锁上的竞争（我们稍后会看到这第二个锁）。 如
果qdisc当前正在运行，那么试图发送的其他程序将在qdisc的<code class="highlighter-rouge">busylock</code>上竞争。 这允许
运行qdisc的程序在处理数据包的同时，与较少量的程序竞争第二个主锁。随着竞争者数量
的减少，这种技巧增加了吞吐量。<a href="https://github.com/torvalds/linux/commit/79640a4ca6955e3ebdb7038508fa7a0cd7fa5527">原始commit描述
</a>
。 接下来是主锁：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="n">spin_lock</span><span class="p">(</span><span class="n">root_lock</span><span class="p">);</span>
</code></pre></div></div>

<p>接下来处理3种可能情况：</p>

<ol>
  <li>如果qdisc已停用</li>
  <li>如果qdisc允许数据包bypass排队系统，并且没有其他包要发送，并且qdisc当前没有运
行。允许包bypass所谓的<strong>“work-conserving qdisc” - 那些用于流量整形（traffic
reshaping）目的并且不会引起发送延迟的qdisc</strong></li>
  <li>所有其他情况</li>
</ol>

<p>让我们来看看每种情况下发生什么，从qdisc停用开始：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__QDISC_STATE_DEACTIVATED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)))</span> <span class="p">{</span>
                <span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
                <span class="n">rc</span> <span class="o">=</span> <span class="n">NET_XMIT_DROP</span><span class="p">;</span>
</code></pre></div></div>

<p>这很简单。 如果qdisc停用，则释放数据并将返回代码设置为<code class="highlighter-rouge">NET_XMIT_DROP</code>。</p>

<p>接下来，如果qdisc允许数据包bypass，并且没有其他包要发送，并且qdisc当前没有运行：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TCQ_F_CAN_BYPASS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">qdisc_qlen</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                   <span class="n">qdisc_run_begin</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span>
                <span class="cm">/*
                 * This is a work-conserving queue; there are no old skbs
                 * waiting to be sent out; and the qdisc is not running -
                 * xmit the skb directly.
                 */</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">&amp;</span> <span class="n">IFF_XMIT_DST_RELEASE</span><span class="p">))</span>
                        <span class="n">skb_dst_force</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

                <span class="n">qdisc_bstats_update</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">sch_direct_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">txq</span><span class="p">,</span> <span class="n">root_lock</span><span class="p">))</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">contended</span><span class="p">))</span> <span class="p">{</span>
                                <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">busylock</span><span class="p">);</span>
                                <span class="n">contended</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                        <span class="p">}</span>
                        <span class="n">__qdisc_run</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span>
                        <span class="n">qdisc_run_end</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

                <span class="n">rc</span> <span class="o">=</span> <span class="n">NET_XMIT_SUCCESS</span><span class="p">;</span>
</code></pre></div></div>

<p>这个if语句有点复杂，如果满足以下所有条件，则整个语句的计算结果为true：</p>

<ol>
  <li><code class="highlighter-rouge">q-&gt; flags＆TCQ_F_CAN_BYPASS</code>：qdisc允许数据包绕过排队系统。对于所谓的“
work-conserving” qdiscs这会是<code class="highlighter-rouge">true</code>；即，允许packet bypass流量整形qdisc。
<code class="highlighter-rouge">pfifo_fast</code> qdisc允许数据包bypass</li>
  <li><code class="highlighter-rouge">!qdisc_qlen(q)</code>：qdisc的队列中没有待发送的数据</li>
  <li><code class="highlighter-rouge">qdisc_run_begin(p)</code>：如果qdisc未运行，此函数将设置qdisc的状态为“running”并返
回<code class="highlighter-rouge">true</code>，如果qdisc已在运行，则返回<code class="highlighter-rouge">false</code></li>
</ol>

<p>如果以上三个条件都为<code class="highlighter-rouge">true</code>，那么：</p>

<ul>
  <li>检查<code class="highlighter-rouge">IFF_XMIT_DST_RELEASE</code>标志，此标志允许内核释放skb的目标缓存。如果标志已禁用，将强制对skb进行引用计数</li>
  <li>调用<code class="highlighter-rouge">qdisc_bstats_update</code>更新qdisc发送的字节数和包数统计</li>
  <li>调用<code class="highlighter-rouge">sch_direct_xmit</code>用于发送数据包。我们将很快深入研究<code class="highlighter-rouge">sch_direct_xmit</code>，因为慢路径也会调用到它</li>
</ul>

<p><code class="highlighter-rouge">sch_direct_xmit</code>的返回值有两种情况：</p>

<ol>
  <li>队列不为空（返回&gt; 0）。在这种情况下，<code class="highlighter-rouge">busylock</code>将被释放，然后调用<code class="highlighter-rouge">__qdisc_run</code>重新启动qdisc处理</li>
  <li>队列为空（返回0）。在这种情况下，<code class="highlighter-rouge">qdisc_run_end</code>用于关闭qdisc处理</li>
</ol>

<p>在任何一种情况下，都会返回<code class="highlighter-rouge">NET_XMIT_SUCCESS</code>，这不是太糟糕。</p>

<p>让我们检查最后一种情况：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">skb_dst_force</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
                <span class="n">rc</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">enqueue</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">NET_XMIT_MASK</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">qdisc_run_begin</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">contended</span><span class="p">))</span> <span class="p">{</span>
                                <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">busylock</span><span class="p">);</span>
                                <span class="n">contended</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                        <span class="p">}</span>
                        <span class="n">__qdisc_run</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
                <span class="p">}</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>在所有其他情况下：</p>

<ol>
  <li>调用<code class="highlighter-rouge">skb_dst_force</code>强制对skb的目标缓存进行引用计数</li>
  <li>调用qdisc的<code class="highlighter-rouge">enqueue</code>方法将数据入队，保存函数返回值</li>
  <li>调用<code class="highlighter-rouge">qdisc_run_begin(p)</code>将qdisc标记为正在运行。如果它尚未运行（<code class="highlighter-rouge">contended ==
false</code>），则释放<code class="highlighter-rouge">busylock</code>，然后调用<code class="highlighter-rouge">__qdisc_run(p)</code>启动qdisc处理</li>
</ol>

<p>函数最后释放相应的锁，并返回状态码：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="n">spin_unlock</span><span class="p">(</span><span class="n">root_lock</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">contended</span><span class="p">))</span>
                <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">busylock</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="75-调优-transmit-packet-steering-xps">7.5 调优: Transmit Packet Steering (XPS)</h3>

<p>使用XPS需要在内核配置中启用它（Ubuntu上内核3.13.0有XPS），并提供一个位掩码，用于
描述<strong>CPU和TX queue的对应关系</strong>。</p>

<p>这些位掩码类似于
<a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#receive-packet-steering-rps">RPS</a>
位掩码，你可以在内核<a href="https://github.com/torvalds/linux/blob/v3.13/Documentation/networking/scaling.txt#L147-L150">文档
</a>
中找到有关这些位掩码的一些资料。</p>

<p>简而言之，要修改的位掩码位于以下位置：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/sys/class/net/DEVICE_NAME/queues/QUEUE/xps_cpus
</code></pre></div></div>

<p>因此，对于eth0和TX queue 0，你需要使用十六进制数修改文件：
<code class="highlighter-rouge">/sys/class/net/eth0/queues/tx-0/xps_cpus</code>，制定哪些CPU应处理来自eth0的发送队列0
的发送过程。另外，<a href="https://github.com/torvalds/linux/blob/v3.13/Documentation/networking/scaling.txt#L412-L422">文档
</a>
指出，在某些配置中可能不需要XPS。</p>


  <!-- POST NAVIGATION -->
  <div class="postNav clearfix">
     
      <a class="prev" href="/blog/tuning-stack-tx-zh-4/"><span>&laquo;&nbsp;[译] Linux网络栈监控和调优：发送数据 4</span>
      
    </a>
      
      
      <a class="next" href="/blog/tuning-stack-tx-zh-6/"><span>[译] Linux网络栈监控和调优：发送数据 6&nbsp;&raquo;</span>
       
      </a>
     
  </div>
</div>


         

      </div>
   </div><!-- end .content -->

   <div class="footer">
   <div class="container">
      <p class="copy">&copy; 2016-2019
      <a href="https://arthurchiao.github.io">Arthur Chiao</a>, Powered by
      <a href="http://jekyllrb.com">Jekyll </a>, Theme originated from
      <a href="https://github.com/brianmaierjr/long-haul"> Long Haul.</a>

      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
      <span id="busuanzi_container_site_pv"> Site visits:
          <span id="busuanzi_value_site_pv"></span>, powered by<a href="http://busuanzi.ibruce.info/"> busuanzi</a>
      </span>

      </p>

      <div class="footer-links"> 
         <ul class="noList"> 
            
            <li><a href="https://www.facebook.com/profile.php?id=100014334455077">
                  <svg id="facebook-square" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M82.667,1H17.335C8.351,1,1,8.351,1,17.336v65.329c0,8.99,7.351,16.335,16.334,16.335h65.332 C91.652,99.001,99,91.655,99,82.665V17.337C99,8.353,91.652,1.001,82.667,1L82.667,1z M84.318,50H68.375v42.875H50V50h-8.855V35.973 H50v-9.11c0-12.378,5.339-19.739,19.894-19.739h16.772V22.3H72.967c-4.066-0.007-4.57,2.12-4.57,6.078l-0.023,7.594H86.75 l-2.431,14.027V50z"></path>
                  </svg>
            </a></li>
            
            
            <li><a href="https://linkedin.com/in/yanan-zhao-7691317b?trk=hp-identity-photo">
                  <svg id="linkedin" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M99.001,19.428c-3.606,1.608-7.48,2.695-11.547,3.184c4.15-2.503,7.338-6.466,8.841-11.189 c-3.885,2.318-8.187,4-12.768,4.908c-3.667-3.931-8.893-6.387-14.676-6.387c-11.104,0-20.107,9.054-20.107,20.223 c0,1.585,0.177,3.128,0.52,4.609c-16.71-0.845-31.525-8.895-41.442-21.131C6.092,16.633,5.1,20.107,5.1,23.813 c0,7.017,3.55,13.208,8.945,16.834c-3.296-0.104-6.397-1.014-9.106-2.529c-0.002,0.085-0.002,0.17-0.002,0.255 c0,9.799,6.931,17.972,16.129,19.831c-1.688,0.463-3.463,0.71-5.297,0.71c-1.296,0-2.555-0.127-3.783-0.363 c2.559,8.034,9.984,13.882,18.782,14.045c-6.881,5.424-15.551,8.657-24.971,8.657c-1.623,0-3.223-0.096-4.796-0.282 c8.898,5.738,19.467,9.087,30.82,9.087c36.982,0,57.206-30.817,57.206-57.543c0-0.877-0.02-1.748-0.059-2.617 C92.896,27.045,96.305,23.482,99.001,19.428z"></path>
                  </svg>
            </a></li>
            
            
            <li><a href="https://github.com/ArthurChiao">
                  <svg id="github" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M50,1C22.938,1,1,22.938,1,50s21.938,49,49,49s49-21.938,49-49S77.062,1,50,1z M79.099,79.099 c-3.782,3.782-8.184,6.75-13.083,8.823c-1.245,0.526-2.509,0.989-3.79,1.387v-7.344c0-3.86-1.324-6.699-3.972-8.517 c1.659-0.16,3.182-0.383,4.57-0.67c1.388-0.287,2.855-0.702,4.402-1.245c1.547-0.543,2.935-1.189,4.163-1.938 c1.228-0.75,2.409-1.723,3.541-2.919s2.082-2.552,2.847-4.067s1.372-3.334,1.818-5.455c0.446-2.121,0.67-4.458,0.67-7.01 c0-4.945-1.611-9.155-4.833-12.633c1.467-3.828,1.308-7.991-0.478-12.489l-1.197-0.143c-0.829-0.096-2.321,0.255-4.474,1.053 c-2.153,0.798-4.57,2.105-7.249,3.924c-3.797-1.053-7.736-1.579-11.82-1.579c-4.115,0-8.039,0.526-11.772,1.579 c-1.69-1.149-3.294-2.097-4.809-2.847c-1.515-0.75-2.727-1.26-3.637-1.532c-0.909-0.271-1.754-0.439-2.536-0.503 c-0.782-0.064-1.284-0.079-1.507-0.048c-0.223,0.031-0.383,0.064-0.478,0.096c-1.787,4.53-1.946,8.694-0.478,12.489 c-3.222,3.477-4.833,7.688-4.833,12.633c0,2.552,0.223,4.889,0.67,7.01c0.447,2.121,1.053,3.94,1.818,5.455 c0.765,1.515,1.715,2.871,2.847,4.067s2.313,2.169,3.541,2.919c1.228,0.751,2.616,1.396,4.163,1.938 c1.547,0.543,3.014,0.957,4.402,1.245c1.388,0.287,2.911,0.511,4.57,0.67c-2.616,1.787-3.924,4.626-3.924,8.517v7.487 c-1.445-0.43-2.869-0.938-4.268-1.53c-4.899-2.073-9.301-5.041-13.083-8.823c-3.782-3.782-6.75-8.184-8.823-13.083 C9.934,60.948,8.847,55.56,8.847,50s1.087-10.948,3.231-16.016c2.073-4.899,5.041-9.301,8.823-13.083s8.184-6.75,13.083-8.823 C39.052,9.934,44.44,8.847,50,8.847s10.948,1.087,16.016,3.231c4.9,2.073,9.301,5.041,13.083,8.823 c3.782,3.782,6.75,8.184,8.823,13.083c2.143,5.069,3.23,10.457,3.23,16.016s-1.087,10.948-3.231,16.016 C85.848,70.915,82.88,75.317,79.099,79.099L79.099,79.099z"></path>
                  </svg>
            </a></li>
             
            
            <li><a href="mailto:arthurchiao@hotmail.com">
                  <svg id="mail" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M50,1C22.938,1,1,22.938,1,50s21.938,49,49,49s49-21.938,49-49S77.062,1,50,1z M25.5,25.5h49 c0.874,0,1.723,0.188,2.502,0.542L50,57.544L22.998,26.041C23.777,25.687,24.626,25.499,25.5,25.5L25.5,25.5z M19.375,68.375v-36.75 c0-0.128,0.005-0.256,0.014-0.383l17.96,20.953L19.587,69.958C19.448,69.447,19.376,68.916,19.375,68.375L19.375,68.375z M74.5,74.5 h-49c-0.541,0-1.072-0.073-1.583-0.212l17.429-17.429L50,66.956l8.653-10.096l17.429,17.429C75.572,74.427,75.041,74.5,74.5,74.5 L74.5,74.5z M80.625,68.375c0,0.541-0.073,1.072-0.211,1.583L62.652,52.195l17.96-20.953c0.008,0.127,0.014,0.255,0.014,0.383 L80.625,68.375L80.625,68.375z"></path>
                  </svg>
            </a></li>
            
         </ul>
      </div>
   </div>
</div><!-- end .footer -->

   <!-- Add jQuery and other scripts -->
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src=""><\/script>')</script>
<script src="/assets/js/dropcap.min.js"></script>
<script src="/assets/js/responsive-nav.min.js"></script>
<script src="/assets/js/scripts.js"></script>


</body>

</html>
