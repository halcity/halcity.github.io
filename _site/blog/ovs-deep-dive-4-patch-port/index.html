<!DOCTYPE html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7"><![endif]-->
<!--[if IE 7]><html class="no-js lt-ie9 lt-ie8" <![endif]-->
<!--[if IE 8]><html class="no-js lt-ie9" <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->

<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
       new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
       j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
       'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
       })(window,document,'script','dataLayer','GTM-WP54B9K');</script>
    <!-- End Google Tag Manager -->

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <title>OVS Deep Dive 4: OVS netdev and Patch Port</title>

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="/assets/img/favicon.ico" />

    <!-- Come and get me RSS readers -->
    <link rel="alternate" type="application/rss+xml" title="ArthurChiao's Blog" href="http://0.0.0.0:4000/feed.xml" />
    
    <!-- Stylesheet -->
    <link rel="stylesheet" href="/assets/css/style.css">
    <!--[if IE 8]><link rel="stylesheet" href="/assets/css/ie.css"><![endif]-->
    <link rel="canonical" href="http://0.0.0.0:4000/blog/ovs-deep-dive-4-patch-port/">

    <!-- Modernizr -->
    <script src="/assets/js/modernizr.custom.15390.js" type="text/javascript"></script>

    
</head>


<body>
  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WP54B9K"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->

    <div class="header">
     <div class="container">
         <h1 class="logo"><a href="/">ArthurChiao's Blog</a></h1>
         <nav class="nav-collapse">
             <ul class="noList">
                 
                   
                   
                   <li class="element first  ">
                     <a href="/index.html">Home</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/articles">Articles</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/articles-zh">Articles (中文)</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/categories">Categories</a>
                   </li> 
                 
                   
                   
                   <li class="element   last">
                     <a href="/about">About</a>
                   </li> 
                 
                 <!-- <li> <a href="https://github.com/arthurchiao/reading" target="_blank">Reading</a></li> -->
                 <!-- <li> <a href="https://github.com/arthurchiao/" target="_blank">GitHub</a></li> -->
             </ul>
         </nav>
     </div>
 </div><!-- end .header -->


   <div class="content">
      <div class="container">
         <div class="post">
  
  <h1 class="postTitle">OVS Deep Dive 4: OVS netdev and Patch Port</h1>
  <p class="meta">2017-01-07 | <span class="time">26</span> Minute Read</p>

  
  
  <p>This post introduces OVS patch port, and compares it with linux veth pair.</p>

<h2 id="1-what-is-ovs-patch-port">1. What is OVS <code class="highlighter-rouge">patch port</code></h2>

<p>An OVS patch port is like a physical cable plugged from
one (OVS) switch port to another. It is quite similar to Linux veth
pair.</p>

<p>Indeed, in some situations, these two could be used alternatively. Such as,
in OpenStack compute node, there are usually two ovs bridges: <code class="highlighter-rouge">br-int</code> and
<code class="highlighter-rouge">br-eth1</code>. In the early OpenStack releases (prior to Kilo), the two are connected
by linux veth pair. In newer releases (such as, releases after Liberty),
however, the default connection fashion has been changed to OVS patch port.</p>

<p align="center"><img src="/assets/img/ovs-deep-dive/ovs-compute-node.png" width="80%" height="80%" /></p>
<p align="center">Fig.1.1. Network On OpenStack Compute Node[1])</p>

<p>According to some materials[2,3][6][7], the reason of switching from
linux veth pair to OVS patch port is for performance consideration. Apart from
this, at least for OpenStack, the patch port brings another great benefit:
traffic of instances (VMs) will not get down during OVS neutron agent restart -
this is what <strong><em>graceful OVS agent restart[4,5]</em></strong> achieves in newer
OpenStack releases.</p>

<p>However, there is also a disadvanage of patch port: you could no longer capture
packets on the patch ports using tools such as <code class="highlighter-rouge">tcpdump</code> - like what you have
been doing on linux veth pair ports.</p>

<p>In this article, we will dig into the source code and get to know why it behaves
this way.</p>

<h2 id="2-ovs-netdev">2. OVS <code class="highlighter-rouge">netdev</code></h2>

<p align="center"><img src="/assets/img/ovs-deep-dive/netdev_rx_tx.png" width="60%" height="60%" /></p>
<p align="center">Fig.2.1 network device xmit/receive</p>

<p>A network device (e.g. physical NIC) has two ends/parts, one end works in kernel, which is responsible
for sending/receiving, and the other end in userspace, which manages the kernel
parts, such as changing device MTU size, disabling/enabling queues, etc. The communication
between kernel and userspace space is usually through <a href="">netlink</a> or <a href="">ioctl</a> (deprecated).</p>

<p>For virtual network devices, such as TUN/TAP, the working process is similar, execpt that
the packets a TAP device receives is not from outside, but from the userspace; and
the packets a TAP device sends does not go to outside, but goes to userspace.</p>

<p>In OVS,
A <code class="highlighter-rouge">struct netdev</code> instance represents a network device in OVS userspace, it is
used for controlling the kernel end of this device, it maybe a
physical NIC, a TAP device, or other types.</p>

<p>Defined in <code class="highlighter-rouge">lib/netdev-provider.h</code>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* A network device (e.g. an Ethernet device) */</span>
<span class="k">struct</span> <span class="n">netdev</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>                         <span class="cm">/* Name of network device. */</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">netdev_class</span> <span class="o">*</span><span class="n">netdev_class</span><span class="p">;</span> <span class="cm">/* Functions to control
                                                this device. */</span>
    <span class="p">...</span>

    <span class="kt">int</span> <span class="n">n_txq</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n_rxq</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ref_cnt</span><span class="p">;</span>                        <span class="cm">/* Times this devices was opened. */</span>
<span class="p">};</span>

</code></pre></div></div>

<p><code class="highlighter-rouge">netdev_class</code> is a general abstraction of all network devices, defined in
<code class="highlighter-rouge">lib/netdev-provider.h</code>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">netdev_class</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span> <span class="cm">/* Type of netdevs in this class, e.g. "system", "tap", "gre", etc. */</span>
    <span class="n">bool</span> <span class="n">is_pmd</span><span class="p">;</span>      <span class="cm">/* If 'true' then this netdev should be polled by PMD threads. */</span>

    <span class="cm">/* ## Top-Level Functions ## */</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">run</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">netdev_class</span> <span class="o">*</span><span class="n">netdev_class</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">wait</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">netdev_class</span> <span class="o">*</span><span class="n">netdev_class</span><span class="p">);</span>

    <span class="cm">/* ## netdev Functions ## */</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">construct</span><span class="p">)(</span><span class="k">struct</span> <span class="n">netdev</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destruct</span><span class="p">)(</span><span class="k">struct</span> <span class="n">netdev</span> <span class="o">*</span><span class="p">);</span>

    <span class="p">...</span>

    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">rxq_recv</span><span class="p">)(</span><span class="k">struct</span> <span class="n">netdev_rxq</span> <span class="o">*</span><span class="n">rx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dp_packet_batch</span> <span class="o">*</span><span class="n">batch</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">rxq_wait</span><span class="p">)(</span><span class="k">struct</span> <span class="n">netdev_rxq</span> <span class="o">*</span><span class="n">rx</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Any device type has to implement the methods in <code class="highlighter-rouge">netdev_class</code> before being used
(became a <strong>netdev provider</strong>) , so there are implementations for different
types on different platforms: for Linux paltform, for BSD paltform, for windows,
etc.</p>

<p align="center"><img src="/assets/img/ovs-deep-dive/netdev_providers.png" /></p>
<p align="center">Fig.2.2. netdev providers</p>

<p>Fig.2.2 depicts the <code class="highlighter-rouge">netdev</code> and <code class="highlighter-rouge">netdev providers</code> in OVS.</p>

<p>In the following, we only talk about the linux netdevs, vport netdevs, and
dpdk netdevs.</p>

<h3 id="21-linux-netdev">2.1. Linux netdev</h3>

<p><code class="highlighter-rouge">struct linux_netdev</code> defined in <code class="highlighter-rouge">lib/netdev-linux.c</code>.</p>

<p>Linux netdevs are network devices (the userspace part) on Linux platform, call
the <code class="highlighter-rouge">send()</code> method on a netdev will send the packet from userspace to linux
kernel (see <code class="highlighter-rouge">linux_netdev_send()</code>), then the packet will be handled by the
kernel part (device drivers) of that device. It includes the following three types:</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">system</code> - <code class="highlighter-rouge">netdev_linux_class</code></p>

    <p>default linux network device type, for physical devices. Also called
<strong>external</strong> devices because they send packets out and receives from out)</p>

    <p>the <code class="highlighter-rouge">send()</code> method of <code class="highlighter-rouge">system</code> device will
send packet to kernel through <code class="highlighter-rouge">AF_PACKET</code> [9] socket.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">internal</code> - <code class="highlighter-rouge">netdev_internal_class</code></p>

    <p>A special kind of virutual network devices on linux. The functionality is
much the same as <code class="highlighter-rouge">system</code> type, but does not directly send/receive from
outside as physical NICs do, and some differences in calculating statistics.</p>

    <p>the <code class="highlighter-rouge">send()</code> method of <code class="highlighter-rouge">internal</code> device will
send packet to kernel through <code class="highlighter-rouge">AF_PACKET</code> [9] socket.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">tap</code> - <code class="highlighter-rouge">netdev_tap_class</code></p>

    <p>Linux tap device.</p>

    <p>the <code class="highlighter-rouge">send()</code> method of <code class="highlighter-rouge">tap</code> device will
send packet to kernel through <code class="highlighter-rouge">write</code> system call on the userspace part of
the tap device (<code class="highlighter-rouge">write(netdev-&gt;tap_fd, data, size)</code>).</p>
  </li>
</ul>

<p>Declaration of 3 linux netdevs, where <code class="highlighter-rouge">NETDEV_LINUX_CLASS</code> is a macro to
initialize all callbacks:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="k">struct</span> <span class="n">netdev_class</span> <span class="n">netdev_linux_class</span> <span class="o">=</span>
    <span class="n">NETDEV_LINUX_CLASS</span><span class="p">(</span>
        <span class="s">"system"</span><span class="p">,</span>
        <span class="n">netdev_linux_construct</span><span class="p">,</span>
        <span class="n">netdev_linux_get_stats</span><span class="p">,</span>
        <span class="n">netdev_linux_get_features</span><span class="p">,</span>
        <span class="n">netdev_linux_get_status</span><span class="p">);</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">netdev_class</span> <span class="n">netdev_tap_class</span> <span class="o">=</span>
    <span class="n">NETDEV_LINUX_CLASS</span><span class="p">(</span>
        <span class="s">"tap"</span><span class="p">,</span>
        <span class="n">netdev_linux_construct_tap</span><span class="p">,</span>
        <span class="n">netdev_tap_get_stats</span><span class="p">,</span>
        <span class="n">netdev_linux_get_features</span><span class="p">,</span>
        <span class="n">netdev_linux_get_status</span><span class="p">);</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">netdev_class</span> <span class="n">netdev_internal_class</span> <span class="o">=</span>
    <span class="n">NETDEV_LINUX_CLASS</span><span class="p">(</span>
        <span class="s">"internal"</span><span class="p">,</span>
        <span class="n">netdev_linux_construct</span><span class="p">,</span>
        <span class="n">netdev_internal_get_stats</span><span class="p">,</span>
        <span class="nb">NULL</span><span class="p">,</span>                  <span class="cm">/* get_features */</span>
        <span class="n">netdev_internal_get_status</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="22-vport-netdev">2.2 vport netdev</h3>

<p><code class="highlighter-rouge">lib/netdev-vport.c</code></p>

<p>A vport is an OVS abstracted virtual port in OVS datapath.
vport netdevs are the userspace part of OVS vports. It is divided into two
categories: <strong>tunnel type</strong> and <strong>patch type</strong>.</p>

<ol>
  <li>
    <p>tunnel class</p>

    <p>used for overlay network.</p>

    <ul>
      <li><code class="highlighter-rouge">geneve</code></li>
      <li><code class="highlighter-rouge">gre</code></li>
      <li><code class="highlighter-rouge">vxlan</code></li>
      <li><code class="highlighter-rouge">lisp</code></li>
      <li><code class="highlighter-rouge">stt</code></li>
    </ul>
  </li>
  <li>
    <p><code class="highlighter-rouge">patch</code> - <code class="highlighter-rouge">patch_class</code></p>

    <p>used for forwarding packets between different OVS bridges.</p>
  </li>
</ol>

<p>Registration of the tunnel vports is in <code class="highlighter-rouge">netdev_vport_tunnel_register()</code>,
and <code class="highlighter-rouge">patch</code> port in <code class="highlighter-rouge">netdev_vport_patch_register()</code>. Both of them will then
call <code class="highlighter-rouge">netdev_register_provider()</code>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">netdev_vport_tunnel_register</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">vport_class</span> <span class="n">vport_classes</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">TUNNEL_CLASS</span><span class="p">(</span><span class="s">"geneve"</span><span class="p">,</span> <span class="s">"genev_sys"</span><span class="p">,</span> <span class="n">netdev_geneve_build_header</span><span class="p">,</span>
                <span class="n">netdev_tnl_push_udp_header</span><span class="p">,</span> <span class="n">netdev_geneve_pop_header</span><span class="p">),</span>
        <span class="n">TUNNEL_CLASS</span><span class="p">(</span><span class="s">"gre"</span><span class="p">,</span> <span class="s">"gre_sys"</span><span class="p">,</span> <span class="n">netdev_gre_build_header</span><span class="p">,</span>
                <span class="n">netdev_gre_push_header</span><span class="p">,</span> <span class="n">netdev_gre_pop_header</span><span class="p">),</span>
        <span class="n">TUNNEL_CLASS</span><span class="p">(</span><span class="s">"vxlan"</span><span class="p">,</span> <span class="s">"vxlan_sys"</span><span class="p">,</span> <span class="n">netdev_vxlan_build_header</span><span class="p">,</span>
                <span class="n">netdev_tnl_push_udp_header</span><span class="p">,</span> <span class="n">netdev_vxlan_pop_header</span><span class="p">),</span>
        <span class="n">TUNNEL_CLASS</span><span class="p">(</span><span class="s">"lisp"</span><span class="p">,</span> <span class="s">"lisp_sys"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">),</span>
        <span class="n">TUNNEL_CLASS</span><span class="p">(</span><span class="s">"stt"</span><span class="p">,</span> <span class="s">"stt_sys"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">),</span>
    <span class="p">};</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">vport_classes</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">netdev_register_provider</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport_classes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">netdev_class</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">netdev_vport_patch_register</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">vport_class</span> <span class="n">patch_class</span> <span class="o">=</span>
        <span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span>
            <span class="p">{</span> <span class="s">"patch"</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span>
              <span class="n">VPORT_FUNCTIONS</span><span class="p">(</span><span class="n">get_patch_config</span><span class="p">,</span> <span class="n">set_patch_config</span><span class="p">,</span>
                              <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">}};</span>
    <span class="n">netdev_register_provider</span><span class="p">(</span><span class="o">&amp;</span><span class="n">patch_class</span><span class="p">.</span><span class="n">netdev_class</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Following is the simplified init macro:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define VPORT_FUNCTIONS(GET_CONFIG, SET_CONFIG,             \
                        GET_TUNNEL_CONFIG, GET_STATUS,      \
                        BUILD_HEADER,                       \
                        PUSH_HEADER, POP_HEADER)            \
    netdev_vport_alloc,                                     \
    netdev_vport_construct,                                 \
    BUILD_HEADER,                                           \
    PUSH_HEADER,                                            \
    POP_HEADER,                                             \
                                                            \
    NULL,                       </span><span class="cm">/* send */</span><span class="cp">                  \
    NULL,                       </span><span class="cm">/* send_wait */</span><span class="cp">             \
    ...
</span>    <span class="nb">NULL</span><span class="p">,</span>                   <span class="cm">/* rx_recv */</span>                  \
    <span class="nb">NULL</span><span class="p">,</span>                   <span class="cm">/* rx_drain */</span>


<span class="cp">#define TUNNEL_CLASS(NAME, DPIF_PORT, BUILD_HEADER, PUSH_HEADER, POP_HEADER)   \
    { DPIF_PORT,                                                               \
        { NAME, false,                                                         \
          VPORT_FUNCTIONS(get_tunnel_config,                                   \
                          set_tunnel_config,                                   \
                          get_netdev_tunnel_config,                            \
                          tunnel_get_status,                                   \
                          BUILD_HEADER, PUSH_HEADER, POP_HEADER) }}
</span></code></pre></div></div>

<p><strong>Note</strong> that the <code class="highlighter-rouge">send</code> and <code class="highlighter-rouge">rx_recv</code> callbacks of all vport type netdevs are all <code class="highlighter-rouge">NULL</code>s.
What this means is that: <strong>a packet could not be sent from userspace to kernel
via vport netdevs, and vport does not receive packets from physical NICs</strong>.
Actually, <code class="highlighter-rouge">vports</code> are used to either forward packets
inside datapath, or send packets out by calling kernel method
<code class="highlighter-rouge">dev_queue_xmit()</code>.</p>

<h3 id="23-dpdk-netdev">2.3 DPDK netdev</h3>

<p>DPDK netdevs are netdev implementation on DPDK platform.</p>

<ul>
  <li><code class="highlighter-rouge">dpdk_class</code></li>
  <li><code class="highlighter-rouge">dpdk_ring_class</code></li>
  <li><code class="highlighter-rouge">dpdk_vhost_class</code></li>
  <li><code class="highlighter-rouge">dpdk_vhost_client_class</code></li>
</ul>

<h2 id="3-patch-port">3. Patch Port</h2>

<p>Patch port as a kind of vport type <code class="highlighter-rouge">netdev</code> is registered by calling
<code class="highlighter-rouge">netdev_register_provider(const struct netdev_class *new_class)</code> in
<code class="highlighter-rouge">lib/netdev-vport.c</code>. It initializes and registers a new netdev provider. After
registration, new netdevs of that type can be opened using <code class="highlighter-rouge">netdev_open()</code>.</p>

<p><code class="highlighter-rouge">patch</code> port accepts exactly one parameter: <code class="highlighter-rouge">peer</code> - the other side of the
connection. This is much like linux <strong>veth pair</strong>. Actually, <code class="highlighter-rouge">patch port</code> was
introduced as a drop-in replacement of linux veth pair [10][11] - originally for connecting
two datapaths - now for connecting different OVS bridges.</p>

<h3 id="31-how-patch-port-works">3.1 How Patch Port Works</h3>

<p>As we mentioned in Section 2, <code class="highlighter-rouge">patch port</code> does not implement the send and
receive methods of <code class="highlighter-rouge">netdev_class</code>, so a packet could not be sent from userspace
to kernel vport via <code class="highlighter-rouge">patch port</code>, and <code class="highlighter-rouge">patch port</code> will not receives packets
from physical devices. Actually, a patch port only receives packets from other
ports of ovs bridge (<code class="highlighter-rouge">ofproto</code>), and the (<strong>ONLY?</strong>) action for incoming packets
from a patch port to datapath, is to “OUTPUT” it to the peer side of this patch
port. In this way, it connects the two sides (usually, two OVS bridges).</p>

<p>The “OUTPUT” action just delivers the packet from one vport to another, no
memcpy, no context switching, and all work done in datapath, <strong>no kernel
network stack involved</strong>.</p>

<h3 id="32-why-packets-not-captured-on-patch-ports">3.2 Why Packets Not Captured On Patch Ports</h3>

<p>To understand why we could see the patch ports on host with <code class="highlighter-rouge">ifconfig</code>, but
could not capture packets with <code class="highlighter-rouge">tcpdump</code>, we need some knowledge about the
underlying theories of packet filtering. I’m not going too deep into packet
capturing, that’s something I’d like to discuss in a separate post.</p>

<p>In short, packet capturing is done by inserting some filtering code into kernel
at run time, the code will copy each incoming packet at <strong>link layer</strong>, sends it
to a buffer, then userspace applications (such as <code class="highlighter-rouge">tcpdump</code>) will read the buffer and get the packets.
Some key components to accomplish this:</p>

<ul>
  <li><strong>network tap</strong>: for intercepting and coping packets at L2 (in device drivers)</li>
  <li><strong>filtering mechanism</strong>: what BPF (LSF) provides</li>
</ul>

<p>Fig.3.1 depicts how BPF works[12]:</p>

<p align="center"><img src="/assets/img/ovs-deep-dive/bpf_overview.jpg" /></p>
<p align="center">Fig.3.1 BPF overview[12]</p>

<p>In Linux, the packet copying occurs in <code class="highlighter-rouge">netif_rx()</code>, which delivers a packet
from L2 driver to Linux network stack (L3).</p>

<p>In Linux kernel code <code class="highlighter-rouge">net/core/dev.c</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 *  netif_rx    -   post buffer to the network code
 *
 *  This function receives a packet from a device driver and queues it for
 *  the upper (protocol) levels to process. It always succeeds.
 *
 *  return values:
 *  NET_RX_SUCCESS  (no congestion)
 *  NET_RX_DROP     (packet was dropped)
 */</span>
<span class="kt">int</span> <span class="nf">netif_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">trace_netif_rx_entry</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">netif_rx_internal</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When packets go through a physical (e.g. eth0) or virtual device (e.g. tun/tap),
the device drivers delivers the packet to kernel stack by calling
<code class="highlighter-rouge">netif_rx(skb)</code>, and <code class="highlighter-rouge">trace_netif_rx_entry(skb)</code> does the packet filtering and
copying work. In contrast, when a packet is received by a <code class="highlighter-rouge">patch port</code>, the patch port
driver (receive method) will not call <code class="highlighter-rouge">netif_rx()</code> (because the packet’s
destination is the peer side, not kernel stack), and there is no no filtering
code in its driver (as we’ve mentioned, the driver just delivers the packet to
its peer vport), so packet could not be copied.</p>

<p>This is why when <code class="highlighter-rouge">tcpdump</code> on patch ports, there is not any output.</p>

<p>The same reason explains why some network utilities, such as <em>tcpdump</em>, <em>netstat</em>,
not work on DPDK-managed physical ports:
in this scenario, after packets are received on physical ports, instead of going
through kernel stack by calling <code class="highlighter-rouge">netif_rx()</code>, they are forwarded directly to
userspace.</p>

<h3 id="33-patch-port-performance-todo-update">3.3 Patch Port Performance (TODO: update)</h3>

<p>As has been pointed out in [2][3][6][7], there is great performance boost in OpenStack
compute node when replacing linux veth pair with OVS patch port for connections
between <code class="highlighter-rouge">br-int</code> and <code class="highlighter-rouge">br-phy</code>. Then, the question is: where the performance
increase comes from?</p>

<p>Here are some explanations from [5]: it “saves an extra lookup in the kernel
datapath and an extra trip to userspace to figure out what happens in the second
bridge”.</p>

<p><strong>I’ll come back to update this later.</strong></p>

<h2 id="references">References</h2>
<ol>
  <li><a href="http://docs.openstack.org/developer/neutron/devref/openvswitch_agent.html">doc: Open vSwitch L2 Agent</a></li>
  <li><a href="https://mail.openvswitch.org/pipermail/ovs-discuss/2013-December/032222.html">disuss: OVS performance with Openstack Neutron</a></li>
  <li><a href="https://docs.google.com/spreadsheets/d/1ZGra_MszBlL0fNsFqd4nOvh1PsgWu58-GxEeh1m1BPw/edit#gid=1328396036">datasheet: Kilo vs Liberty - OVS Agent restart outage</a></li>
  <li><a href="https://bugs.launchpad.net/openstack-manuals/+bug/1487250">patch: Graceful OVS Agent Restart</a></li>
  <li><a href="https://bugs.launchpad.net/neutron/+bug/1383674">discuss: Restarting neutron openvswitch agent causes network hiccup by throwing away all flows</a></li>
  <li><a href="http://www.opencloudblog.com/?p=386">Switching Performance - Chaining OVS bridges</a></li>
  <li><a href="http://www.opencloudblog.com/?p=96">Switching Performance – Connecting Linux Network Namespaces</a></li>
  <li><a href="https://www.kernel.org/doc/Documentation/networking/filter.txt">Linux Socket Filtering aka Berkeley Packet Filter (BPF)</a></li>
  <li><a href="https://www.google.com.hk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=2&amp;ved=0ahUKEwie5eTuo8bSAhUCn5QKHVLwCCgQFggaMAE&amp;url=http%3A%2F%2Fwww.microhowto.info%2Fhowto%2Fsend_an_arbitrary_ethernet_frame_using_an_af_packet_socket_in_c.html&amp;usg=AFQjCNE3nRXs5NgRg4UdO1BG4DKchJp4Dw&amp;sig2=fkF60J6TCgwO-GjQ_dPEiA">microHOWTO: Send an arbitrary Ethernet frame using an AF_PACKET</a></li>
  <li><a href="https://github.com/openvswitch/ovs/commit/2158888d8d8f3b4c00dcf979390a19fa7fcf7942">OVS commit: remove veth pair driver</a></li>
  <li><a href="https://github.com/openvswitch/ovs/commit/4fe648861042761f3a132ba8a998aacd03ad8e4a">OVS commit: add patch port</a></li>
  <li><a href="www.vodun.org/papers/net-papers/van_jacobson_the_bpf_packet_filter.pdf">BPF Packet Filter: A New Approach for Packet Capturing (1992)</a></li>
</ol>


  <!-- POST NAVIGATION -->
  <div class="postNav clearfix">
     
      <a class="prev" href="/blog/ovs-deep-dive-3-datapath/"><span>&laquo;&nbsp;OVS Deep Dive 3: Datapath</span>
      
    </a>
      
      
      <a class="next" href="/blog/ovs-deep-dive-5-datapath-tx-offloading/"><span>OVS Deep Dive 5: Datapath and TX Offloading&nbsp;&raquo;</span>
       
      </a>
     
  </div>
</div>


         

      </div>
   </div><!-- end .content -->

   <div class="footer">
   <div class="container">
      <p class="copy">&copy; 2016-2019
      <a href="https://arthurchiao.github.io">Arthur Chiao</a>, Powered by
      <a href="http://jekyllrb.com">Jekyll </a>, Theme originated from
      <a href="https://github.com/brianmaierjr/long-haul"> Long Haul.</a>

      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
      <span id="busuanzi_container_site_pv"> Site visits:
          <span id="busuanzi_value_site_pv"></span>, powered by<a href="http://busuanzi.ibruce.info/"> busuanzi</a>
      </span>

      </p>

      <div class="footer-links"> 
         <ul class="noList"> 
            
            <li><a href="https://www.facebook.com/profile.php?id=100014334455077">
                  <svg id="facebook-square" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M82.667,1H17.335C8.351,1,1,8.351,1,17.336v65.329c0,8.99,7.351,16.335,16.334,16.335h65.332 C91.652,99.001,99,91.655,99,82.665V17.337C99,8.353,91.652,1.001,82.667,1L82.667,1z M84.318,50H68.375v42.875H50V50h-8.855V35.973 H50v-9.11c0-12.378,5.339-19.739,19.894-19.739h16.772V22.3H72.967c-4.066-0.007-4.57,2.12-4.57,6.078l-0.023,7.594H86.75 l-2.431,14.027V50z"></path>
                  </svg>
            </a></li>
            
            
            <li><a href="https://linkedin.com/in/yanan-zhao-7691317b?trk=hp-identity-photo">
                  <svg id="linkedin" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M99.001,19.428c-3.606,1.608-7.48,2.695-11.547,3.184c4.15-2.503,7.338-6.466,8.841-11.189 c-3.885,2.318-8.187,4-12.768,4.908c-3.667-3.931-8.893-6.387-14.676-6.387c-11.104,0-20.107,9.054-20.107,20.223 c0,1.585,0.177,3.128,0.52,4.609c-16.71-0.845-31.525-8.895-41.442-21.131C6.092,16.633,5.1,20.107,5.1,23.813 c0,7.017,3.55,13.208,8.945,16.834c-3.296-0.104-6.397-1.014-9.106-2.529c-0.002,0.085-0.002,0.17-0.002,0.255 c0,9.799,6.931,17.972,16.129,19.831c-1.688,0.463-3.463,0.71-5.297,0.71c-1.296,0-2.555-0.127-3.783-0.363 c2.559,8.034,9.984,13.882,18.782,14.045c-6.881,5.424-15.551,8.657-24.971,8.657c-1.623,0-3.223-0.096-4.796-0.282 c8.898,5.738,19.467,9.087,30.82,9.087c36.982,0,57.206-30.817,57.206-57.543c0-0.877-0.02-1.748-0.059-2.617 C92.896,27.045,96.305,23.482,99.001,19.428z"></path>
                  </svg>
            </a></li>
            
            
            <li><a href="https://github.com/ArthurChiao">
                  <svg id="github" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M50,1C22.938,1,1,22.938,1,50s21.938,49,49,49s49-21.938,49-49S77.062,1,50,1z M79.099,79.099 c-3.782,3.782-8.184,6.75-13.083,8.823c-1.245,0.526-2.509,0.989-3.79,1.387v-7.344c0-3.86-1.324-6.699-3.972-8.517 c1.659-0.16,3.182-0.383,4.57-0.67c1.388-0.287,2.855-0.702,4.402-1.245c1.547-0.543,2.935-1.189,4.163-1.938 c1.228-0.75,2.409-1.723,3.541-2.919s2.082-2.552,2.847-4.067s1.372-3.334,1.818-5.455c0.446-2.121,0.67-4.458,0.67-7.01 c0-4.945-1.611-9.155-4.833-12.633c1.467-3.828,1.308-7.991-0.478-12.489l-1.197-0.143c-0.829-0.096-2.321,0.255-4.474,1.053 c-2.153,0.798-4.57,2.105-7.249,3.924c-3.797-1.053-7.736-1.579-11.82-1.579c-4.115,0-8.039,0.526-11.772,1.579 c-1.69-1.149-3.294-2.097-4.809-2.847c-1.515-0.75-2.727-1.26-3.637-1.532c-0.909-0.271-1.754-0.439-2.536-0.503 c-0.782-0.064-1.284-0.079-1.507-0.048c-0.223,0.031-0.383,0.064-0.478,0.096c-1.787,4.53-1.946,8.694-0.478,12.489 c-3.222,3.477-4.833,7.688-4.833,12.633c0,2.552,0.223,4.889,0.67,7.01c0.447,2.121,1.053,3.94,1.818,5.455 c0.765,1.515,1.715,2.871,2.847,4.067s2.313,2.169,3.541,2.919c1.228,0.751,2.616,1.396,4.163,1.938 c1.547,0.543,3.014,0.957,4.402,1.245c1.388,0.287,2.911,0.511,4.57,0.67c-2.616,1.787-3.924,4.626-3.924,8.517v7.487 c-1.445-0.43-2.869-0.938-4.268-1.53c-4.899-2.073-9.301-5.041-13.083-8.823c-3.782-3.782-6.75-8.184-8.823-13.083 C9.934,60.948,8.847,55.56,8.847,50s1.087-10.948,3.231-16.016c2.073-4.899,5.041-9.301,8.823-13.083s8.184-6.75,13.083-8.823 C39.052,9.934,44.44,8.847,50,8.847s10.948,1.087,16.016,3.231c4.9,2.073,9.301,5.041,13.083,8.823 c3.782,3.782,6.75,8.184,8.823,13.083c2.143,5.069,3.23,10.457,3.23,16.016s-1.087,10.948-3.231,16.016 C85.848,70.915,82.88,75.317,79.099,79.099L79.099,79.099z"></path>
                  </svg>
            </a></li>
             
            
            <li><a href="mailto:arthurchiao@hotmail.com">
                  <svg id="mail" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M50,1C22.938,1,1,22.938,1,50s21.938,49,49,49s49-21.938,49-49S77.062,1,50,1z M25.5,25.5h49 c0.874,0,1.723,0.188,2.502,0.542L50,57.544L22.998,26.041C23.777,25.687,24.626,25.499,25.5,25.5L25.5,25.5z M19.375,68.375v-36.75 c0-0.128,0.005-0.256,0.014-0.383l17.96,20.953L19.587,69.958C19.448,69.447,19.376,68.916,19.375,68.375L19.375,68.375z M74.5,74.5 h-49c-0.541,0-1.072-0.073-1.583-0.212l17.429-17.429L50,66.956l8.653-10.096l17.429,17.429C75.572,74.427,75.041,74.5,74.5,74.5 L74.5,74.5z M80.625,68.375c0,0.541-0.073,1.072-0.211,1.583L62.652,52.195l17.96-20.953c0.008,0.127,0.014,0.255,0.014,0.383 L80.625,68.375L80.625,68.375z"></path>
                  </svg>
            </a></li>
            
         </ul>
      </div>
   </div>
</div><!-- end .footer -->

   <!-- Add jQuery and other scripts -->
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src=""><\/script>')</script>
<script src="/assets/js/dropcap.min.js"></script>
<script src="/assets/js/responsive-nav.min.js"></script>
<script src="/assets/js/scripts.js"></script>


</body>

</html>
