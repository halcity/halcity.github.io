<!DOCTYPE html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7"><![endif]-->
<!--[if IE 7]><html class="no-js lt-ie9 lt-ie8" <![endif]-->
<!--[if IE 8]><html class="no-js lt-ie9" <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->

<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
       new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
       j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
       'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
       })(window,document,'script','dataLayer','GTM-WP54B9K');</script>
    <!-- End Google Tag Manager -->

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <title>[译] Linux网络栈监控和调优：发送数据 7</title>

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="/assets/img/favicon.ico" />

    <!-- Come and get me RSS readers -->
    <link rel="alternate" type="application/rss+xml" title="ArthurChiao's Blog" href="http://0.0.0.0:4000/feed.xml" />
    
    <!-- Stylesheet -->
    <link rel="stylesheet" href="/assets/css/style.css">
    <!--[if IE 8]><link rel="stylesheet" href="/assets/css/ie.css"><![endif]-->
    <link rel="canonical" href="http://0.0.0.0:4000/blog/tuning-stack-tx-zh-7/">

    <!-- Modernizr -->
    <script src="/assets/js/modernizr.custom.15390.js" type="text/javascript"></script>

    
</head>


<body>
  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WP54B9K"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->

    <div class="header">
     <div class="container">
         <h1 class="logo"><a href="/">ArthurChiao's Blog</a></h1>
         <nav class="nav-collapse">
             <ul class="noList">
                 
                   
                   
                   <li class="element first  ">
                     <a href="/index.html">Home</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/articles">Articles</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/articles-zh">Articles (中文)</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/categories">Categories</a>
                   </li> 
                 
                   
                   
                   <li class="element   last">
                     <a href="/about">About</a>
                   </li> 
                 
                 <!-- <li> <a href="https://github.com/arthurchiao/reading" target="_blank">Reading</a></li> -->
                 <!-- <li> <a href="https://github.com/arthurchiao/" target="_blank">GitHub</a></li> -->
             </ul>
         </nav>
     </div>
 </div><!-- end .header -->


   <div class="content">
      <div class="container">
         <div class="post">
  
  <h1 class="postTitle">[译] Linux网络栈监控和调优：发送数据 7</h1>
  <p class="meta">2018-12-17 | <span class="time">45</span> Minute Read</p>

  
  
  <h2 id="9-网络设备驱动">9 网络设备驱动</h2>

<p>我们即将结束我们的网络栈之旅。</p>

<p>要理解数据包的发送过程，有一个重要的概念。大多数设备和驱动程序通过两个阶段处理数
据包发送：</p>

<ol>
  <li>合理地组织数据，然后触发设备通过DMA从RAM中读取数据并将其发送到网络中</li>
  <li>发送完成后，设备发出中断，驱动程序解除映射缓冲区、释放内存或清除其状态</li>
</ol>

<p>第二阶段通常称为“发送完成”（transmit completion）阶段。我们将对以上两阶段进行研
究，先从第一个开始：发送阶段。</p>

<p>之前已经看到，<code class="highlighter-rouge">dev_hard_start_xmit</code>通过调用<code class="highlighter-rouge">ndo_start_xmit</code>（保持一个锁）来发送
数据，所以接下来先看驱动程序是如何注册<code class="highlighter-rouge">ndo_start_xmit</code>的，然后再深入理解该函数的
工作原理。</p>

<p>与上篇<a href="/blog/tuning-stack-rx-zh-1/">Linux网络栈监控和调优：接收数据</a>
一样，我们将拿<code class="highlighter-rouge">igb</code>驱动作为例子。</p>

<h3 id="91-驱动回调函数注册">9.1 驱动回调函数注册</h3>

<p>驱动程序实现了一系列方法来支持设备操作，例如：</p>

<ol>
  <li>发送数据（<code class="highlighter-rouge">ndo_start_xmit</code>）</li>
  <li>获取统计信息（<code class="highlighter-rouge">ndo_get_stats64</code>）</li>
  <li>处理设备<code class="highlighter-rouge">ioctl</code>s（<code class="highlighter-rouge">ndo_do_ioctl</code>）</li>
</ol>

<p>这些方法通过一个<code class="highlighter-rouge">struct net_device_ops</code>实例导出。让我们来看看<a href="https://github.com/torvalds/linux/blob/v3.13/drivers/net/ethernet/intel/igb/igb_main.c#L1905-L1928">igb驱动程序
</a>
中这些操作：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">igb_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">ndo_open</span>               <span class="o">=</span> <span class="n">igb_open</span><span class="p">,</span>
        <span class="p">.</span><span class="n">ndo_stop</span>               <span class="o">=</span> <span class="n">igb_close</span><span class="p">,</span>
        <span class="p">.</span><span class="n">ndo_start_xmit</span>         <span class="o">=</span> <span class="n">igb_xmit_frame</span><span class="p">,</span>
        <span class="p">.</span><span class="n">ndo_get_stats64</span>        <span class="o">=</span> <span class="n">igb_get_stats64</span><span class="p">,</span>

                <span class="cm">/* ... more fields ... */</span>
<span class="p">};</span>
</code></pre></div></div>

<p>这个<code class="highlighter-rouge">igb_netdev_ops</code>变量在
<a href="https://github.com/torvalds/linux/blob/v3.13/drivers/net/ethernet/intel/igb/igb_main.c#L2090"><code class="highlighter-rouge">igb_probe</code></a>
函数中注册给设备：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
                <span class="cm">/* ... lots of other stuff ... */</span>

        <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">igb_netdev_ops</span><span class="p">;</span>

                <span class="cm">/* ... more code ... */</span>
<span class="p">}</span>
</code></pre></div></div>

<p>正如我们在上一节中看到的，更上层的代码将通过设备的<code class="highlighter-rouge">netdev_ops</code>字段
调用适当的回调函数。想了解更多关于PCI设备是如何启动的，以及何时/何处调用
<code class="highlighter-rouge">igb_probe</code>，请查看我们之前文章中的<a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#initialization">驱动程序初始化
</a>
部分。</p>

<h3 id="92-通过ndo_start_xmit发送数据">9.2 通过<code class="highlighter-rouge">ndo_start_xmit</code>发送数据</h3>

<p>上层的网络栈通过<code class="highlighter-rouge">struct net_device_ops</code>实例里的回调函数，调用驱动程序来执行各种
操作。正如我们之前看到的，qdisc代码调用<code class="highlighter-rouge">ndo_start_xmit</code>将数据传递给驱动程序进行
发送。对于大多数硬件设备，都是在保持一个锁时调用<code class="highlighter-rouge">ndo_start_xmit</code>函数。</p>

<p>在igb设备驱动程序中，<code class="highlighter-rouge">ndo_start_xmit</code>字段初始化为<code class="highlighter-rouge">igb_xmit_frame</code>函数，所以
我们接下来从<code class="highlighter-rouge">igb_xmit_frame</code>开始，查看该驱动程序是如何发送数据的。跟随
<a href="https://github.com/torvalds/linux/blob/v3.13/drivers/net/ethernet/intel/igb/igb_main.c#L4664-L4741">drivers/net/ethernet/intel/igb/igb_main.c</a>
，并记得以下代码在整个执行过程中都hold着一个锁：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">netdev_tx_t</span> <span class="nf">igb_xmit_frame_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
                                <span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">igb_tx_buffer</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">tso</span><span class="p">;</span>
        <span class="n">u32</span> <span class="n">tx_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">u16</span> <span class="n">count</span> <span class="o">=</span> <span class="n">TXD_USE_COUNT</span><span class="p">(</span><span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
        <span class="n">__be16</span> <span class="n">protocol</span> <span class="o">=</span> <span class="n">vlan_get_protocol</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
        <span class="n">u8</span> <span class="n">hdr_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="cm">/* need: 1 descriptor per page * PAGE_SIZE/IGB_MAX_DATA_PER_TXD,
         *       + 1 desc for skb_headlen/IGB_MAX_DATA_PER_TXD,
         *       + 2 desc gap to keep tail from touching head,
         *       + 1 desc for context descriptor,
         * otherwise try next time
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">NETDEV_FRAG_PAGE_MAX_SIZE</span> <span class="o">&gt;</span> <span class="n">IGB_MAX_DATA_PER_TXD</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">f</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">f</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">f</span> <span class="o">&lt;</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span> <span class="n">f</span><span class="o">++</span><span class="p">)</span>
                        <span class="n">count</span> <span class="o">+=</span> <span class="n">TXD_USE_COUNT</span><span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">f</span><span class="p">].</span><span class="n">size</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>函数首先使用<code class="highlighter-rouge">TXD_USER_COUNT</code>宏来计算发送skb所需的描述符数量，用<code class="highlighter-rouge">count</code>
变量表示。然后根据分片情况，对<code class="highlighter-rouge">count</code>进行相应调整。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">if</span> <span class="p">(</span><span class="n">igb_maybe_stop_tx</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">3</span><span class="p">))</span> <span class="p">{</span>
                <span class="cm">/* this is a hard error */</span>
                <span class="k">return</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>然后驱动程序调用内部函数<code class="highlighter-rouge">igb_maybe_stop_tx</code>，检查TX Queue以确保有足够可用的描
述符。如果没有，则返回<code class="highlighter-rouge">NETDEV_TX_BUSY</code>。正如我们之前在qdisc代码中看到的那样，这
将导致qdisc将skb重新入队以便稍后重试。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="cm">/* record the location of the first descriptor for this packet */</span>
        <span class="n">first</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_buffer_info</span><span class="p">[</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">];</span>
        <span class="n">first</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
        <span class="n">first</span><span class="o">-&gt;</span><span class="n">bytecount</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
        <span class="n">first</span><span class="o">-&gt;</span><span class="n">gso_segs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<p>然后，获取TX Queue中下一个可用缓冲区信息，用<code class="highlighter-rouge">struct igb_tx_buffer *first</code>表
示，这个信息稍后将用于设置缓冲区描述符。数据包<code class="highlighter-rouge">skb</code>指针及其大小<code class="highlighter-rouge">skb-&gt;len</code>
也存储到<code class="highlighter-rouge">first</code>。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="n">skb_tx_timestamp</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
</code></pre></div></div>

<p>接下来代码调用<code class="highlighter-rouge">skb_tx_timestamp</code>，获取基于软件的发送时间戳。应用程序可以
使用发送时间戳来确定数据包通过网络栈的发送路径所花费的时间。</p>

<p>某些设备还支持硬件时间戳，这允许系统将打时间戳任务offload到设备。程序员因此可以
获得更准确的时间戳，因为它更接近于硬件实际发送的时间。</p>

<p>某些网络设备可以使用<a href="https://events.linuxfoundation.org/sites/events/files/slides/lcjp14_ichikawa_0.pdf">Precision Time
Protocol</a>
（PTP，精确时间协议）在硬件中为数据包加时间戳。驱动程序处理用户的硬件时间戳请求。</p>

<p>我们现在看到这个代码：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">SKBTX_HW_TSTAMP</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>

                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_tx_skb</span><span class="p">))</span> <span class="p">{</span>
                        <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tx_flags</span> <span class="o">|=</span> <span class="n">SKBTX_IN_PROGRESS</span><span class="p">;</span>
                        <span class="n">tx_flags</span> <span class="o">|=</span> <span class="n">IGB_TX_FLAGS_TSTAMP</span><span class="p">;</span>

                        <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_tx_skb</span> <span class="o">=</span> <span class="n">skb_get</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
                        <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_tx_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_82576</span><span class="p">)</span>
                                <span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ptp_tx_work</span><span class="p">);</span>
                <span class="p">}</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>上面的if语句检查<code class="highlighter-rouge">SKBTX_HW_TSTAMP</code>标志，该标志表示用户请求了硬件时间戳。接下来检
查是否设置了<code class="highlighter-rouge">ptp_tx_skb</code>。一次只能给一个数据包加时间戳，因此给正在打时间戳的skb
上设置了<code class="highlighter-rouge">SKBTX_IN_PROGRESS</code>标志。然后更新<code class="highlighter-rouge">tx_flags</code>，将<code class="highlighter-rouge">IGB_TX_FLAGS_TSTAMP</code>标志
置位。<code class="highlighter-rouge">tx_flags</code>变量稍后将被复制到缓冲区信息结构中。</p>

<p>当前的<code class="highlighter-rouge">jiffies</code>值赋给<code class="highlighter-rouge">ptp_tx_start</code>。驱动程序中的其他代码将使用这个值，
以确保TX硬件打时间戳不会hang住。最后，如果这是一个82576以太网硬件网卡，将用
<code class="highlighter-rouge">schedule_work</code>函数启动<a href="http://www.makelinux.net/ldd3/chp-7-sect-6">工作队列</a>。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">if</span> <span class="p">(</span><span class="n">vlan_tx_tag_present</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">tx_flags</span> <span class="o">|=</span> <span class="n">IGB_TX_FLAGS_VLAN</span><span class="p">;</span>
                <span class="n">tx_flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">vlan_tx_tag_get</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">IGB_TX_FLAGS_VLAN_SHIFT</span><span class="p">);</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>上面的代码将检查skb的<code class="highlighter-rouge">vlan_tci</code>字段是否设置了，如果是，将设置<code class="highlighter-rouge">IGB_TX_FLAGS_VLAN</code>
标记，并保存VLAN ID。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="cm">/* record initial flags and protocol */</span>
        <span class="n">first</span><span class="o">-&gt;</span><span class="n">tx_flags</span> <span class="o">=</span> <span class="n">tx_flags</span><span class="p">;</span>
        <span class="n">first</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">protocol</span><span class="p">;</span>
</code></pre></div></div>

<p>最后将<code class="highlighter-rouge">tx_flags</code>和<code class="highlighter-rouge">protocol</code>值都保存到<code class="highlighter-rouge">first</code>变量里面。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="n">tso</span> <span class="o">=</span> <span class="n">igb_tso</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr_len</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tso</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">out_drop</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tso</span><span class="p">)</span>
                <span class="n">igb_tx_csum</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">first</span><span class="p">);</span>
</code></pre></div></div>

<p>接下来，驱动程序调用其内部函数<code class="highlighter-rouge">igb_tso</code>，判断skb是否需要分片。如果需要
，缓冲区信息变量（<code class="highlighter-rouge">first</code>）将更新标志位，以提示硬件需要做TSO。</p>

<p>如果不需要TSO，则<code class="highlighter-rouge">igb_tso</code>返回0；否则返回1。 如果返回0，则将调用<code class="highlighter-rouge">igb_tx_csum</code>来
处理校验和offload信息（是否需要offload，是否支持此协议的offload）。
<code class="highlighter-rouge">igb_tx_csum</code>函数将检查skb的属性，修改<code class="highlighter-rouge">first</code>变量中的一些标志位，以表示需要校验
和offload。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="n">igb_tx_map</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">hdr_len</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">igb_tx_map</code>函数准备给设备发送的数据。我们后面会仔细查看这个函数。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="cm">/* Make sure there is space in the ring for the next send. */</span>
        <span class="n">igb_maybe_stop_tx</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">DESC_NEEDED</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
</code></pre></div></div>

<p>发送结束之后，驱动要检查确保有足够的描述符用于下一次发送。如果不够，TX Queue将被
关闭。最后返回<code class="highlighter-rouge">NETDEV_TX_OK</code>给上层（qdisc代码）。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">out_drop:</span>
        <span class="n">igb_unmap_and_free_tx_resource</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">first</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>最后是一些错误处理代码，只有当<code class="highlighter-rouge">igb_tso</code>遇到某种错误时才会触发此代码。
<code class="highlighter-rouge">igb_unmap_and_free_tx_resource</code>用于清理数据。在这种情况下也返回<code class="highlighter-rouge">NETDEV_TX_OK</code>
。发送没有成功，但驱动程序释放了相关资源，没有什么需要做的了。请注意，在这种情
况下，此驱动程序不会增加drop计数，但或许它应该增加。</p>

<h3 id="93-igb_tx_map">9.3 <code class="highlighter-rouge">igb_tx_map</code></h3>

<p><code class="highlighter-rouge">igb_tx_map</code>函数处理将skb数据映射到RAM的DMA区域的细节。它还会更新设备TX Queue的
尾部指针，从而触发设备“被唤醒”，从RAM获取数据并开始发送。</p>

<p>让我们简单地看一下这个<a href="https://github.com/torvalds/linux/blob/v3.13/drivers/net/ethernet/intel/igb/igb_main.c#L4501-L4627">函数
</a>
的工作原理：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">igb_tx_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span>
                       <span class="k">struct</span> <span class="n">igb_tx_buffer</span> <span class="o">*</span><span class="n">first</span><span class="p">,</span>
                       <span class="k">const</span> <span class="n">u8</span> <span class="n">hdr_len</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">first</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>

                <span class="cm">/* ... other variables ... */</span>

        <span class="n">u32</span> <span class="n">tx_flags</span> <span class="o">=</span> <span class="n">first</span><span class="o">-&gt;</span><span class="n">tx_flags</span><span class="p">;</span>
        <span class="n">u32</span> <span class="n">cmd_type</span> <span class="o">=</span> <span class="n">igb_tx_cmd_type</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">tx_flags</span><span class="p">);</span>
        <span class="n">u16</span> <span class="n">i</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">;</span>

        <span class="n">tx_desc</span> <span class="o">=</span> <span class="n">IGB_TX_DESC</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

        <span class="n">igb_tx_olinfo_status</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">tx_desc</span><span class="p">,</span> <span class="n">tx_flags</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">hdr_len</span><span class="p">);</span>

        <span class="n">size</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
        <span class="n">data_len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">;</span>

        <span class="n">dma</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
</code></pre></div></div>

<p>上面的代码所做的一些事情：</p>

<ol>
  <li>声明变量并初始化</li>
  <li>使用<code class="highlighter-rouge">IGB_TX_DESC</code>获取下一个可用描述符的指针</li>
  <li><code class="highlighter-rouge">igb_tx_olinfo_status</code>函数更新<code class="highlighter-rouge">tx_flags</code>，并将它们复制到描述符（<code class="highlighter-rouge">tx_desc</code>）中</li>
  <li>计算skb头长度和数据长度</li>
  <li>调用<code class="highlighter-rouge">dma_map_single</code>为<code class="highlighter-rouge">skb-&gt;data</code>构造内存映射，以允许设备通过DMA从RAM中读取数据</li>
</ol>

<p>接下来是驱动程序中的一个<strong>非常长的循环，用于为skb的每个分片生成有效映射</strong>。具体如何
做的细节并不是特别重要，但如下步骤值得一提：</p>

<ul>
  <li>驱动程序遍历该数据包的所有分片</li>
  <li>当前描述符有其数据的DMA地址信息</li>
  <li>如果分片的大小大于单个IGB描述符可以发送的大小，则构造多个描述符指向可DMA区域的块，直到描述符指向整个分片</li>
  <li>更新描述符迭代器</li>
  <li>更新剩余长度</li>
  <li>当没有剩余分片或者已经消耗了整个数据长度时，循环终止</li>
</ul>

<p>下面提供循环的代码以供以上描述参考。这里的代码进一步向读者说明，<strong>如果可能的话，避
免分片是一个好主意</strong>。分片需要大量额外的代码来处理网络栈的每一层，包括驱动层。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="n">tx_buffer</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">frag</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="mi">0</span><span class="p">];;</span> <span class="n">frag</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma</span><span class="p">))</span>
                        <span class="k">goto</span> <span class="n">dma_error</span><span class="p">;</span>

                <span class="cm">/* record length, and DMA address */</span>
                <span class="n">dma_unmap_len_set</span><span class="p">(</span><span class="n">tx_buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
                <span class="n">dma_unmap_addr_set</span><span class="p">(</span><span class="n">tx_buffer</span><span class="p">,</span> <span class="n">dma</span><span class="p">,</span> <span class="n">dma</span><span class="p">);</span>

                <span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">buffer_addr</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">dma</span><span class="p">);</span>

                <span class="k">while</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">IGB_MAX_DATA_PER_TXD</span><span class="p">))</span> <span class="p">{</span>
                        <span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">cmd_type_len</span> <span class="o">=</span>
                                <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">cmd_type</span> <span class="o">^</span> <span class="n">IGB_MAX_DATA_PER_TXD</span><span class="p">);</span>

                        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
                        <span class="n">tx_desc</span><span class="o">++</span><span class="p">;</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
                                <span class="n">tx_desc</span> <span class="o">=</span> <span class="n">IGB_TX_DESC</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
                                <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                        <span class="p">}</span>
                        <span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">olinfo_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

                        <span class="n">dma</span> <span class="o">+=</span> <span class="n">IGB_MAX_DATA_PER_TXD</span><span class="p">;</span>
                        <span class="n">size</span> <span class="o">-=</span> <span class="n">IGB_MAX_DATA_PER_TXD</span><span class="p">;</span>

                        <span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">buffer_addr</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">dma</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">data_len</span><span class="p">))</span>
                        <span class="k">break</span><span class="p">;</span>

                <span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">cmd_type_len</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">cmd_type</span> <span class="o">^</span> <span class="n">size</span><span class="p">);</span>

                <span class="n">i</span><span class="o">++</span><span class="p">;</span>
                <span class="n">tx_desc</span><span class="o">++</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">tx_desc</span> <span class="o">=</span> <span class="n">IGB_TX_DESC</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">olinfo_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

                <span class="n">size</span> <span class="o">=</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">frag</span><span class="p">);</span>
                <span class="n">data_len</span> <span class="o">-=</span> <span class="n">size</span><span class="p">;</span>

                <span class="n">dma</span> <span class="o">=</span> <span class="n">skb_frag_dma_map</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">frag</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                       <span class="n">size</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>

                <span class="n">tx_buffer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>所有需要的描述符都已建好，且<code class="highlighter-rouge">skb</code>的所有数据都映射到DMA地址后，驱动就会
进入到它的最后一步，触发一次发送：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="cm">/* write last descriptor with RS and EOP bits */</span>
        <span class="n">cmd_type</span> <span class="o">|=</span> <span class="n">size</span> <span class="o">|</span> <span class="n">IGB_TXD_DCMD</span><span class="p">;</span>
        <span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">cmd_type_len</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">cmd_type</span><span class="p">);</span>
</code></pre></div></div>

<p>对最后一个描述符设置<code class="highlighter-rouge">RS</code>和<code class="highlighter-rouge">EOP</code>位，以提示设备这是最后一个描述符了。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="n">netdev_tx_sent_queue</span><span class="p">(</span><span class="n">txring_txq</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">),</span> <span class="n">first</span><span class="o">-&gt;</span><span class="n">bytecount</span><span class="p">);</span>

        <span class="cm">/* set the timestamp */</span>
        <span class="n">first</span><span class="o">-&gt;</span><span class="n">time_stamp</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
</code></pre></div></div>

<p>调用<code class="highlighter-rouge">netdev_tx_sent_queue</code>函数，同时带着将发送的字节数作为参数。这个函数是byte
query limit（字节查询限制）功能的一部分，我们将在稍后详细介绍。当前的jiffies存
储到<code class="highlighter-rouge">first</code>的时间戳字段。</p>

<p>接下来，有点tricky：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="cm">/* Force memory writes to complete before letting h/w know there
         * are new descriptors to fetch.  (Only applicable for weak-ordered
         * memory model archs, such as IA-64).
         *
         * We also need this memory barrier to make certain all of the
         * status bits have been updated before next_to_watch is written.
         */</span>
        <span class="n">wmb</span><span class="p">();</span>

        <span class="cm">/* set next_to_watch value indicating a packet is present */</span>
        <span class="n">first</span><span class="o">-&gt;</span><span class="n">next_to_watch</span> <span class="o">=</span> <span class="n">tx_desc</span><span class="p">;</span>

        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

        <span class="n">writel</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">);</span>

        <span class="cm">/* we need this if more than one processor can write to our tail
         * at a time, it synchronizes IO on IA64/Altix systems
         */</span>
        <span class="n">mmiowb</span><span class="p">();</span>

        <span class="k">return</span><span class="p">;</span>
</code></pre></div></div>

<p>上面的代码做了一些重要的事情：</p>

<ol>
  <li>调用<code class="highlighter-rouge">wmb</code>函数强制完成内存写入。这通常称作<strong>“写屏障”</strong>（write barrier）
，是通过CPU平台相关的特殊指令完成的。这对某些CPU架构非常重要，因为如果触发
设备启动DMA时不能确保所有内存写入已经完成，那设备可能从RAM中读取不一致
状态的数据。<a href="http://preshing.com/20120930/weak-vs-strong-memory-models/">这篇文章</a>和<a href="http://www.cs.utexas.edu/~pingali/CS378/2012fa/lectures/consistency.pdf">这个课程</a>深
入探讨了内存顺序的细节</li>
  <li>设置<code class="highlighter-rouge">next_to_watch</code>字段，它将在completion阶段后期使用</li>
  <li>更新计数，并且TX Queue的<code class="highlighter-rouge">next_to_use</code>字段设置为下一个可用的描述符。使用
<code class="highlighter-rouge">writel</code>函数更新TX Queue的尾部。<code class="highlighter-rouge">writel</code>向<a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">内存映射I/O</a>地址写入一个<code class="highlighter-rouge">long</code>型数据
，这里地址是<code class="highlighter-rouge">tx_ring-&gt;tail</code>（一个硬件地址），要写入的值是<code class="highlighter-rouge">i</code>。这次写操作会让
设备知道其他数据已经准备好，可以通过DMA从RAM中读取并写入网络</li>
  <li>最后，调用<code class="highlighter-rouge">mmiowb</code>函数。它执行特定于CPU体系结构的指令，对内存映射的
写操作进行排序。它也是一个写屏障，用于内存映射的I/O写</li>
</ol>

<p>想了解更多关于<code class="highlighter-rouge">wmb</code>，<code class="highlighter-rouge">mmiowb</code>以及何时使用它们的信息，可以阅读Linux内核中一些包含
内存屏障的优秀<a href="https://github.com/torvalds/linux/blob/v3.13/Documentation/memory-barriers.txt">文档</a>
。</p>

<p>最后，代码包含了一些错误处理。只有DMA API（将skb数据地址映射到DMA地址）返回错误
时，才会执行此代码。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">dma_error:</span>
        <span class="n">dev_err</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">"TX DMA map failed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

        <span class="cm">/* clear dma mappings for failed tx_buffer_info map */</span>
        <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
                <span class="n">tx_buffer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="n">igb_unmap_and_free_tx_resource</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">tx_buffer</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">tx_buffer</span> <span class="o">==</span> <span class="n">first</span><span class="p">)</span>
                        <span class="k">break</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
                <span class="n">i</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</code></pre></div></div>

<p>在继续跟进“发送完成”（transmit completion）过程之前，让我们来看下之前跳过了的一
个东西：dynamic queue limits（动态队列限制）。</p>

<h4 id="dynamic-queue-limits-dql">Dynamic Queue Limits (DQL)</h4>

<p>正如在本文中看到的，<strong>数据在逐步接近网络设备的过程中，花费了大量时间在
不同阶段的Queue里面</strong>。队列越大，在队列中所花费的时间就越多。</p>

<p>解决这个问题的一种方式是<strong>背压</strong>（back pressure）。动态队列限制（DQL）系统是一种
机制，驱动程序可以使用该机制向网络系统（network system）施加反压，以避免设备
无法发送时有过多的数据积压在队列。</p>

<p>要使用DQL，驱动需要在其发送和完成例程（transmit and completion routines）中调用
几次简单的API。DQL内部算法判断何时数据已足够多，达到此阈值后，DQL将暂时禁用TX
Queue，从而对网络系统产生背压。当足够的数据已发送完后，DQL再自动重新启用
该队列。</p>

<p><a href="https://www.linuxplumbersconf.org/2012/wp-content/uploads/2012/08/bql_slide.pdf">这里</a>
给出了DQL的一些性能数据及DQL内部算法的说明。</p>

<p>我们刚刚看到的<code class="highlighter-rouge">netdev_tx_sent_queue</code>函数就是DQL API一部分。当数据排
队到设备进行发送时，将调用此函数。发送完成后，驱动程序调用
<code class="highlighter-rouge">netdev_tx_completed_queue</code>。在内部，这两个函数都将调用DQL库（在
<a href="https://github.com/torvalds/linux/blob/v3.13/lib/dynamic_queue_limits.c">lib/dynamic_queue_limits.c</a>
和
<a href="https://github.com/torvalds/linux/blob/v3.13/include/linux/dynamic_queue_limits.h">include/linux/dynamic_queue_limits.h</a>
），以判断是否禁用、重新启用DQL，或保持配置不动。</p>

<p>DQL在sysfs中导出了一些统计信息和调优参数。调整DQL不是必需的；算法自己会随着时间
变化调整其参数。尽管如此，为了完整性，我们稍后会看到如何监控和调整DQL。</p>

<h3 id="94-发送完成transmit-completions">9.4 发送完成（Transmit completions）</h3>

<p>设备发送数据之后会产生一个中断，表示发送已完成。然后，设备驱动程序可以调度一些长
时间运行的工作，例如解除DMA映射、释放数据。这是如何工作的取决于不同设备。对于
<code class="highlighter-rouge">igb</code>驱动程序（及其关联设备），发送完成和数据包接收所触发的IRQ是相同的。这意味着
对于<code class="highlighter-rouge">igb</code>驱动程序，<code class="highlighter-rouge">NET_RX</code>既用于处理发送完成，又用于处理数据包接收。</p>

<p>让我重申一遍，以强调这一点的重要性：<strong>你的设备可能会发出与“接收到数据包时触发的中
断”相同的中断来表示“数据包发送已完成”</strong>。如果是这种情况，则<code class="highlighter-rouge">NET_RX</code> softirq会被用于
处理<strong>数据包接收</strong>和<strong>发送完成</strong>两种情况。</p>

<p>由于两个操作共享相同的IRQ，因此只能注册一个IRQ处理函数来处理这两种情况。
回忆以下收到网络数据时的流程：</p>

<ol>
  <li>收到网络数据</li>
  <li>网络设备触发IRQ</li>
  <li>驱动的IRQ处理程序执行，清除IRQ并运行softIRQ（如果尚未运行）。这里触发的softIRQ是<code class="highlighter-rouge">NET_RX</code>类型</li>
  <li>softIRQ本质上作为单独的内核线程，执行NAPI轮询循环</li>
  <li>只要有足够的预算，NAPI轮询循环就一直接收数据包</li>
  <li>每次处理数据包后，预算都会减少，直到没有更多数据包要处理、预算达到0或时间片已过期为止</li>
</ol>

<p>在igb（和ixgbe）驱动中，上面的步骤5在处理接收数据之前会先处理发送完成（TX
completion）。请记住，<strong>根据驱动程序的实现，处理发送完成和接收数据的函数可能共享一
份处理预算</strong>。igb和ixgbe驱动程序分别跟踪发送完成和接收数据包的预算，因此处理发送完
成不一定会消耗完RX预算。</p>

<p>也就是说，整个NAPI轮询循环在hard code时间片内运行。这意味着如果要处理大量的TX完成
，TX完成可能会比处理接收数据时占用更多的时间片。对于在高负载环境中运行网络硬
件的人来说，这可能是一个重要的考虑因素。</p>

<p>让我们看看igb驱动程序在实际是如何实现的。</p>

<h4 id="941-transmit-completion-irq">9.4.1 Transmit completion IRQ</h4>

<p>收包过程我们已经在<a href="/blog/tuning-stack-rx-zh-1/">数据接收部分的博客</a>
中介绍过，这里不再赘述，只给出相应链接。</p>

<p>那么，让我们从头开始：</p>

<ol>
  <li>网络设备<a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#bringing-a-network-device-up">启用</a>（bring up）</li>
  <li>IRQ处理函数完成<a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#register-an-interrupt-handler">注册</a></li>
  <li>用户程序将数据发送到socket。数据穿过网络栈，最后被网络设备从内存中取出并发送</li>
  <li>设备完成数据发送并触发IRQ表示发送完成</li>
  <li>驱动程序的IRQ处理函数开始<a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#interrupt-handler">处理中断</a></li>
  <li>IRQ处理程序调用<code class="highlighter-rouge">napi_schedule</code></li>
  <li><a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#napi-and-napischedule">NAPI代码</a>触发<code class="highlighter-rouge">NET_RX</code>类型softirq</li>
  <li><code class="highlighter-rouge">NET_RX</code>类型sofitrq的中断处理函数<code class="highlighter-rouge">net_rx_action</code><a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#network-data-processing-begins">开始执行</a></li>
  <li><code class="highlighter-rouge">net_rx_action</code>函数调用驱动程序注册的<a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#napi-poll-function-and-weight">NAPI轮询函数</a></li>
  <li>NAPI轮询函数<code class="highlighter-rouge">igb_poll</code><a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#igbpoll">开始运行</a></li>
</ol>

<p>poll函数<code class="highlighter-rouge">igb_poll</code>同时处理接收数据包和发送完成（transmit completion）逻辑。让我
们深入研究这个函数的代码，看看发生了什么。</p>

<h4 id="942-igb_poll">9.4.2 <code class="highlighter-rouge">igb_poll</code></h4>

<p><a href="https://github.com/torvalds/linux/blob/v3.13/drivers/net/ethernet/intel/igb/igb_main.c#L5987-L6018">drivers/net/ethernet/intel/igb/igb_main.c</a>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 *  igb_poll - NAPI Rx polling callback
 *  @napi: napi polling structure
 *  @budget: count of how many packets we should handle
 **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">igb_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">igb_q_vector</span> <span class="o">*</span><span class="n">q_vector</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">napi</span><span class="p">,</span>
                                                     <span class="k">struct</span> <span class="n">igb_q_vector</span><span class="p">,</span>
                                                     <span class="n">napi</span><span class="p">);</span>
        <span class="n">bool</span> <span class="n">clean_complete</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_IGB_DCA
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IGB_FLAG_DCA_ENABLED</span><span class="p">)</span>
                <span class="n">igb_update_dca</span><span class="p">(</span><span class="n">q_vector</span><span class="p">);</span>
<span class="cp">#endif
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">ring</span><span class="p">)</span>
                <span class="n">clean_complete</span> <span class="o">=</span> <span class="n">igb_clean_tx_irq</span><span class="p">(</span><span class="n">q_vector</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">ring</span><span class="p">)</span>
                <span class="n">clean_complete</span> <span class="o">&amp;=</span> <span class="n">igb_clean_rx_irq</span><span class="p">(</span><span class="n">q_vector</span><span class="p">,</span> <span class="n">budget</span><span class="p">);</span>

        <span class="cm">/* If all work not completed, return budget and keep polling */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clean_complete</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">budget</span><span class="p">;</span>

        <span class="cm">/* If not enough Rx work done, exit the polling mode */</span>
        <span class="n">napi_complete</span><span class="p">(</span><span class="n">napi</span><span class="p">);</span>
        <span class="n">igb_ring_irq_enable</span><span class="p">(</span><span class="n">q_vector</span><span class="p">);</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>函数按顺序执行以下操作：</p>

<ol>
  <li>如果在内核中启用了直接缓存访问（<a href="https://lwn.net/Articles/247493/">DCA</a>）功能
，则更新CPU缓存（预热，warm up），后续对RX Ring Buffer的访问将命中CPU缓存。可以在接
收数据博客的Extras部分中阅读<a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#direct-cache-access-dca">有关DCA的更多信息</a></li>
  <li>调用<code class="highlighter-rouge">igb_clean_tx_irq</code>执行发送完成操作</li>
  <li>调用<code class="highlighter-rouge">igb_clean_rx_irq</code>处理收到的数据包</li>
  <li>最后，检查<code class="highlighter-rouge">clean_complete</code>变量，判断是否还有更多工作可以完成。如果是，则返
回预算。如果是这种情况，<code class="highlighter-rouge">net_rx_action</code>会将此NAPI实例移动到轮询列表的末尾，
以便稍后再次处理</li>
</ol>

<p>要了解<code class="highlighter-rouge">igb_clean_rx_irq</code>如何工作的，请阅读上一篇博客文章的<a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#igbcleanrxirq">这一部分
</a>
。</p>

<p>本文主要关注发送方面，因此我们将继续研究上面的<code class="highlighter-rouge">igb_clean_tx_irq</code>如何工作。</p>

<h4 id="943-igb_clean_tx_irq">9.4.3 <code class="highlighter-rouge">igb_clean_tx_irq</code></h4>

<p>来看一下这个函数的实现，
<a href="https://github.com/torvalds/linux/blob/v3.13/drivers/net/ethernet/intel/igb/igb_main.c#L6020-L6189">drivers/net/ethernet/intel/igb/igb_main.c</a>。</p>

<p>这个函数有点长，分成几部分来看：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">bool</span> <span class="nf">igb_clean_tx_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">igb_q_vector</span> <span class="o">*</span><span class="n">q_vector</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">igb_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">igb_ring</span> <span class="o">*</span><span class="n">tx_ring</span> <span class="o">=</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">ring</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">igb_tx_buffer</span> <span class="o">*</span><span class="n">tx_buffer</span><span class="p">;</span>
        <span class="k">union</span> <span class="n">e1000_adv_tx_desc</span> <span class="o">*</span><span class="n">tx_desc</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">total_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">budget</span> <span class="o">=</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">work_limit</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__IGB_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</code></pre></div></div>

<p>该函数首先初始化一些变量，其中比较重要的是预算（变量<code class="highlighter-rouge">budget</code>）
，初始化为此队列的<code class="highlighter-rouge">tx.work_limit</code>。在igb驱动程序中，<code class="highlighter-rouge">tx.work_limit</code>初始化为hard
code值<code class="highlighter-rouge">IGB_DEFAULT_TX_WORK</code>（128）。</p>

<p>值得注意的是，虽然我们现在看到的TX完成代码与RX处理在同一个<code class="highlighter-rouge">NET_RX</code> softirq中运行
，但igb驱动的TX和RX函数<strong>不共享处理预算</strong>。由于整个轮询函数在同一时间片内运行，因此
每次<code class="highlighter-rouge">igb_poll</code>运行不会出现RX或TX饥饿，只要调用<code class="highlighter-rouge">igb_poll</code>，两者都将被处理。</p>

<p>继续前进，代码检查网络设备是否已关闭。如果是，则返回<code class="highlighter-rouge">true</code>并退出<code class="highlighter-rouge">igb_clean_tx_irq</code>。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="n">tx_buffer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">tx_desc</span> <span class="o">=</span> <span class="n">IGB_TX_DESC</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">i</span> <span class="o">-=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
</code></pre></div></div>

<p>接下来：</p>

<ol>
  <li><code class="highlighter-rouge">tx_buffer</code>变量初始化为<code class="highlighter-rouge">tx_ring-&gt;next_to_clean</code>（其本身被初始化为0）</li>
  <li><code class="highlighter-rouge">tx_desc</code>变量初始化为相关描述符的指针</li>
  <li>计数器<code class="highlighter-rouge">i</code>减去TX Queue的大小。可以调整此值（我们将在调优部分中看到），但初始化为<code class="highlighter-rouge">IGB_DEFAULT_TXD</code>（256）</li>
</ol>

<p>接下来，循环开始。它包含一些有用的注释，用于解释每个步骤中发生的情况：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">do</span> <span class="p">{</span>
                <span class="k">union</span> <span class="n">e1000_adv_tx_desc</span> <span class="o">*</span><span class="n">eop_desc</span> <span class="o">=</span> <span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">next_to_watch</span><span class="p">;</span>

                <span class="cm">/* if next_to_watch is not set then there is no work pending */</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eop_desc</span><span class="p">)</span>
                        <span class="k">break</span><span class="p">;</span>

                <span class="cm">/* prevent any other reads prior to eop_desc */</span>
                <span class="n">read_barrier_depends</span><span class="p">();</span>

                <span class="cm">/* if DD is not set pending work has not been completed */</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">eop_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">E1000_TXD_STAT_DD</span><span class="p">)))</span>
                        <span class="k">break</span><span class="p">;</span>

                <span class="cm">/* clear next_to_watch to prevent false hangs */</span>
                <span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">next_to_watch</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

                <span class="cm">/* update the statistics for this packet */</span>
                <span class="n">total_bytes</span> <span class="o">+=</span> <span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">bytecount</span><span class="p">;</span>
                <span class="n">total_packets</span> <span class="o">+=</span> <span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">gso_segs</span><span class="p">;</span>

                <span class="cm">/* free the skb */</span>
                <span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>

                <span class="cm">/* unmap skb header data */</span>
                <span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
                                 <span class="n">dma_unmap_addr</span><span class="p">(</span><span class="n">tx_buffer</span><span class="p">,</span> <span class="n">dma</span><span class="p">),</span>
                                 <span class="n">dma_unmap_len</span><span class="p">(</span><span class="n">tx_buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">),</span>
                                 <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>

                <span class="cm">/* clear tx_buffer data */</span>
                <span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                <span class="n">dma_unmap_len_set</span><span class="p">(</span><span class="n">tx_buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>

<ol>
  <li>首先将<code class="highlighter-rouge">eop_desc</code>（eop = end of packet）设置为发送缓冲区<code class="highlighter-rouge">tx_buffer</code>的<code class="highlighter-rouge">next_to_watch</code>，后者是在我们之前看到的发送代码中设置的</li>
  <li>如果<code class="highlighter-rouge">eop_desc</code>为<code class="highlighter-rouge">NULL</code>，则表示没有待处理的工作</li>
  <li>接下来调用<code class="highlighter-rouge">read_barrier_depends</code>函数，该函数执行此CPU体系结构相关的指令，通过屏障防止其他任何读操作</li>
  <li>接下来，检查描述符<code class="highlighter-rouge">eop_desc</code>的状态位。如果<code class="highlighter-rouge">E1000_TXD_STAT_DD</code>未设置，则表示发送尚未完成，因此跳出循环</li>
  <li>清除<code class="highlighter-rouge">tx_buffer-&gt;next_to_watch</code>。驱动中的watchdog定时器将监视此字段以判断发送是否hang住。清除此字段将不会触发watchdog</li>
  <li>统计发送的总字节数和包数，这些计数将被复制到驱动的相应计数中</li>
  <li>释放skb</li>
  <li>调用<code class="highlighter-rouge">dma_unmap_single</code>取消skb数据区映射</li>
  <li><code class="highlighter-rouge">tx_buffer-&gt;skb</code>设置为<code class="highlighter-rouge">NULL</code>，解除<code class="highlighter-rouge">tx_buffer</code>映射</li>
</ol>

<p>接下来，在上面的循环内部开始了另一个循环：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                <span class="cm">/* clear last DMA location and unmap remaining buffers */</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">tx_desc</span> <span class="o">!=</span> <span class="n">eop_desc</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">tx_buffer</span><span class="o">++</span><span class="p">;</span>
                        <span class="n">tx_desc</span><span class="o">++</span><span class="p">;</span>
                        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
                                <span class="n">i</span> <span class="o">-=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
                                <span class="n">tx_buffer</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_buffer_info</span><span class="p">;</span>
                                <span class="n">tx_desc</span> <span class="o">=</span> <span class="n">IGB_TX_DESC</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
                        <span class="p">}</span>

                        <span class="cm">/* unmap any remaining paged data */</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">dma_unmap_len</span><span class="p">(</span><span class="n">tx_buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
                                <span class="n">dma_unmap_page</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
                                               <span class="n">dma_unmap_addr</span><span class="p">(</span><span class="n">tx_buffer</span><span class="p">,</span> <span class="n">dma</span><span class="p">),</span>
                                               <span class="n">dma_unmap_len</span><span class="p">(</span><span class="n">tx_buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">),</span>
                                               <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
                                <span class="n">dma_unmap_len_set</span><span class="p">(</span><span class="n">tx_buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
                        <span class="p">}</span>
                <span class="p">}</span>
</code></pre></div></div>

<p>这个内层循环会遍历每个发送描述符，直到<code class="highlighter-rouge">tx_desc</code>等于<code class="highlighter-rouge">eop_desc</code>，并会解除被其他描
述符引用的被DMA映射的数据。</p>

<p>外层循环继续：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                <span class="cm">/* move us one more past the eop_desc for start of next pkt */</span>
                <span class="n">tx_buffer</span><span class="o">++</span><span class="p">;</span>
                <span class="n">tx_desc</span><span class="o">++</span><span class="p">;</span>
                <span class="n">i</span><span class="o">++</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
                        <span class="n">i</span> <span class="o">-=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
                        <span class="n">tx_buffer</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_buffer_info</span><span class="p">;</span>
                        <span class="n">tx_desc</span> <span class="o">=</span> <span class="n">IGB_TX_DESC</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="cm">/* issue prefetch for next Tx descriptor */</span>
                <span class="n">prefetch</span><span class="p">(</span><span class="n">tx_desc</span><span class="p">);</span>

                <span class="cm">/* update budget accounting */</span>
                <span class="n">budget</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">budget</span><span class="p">));</span>
</code></pre></div></div>

<p>外层循环递增迭代器，更新budget，然后检查是否要进入下一次循环。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="n">netdev_tx_completed_queue</span><span class="p">(</span><span class="n">txring_txq</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">),</span>
                                  <span class="n">total_packets</span><span class="p">,</span> <span class="n">total_bytes</span><span class="p">);</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
        <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">u64_stats_update_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_syncp</span><span class="p">);</span>
        <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_stats</span><span class="p">.</span><span class="n">bytes</span> <span class="o">+=</span> <span class="n">total_bytes</span><span class="p">;</span>
        <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_stats</span><span class="p">.</span><span class="n">packets</span> <span class="o">+=</span> <span class="n">total_packets</span><span class="p">;</span>
        <span class="n">u64_stats_update_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_syncp</span><span class="p">);</span>
        <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">total_bytes</span> <span class="o">+=</span> <span class="n">total_bytes</span><span class="p">;</span>
        <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">total_packets</span> <span class="o">+=</span> <span class="n">total_packets</span><span class="p">;</span>
</code></pre></div></div>

<p>这段代码：</p>

<ol>
  <li>调用<code class="highlighter-rouge">netdev_tx_completed_queue</code>，它是上面解释的DQL API的一部分。如果处理了足够的发送完成，这可能会重新启用TX Queue</li>
  <li>更新各处的统计信息，以便用户可以访问它们，我们稍后会看到</li>
</ol>

<p>代码继续，首先检查是否设置了<code class="highlighter-rouge">IGB_RING_FLAG_TX_DETECT_HANG</code>标志。每次运行定时器
回调函数时，watchdog定时器都会设置此标志，以强制定期检查TX Queue。如果该标志被设
置了，则代码将检查TX Queue是否hang住：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">IGB_RING_FLAG_TX_DETECT_HANG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

                <span class="cm">/* Detect a transmit hang in hardware, this serializes the
                 * check with the clearing of time_stamp and movement of i
                 */</span>
                <span class="n">clear_bit</span><span class="p">(</span><span class="n">IGB_RING_FLAG_TX_DETECT_HANG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">next_to_watch</span> <span class="o">&amp;&amp;</span>
                    <span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">time_stamp</span> <span class="o">+</span>
                               <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_timeout_factor</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
                    <span class="o">!</span><span class="p">(</span><span class="n">rd32</span><span class="p">(</span><span class="n">E1000_STATUS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">E1000_STATUS_TXOFF</span><span class="p">))</span> <span class="p">{</span>

                        <span class="cm">/* detected Tx unit hang */</span>
                        <span class="n">dev_err</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
                                <span class="s">"Detected Tx Unit Hang</span><span class="se">\n</span><span class="s">"</span>
                                <span class="s">"  Tx Queue             &lt;%d&gt;</span><span class="se">\n</span><span class="s">"</span>
                                <span class="s">"  TDH                  &lt;%x&gt;</span><span class="se">\n</span><span class="s">"</span>
                                <span class="s">"  TDT                  &lt;%x&gt;</span><span class="se">\n</span><span class="s">"</span>
                                <span class="s">"  next_to_use          &lt;%x&gt;</span><span class="se">\n</span><span class="s">"</span>
                                <span class="s">"  next_to_clean        &lt;%x&gt;</span><span class="se">\n</span><span class="s">"</span>
                                <span class="s">"buffer_info[next_to_clean]</span><span class="se">\n</span><span class="s">"</span>
                                <span class="s">"  time_stamp           &lt;%lx&gt;</span><span class="se">\n</span><span class="s">"</span>
                                <span class="s">"  next_to_watch        &lt;%p&gt;</span><span class="se">\n</span><span class="s">"</span>
                                <span class="s">"  jiffies              &lt;%lx&gt;</span><span class="se">\n</span><span class="s">"</span>
                                <span class="s">"  desc.status          &lt;%x&gt;</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                                <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">queue_index</span><span class="p">,</span>
                                <span class="n">rd32</span><span class="p">(</span><span class="n">E1000_TDH</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">reg_idx</span><span class="p">)),</span>
                                <span class="n">readl</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">),</span>
                                <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">,</span>
                                <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span><span class="p">,</span>
                                <span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">time_stamp</span><span class="p">,</span>
                                <span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">next_to_watch</span><span class="p">,</span>
                                <span class="n">jiffies</span><span class="p">,</span>
                                <span class="n">tx_buffer</span><span class="o">-&gt;</span><span class="n">next_to_watch</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">status</span><span class="p">);</span>
                        <span class="n">netif_stop_subqueue</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span>
                                            <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">queue_index</span><span class="p">);</span>

                        <span class="cm">/* we are about to reset, no point in enabling stuff */</span>
                        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
                <span class="p">}</span>
</code></pre></div></div>

<p>上面的if语句检查：</p>

<ol>
  <li><code class="highlighter-rouge">tx_buffer-&gt;next_to_watch</code>已设置，并且</li>
  <li>当前jiffies大于<code class="highlighter-rouge">tx_buffer</code>发送路径上记录的<code class="highlighter-rouge">time_stamp</code>加上超时因子，并且</li>
  <li>设备的发送状态寄存器未设置<code class="highlighter-rouge">E1000_STATUS_TXOFF</code></li>
</ol>

<p>如果这三个条件都为真，则会打印一个错误，表明已检测到挂起。<code class="highlighter-rouge">netif_stop_subqueue</code>
用于关闭队列，最后函数返回true。</p>

<p>让我们继续阅读代码，看看如果没有发送挂起检查会发生什么，或者如果有，但没有检测到
挂起：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define TX_WAKE_THRESHOLD (DESC_NEEDED * 2)
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">total_packets</span> <span class="o">&amp;&amp;</span>
            <span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
            <span class="n">igb_desc_unused</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">TX_WAKE_THRESHOLD</span><span class="p">))</span> <span class="p">{</span>
                <span class="cm">/* Make sure that anybody stopping the queue after this
                 * sees the new next_to_clean.
                 */</span>
                <span class="n">smp_mb</span><span class="p">();</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">__netif_subqueue_stopped</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span>
                                             <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">queue_index</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                    <span class="o">!</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__IGB_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)))</span> <span class="p">{</span>
                        <span class="n">netif_wake_subqueue</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span>
                                            <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">queue_index</span><span class="p">);</span>

                        <span class="n">u64_stats_update_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_syncp</span><span class="p">);</span>
                        <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_stats</span><span class="p">.</span><span class="n">restart_queue</span><span class="o">++</span><span class="p">;</span>
                        <span class="n">u64_stats_update_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tx_syncp</span><span class="p">);</span>
                <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="o">!!</span><span class="n">budget</span><span class="p">;</span>
</code></pre></div></div>

<p>在上面的代码中，如果先前已禁用，则驱动程序将重新启动TX Queue。
它首先检查：</p>

<ol>
  <li>是否有数据包处理完成（<code class="highlighter-rouge">total_packets</code>非零）</li>
  <li>调用<code class="highlighter-rouge">netif_carrier_ok</code>，确保设备没有被关闭</li>
  <li>TX Queue中未使用的描述符数量大于等于<code class="highlighter-rouge">TX_WAKE_THRESHOLD</code>（我的x86_64系统上此阈值为42）</li>
</ol>

<p>如果满足以上所有条件，则执行<strong>写屏障</strong>（<code class="highlighter-rouge">smp_mb</code>）。</p>

<p>接下来检查另一组条件。如果：</p>

<ol>
  <li>队列停止了</li>
  <li>设备未关闭</li>
</ol>

<p>则调用<code class="highlighter-rouge">netif_wake_subqueue</code>唤醒TX Queue，并向更高层发信号通知它们可能需要将数据
再次入队。<code class="highlighter-rouge">restart_queue</code>统计计数器递增。我们接下来会看到如何阅读这个值。</p>

<p>最后，返回一个布尔值。如果有任何剩余的未使用预算，则返回true，否则为false。在
<code class="highlighter-rouge">igb_poll</code>中检查此值以确定返回<code class="highlighter-rouge">net_rx_action</code>的内容。</p>

<h4 id="944-igb_poll返回值">9.4.4 <code class="highlighter-rouge">igb_poll</code>返回值</h4>

<p><code class="highlighter-rouge">igb_poll</code>函数通过以下逻辑决定返回什么值给<code class="highlighter-rouge">net_rx_action</code>：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">if</span> <span class="p">(</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">ring</span><span class="p">)</span>
                <span class="n">clean_complete</span> <span class="o">=</span> <span class="n">igb_clean_tx_irq</span><span class="p">(</span><span class="n">q_vector</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">ring</span><span class="p">)</span>
                <span class="n">clean_complete</span> <span class="o">&amp;=</span> <span class="n">igb_clean_rx_irq</span><span class="p">(</span><span class="n">q_vector</span><span class="p">,</span> <span class="n">budget</span><span class="p">);</span>

        <span class="cm">/* If all work not completed, return budget and keep polling */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clean_complete</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">budget</span><span class="p">;</span>
</code></pre></div></div>

<p>换句话说，如果：</p>

<ol>
  <li><code class="highlighter-rouge">igb_clean_tx_irq</code>清除了所有<strong>待发送</strong>数据包，且未用完其TX预算（transmit
completion budget），并且</li>
  <li><code class="highlighter-rouge">igb_clean_rx_irq</code>清除了所有<strong>接收到的</strong>数据包，且未用完其RX预算（packet
processing budget）</li>
</ol>

<p>那么，最后将返回整个预算值（包括igb在内的大多数驱动程序hard code为64）；否则，如果
RX或TX处理中的任何用完了其budget（因为还有更多工作要做），则调用<code class="highlighter-rouge">napi_complete</code>
禁用NAPI并返回0：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="cm">/* If not enough Rx work done, exit the polling mode */</span>
        <span class="n">napi_complete</span><span class="p">(</span><span class="n">napi</span><span class="p">);</span>
        <span class="n">igb_ring_irq_enable</span><span class="p">(</span><span class="n">q_vector</span><span class="p">);</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="95-监控网络设备">9.5 监控网络设备</h3>

<p>监控网络设备有多种方式，每种方式提供的监控粒度和复杂度各不相同。我们先从最粗
大粒度开始，然后逐步到最细的粒度。</p>

<h4 id="951-使用ethtool--s命令">9.5.1 使用<code class="highlighter-rouge">ethtool -S</code>命令</h4>

<p>Ubuntu安装ethtool：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>apt-get <span class="nb">install </span>ethtool.
</code></pre></div></div>

<p><code class="highlighter-rouge">ethtool -S &lt;NIC&gt;</code>可以打印设备的收发统计信息（例如，发送错误）：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>ethtool <span class="nt">-S</span> eth0
NIC statistics:
     rx_packets: 597028087
     tx_packets: 5924278060
     rx_bytes: 112643393747
     tx_bytes: 990080156714
     rx_broadcast: 96
     tx_broadcast: 116
     rx_multicast: 20294528
     ....
</code></pre></div></div>

<p>监控这个数据不是太容易，因为并无统一的标准规定<code class="highlighter-rouge">-S</code>应该打印出哪些字段。不同的设备
，甚至是相同设备的不同版本，都可能打印出名字不同但意思相同的字段。</p>

<p>你首先需要检查里面的“drop”、“buffer”、“miss”、“errors”等字段，然后查看驱动程序的
代码，以确定哪些计数是在软件里更新的（例如，内存不足时更新），哪些是直接来自硬件
寄存器更新的。如果是硬件寄存器值，那你需要查看网卡的data sheet，确定这个计数真正
表示什么，因为ethtool给出的很多字段都是有误导性的（misleading）。</p>

<h4 id="952-使用sysfs">9.5.2 使用<code class="highlighter-rouge">sysfs</code></h4>

<p>sysfs也提供了很多统计值，但比网卡层的统计更上层一些。</p>

<p>例如，你可以通过<code class="highlighter-rouge">cat &lt;file&gt;</code>的方式查看eth0接收的丢包数。</p>

<p>示例：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cat</span> /sys/class/net/eth0/statistics/tx_aborted_errors
2
</code></pre></div></div>

<p>每个counter对应一个文件，包括<code class="highlighter-rouge">tx_aborted_errors</code>, <code class="highlighter-rouge">tx_carrier_errors</code>, <code class="highlighter-rouge">tx_compressed</code>, <code class="highlighter-rouge">tx_dropped</code>,等等。</p>

<p><strong>不幸的是，每个值代表什么是由驱动决定的，因此，什么时候更新它们，在什么条件下更新
，都是驱动决定的。</strong>例如，你可能已经注意到，对于同一种错误，有的驱动将其视为drop
，而有的驱动将其视为miss。</p>

<p>如果这些值对你非常重要，那你必须阅读驱动代码和网卡data sheet，以确定每个值真正代
表什么。</p>

<h4 id="953-使用procnetdev">9.5.3 使用<code class="highlighter-rouge">/proc/net/dev</code></h4>

<p><code class="highlighter-rouge">/proc/net/dev</code>提供了更高一层的统计，它给系统中的每个网络设备一个统计摘要。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cat</span> /proc/net/dev
Inter-|   Receive                                                |  Transmit
 face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed
  eth0: 110346752214 597737500    0    2    0     0          0  20963860 990024805984 6066582604    0    0    0     0       0          0
    lo: 428349463836 1579868535    0    0    0     0          0         0 428349463836 1579868535    0    0    0     0       0          0
</code></pre></div></div>

<p>这里打印出来的字段是上面sysfs里字段的一个子集，可以作为通用general reference。</p>

<p>上面的建议在这里同样适用，即：
如果这些值对你非常重要，那你必须阅读驱动代码和网卡data sheet，以确定每个值真正代
表什么。</p>

<h3 id="96-监控-dql">9.6 监控 DQL</h3>

<p>可以通过<code class="highlighter-rouge">/sys/class/net/&lt;NIC&gt;/queues/tx-&lt;QUEUE_ID&gt;/byte_queue_limits/</code>
监控网络设备的动态队列限制（DQL）信息。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cat</span> /sys/class/net/eth0/queues/tx-0/byte_queue_limits/inflight
350
</code></pre></div></div>

<p>文件包括：</p>

<ol>
  <li><code class="highlighter-rouge">hold_time</code>: Initialized to HZ (a single hertz). If the queue has been full for hold_time, then the maximum size is decreased.</li>
  <li><code class="highlighter-rouge">inflight</code>: This value is equal to (number of packets queued - number of packets completed). It is the current number of packets being transmit for which a completion has not been processed.</li>
  <li><code class="highlighter-rouge">limit_max</code>: A hardcoded value, set to DQL_MAX_LIMIT (1879048192 on my x86_64 system).</li>
  <li><code class="highlighter-rouge">limit_min</code>: A hardcoded value, set to 0.</li>
  <li><code class="highlighter-rouge">limit</code>: A value between limit_min and limit_max which represents the current maximum number of objects which can be queued.</li>
</ol>

<p>在修改这些值之前，强烈建议先阅读<a href="https://www.linuxplumbersconf.org/2012/wp-content/uploads/2012/08/bql_slide.pdf">这些资料
</a>，以更深入地了解其算法。</p>

<h3 id="97-调优网络设备">9.7 调优网络设备</h3>

<h4 id="971-查询tx-queue数量">9.7.1 查询TX Queue数量</h4>

<p>如果网络及其驱动支持多TX Queue，那可以用ethtool调整TX queue（也叫TX channel）的数量。</p>

<p>查看网卡TX Queue数量：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>ethtool <span class="nt">-l</span> eth0
Channel parameters <span class="k">for </span>eth0:
Pre-set maximums:
RX:   0
TX:   0
Other:    0
Combined: 8
Current hardware settings:
RX:   0
TX:   0
Other:    0
Combined: 4
</code></pre></div></div>

<p>这里显示了（由驱动和硬件）预设的最大值，以及当前值。</p>

<p>注意：不是所有设备驱动都支持这个选项。</p>

<p>如果你的网卡不支持，会遇到以下错误：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>ethtool <span class="nt">-l</span> eth0
Channel parameters <span class="k">for </span>eth0:
Cannot get device channel parameters
: Operation not supported
</code></pre></div></div>

<p>这表示设备驱动没有实现ethtool的<code class="highlighter-rouge">get_channels</code>方法，这可能是由于网卡不支持调整
queue数量，不支持多TX Queue，或者驱动版本太旧导致不支持此操作。</p>

<h4 id="972-调整tx-queue数量">9.7.2 调整TX queue数量</h4>

<p><code class="highlighter-rouge">ethtool -L</code>可以修改TX Queue数量。</p>

<p>注意：一些设备及其驱动只支持combined queue，这种情况下一个TX queue和和一个RX queue绑定到一起的。前面的例子中我们已经看到了。</p>

<p>例子：设置收发队列数量为8：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>ethtool <span class="nt">-L</span> eth0 combined 8
</code></pre></div></div>

<p>如果你的设备和驱动支持分别设置TX queue和RX queue的数量，那你可以分别设置。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>ethtool <span class="nt">-L</span> eth0 tx 8
</code></pre></div></div>

<p>注意：对于大部分驱动，调整以上设置会导致网卡先down再up，经过这个网卡的连接会断掉
。如果只是一次性改动，那这可能不是太大问题。</p>

<h4 id="973-调整tx-queue大小">9.7.3 调整TX queue大小</h4>

<p>一些设备及其驱动支持修改TX queue大小，这是如何实现的取决于具体的硬件，但是，
ethtool提供了一个通用的接口可以调整这个大小。由于DQL在更高层面处理数据排队的问题
，因此调整队列大小可能不会产生明显的影响。然而，你可能还是想要将TX queue调到最大
，然后再把剩下的事情交给DQL：</p>

<p><code class="highlighter-rouge">ethtool -g</code>查看队列当前的大小：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>ethtool <span class="nt">-g</span> eth0
Ring parameters <span class="k">for </span>eth0:
Pre-set maximums:
RX:   4096
RX Mini:  0
RX Jumbo: 0
TX:   4096
Current hardware settings:
RX:   512
RX Mini:  0
RX Jumbo: 0
TX:   512
</code></pre></div></div>

<p>以上显示硬件支持最大4096个接收和发送描述符，但当前只使用了512个。</p>

<p><code class="highlighter-rouge">-G</code>修改queue大小：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>ethtool <span class="nt">-G</span> eth0 tx 4096
</code></pre></div></div>

<p>注意：对于大部分驱动，调整以上设置会导致网卡先down再up，经过这个网卡的连接会断掉
。如果只是一次性改动，那这可能不是太大问题。</p>

<h2 id="10-网络栈之旅结束">10 网络栈之旅：结束</h2>

<p>至此，你已经知道关于Linux如何发送数据包的全部内容了：从用户程序直到驱动，以及反
方向。</p>


  <!-- POST NAVIGATION -->
  <div class="postNav clearfix">
     
      <a class="prev" href="/blog/tuning-stack-tx-zh-6/"><span>&laquo;&nbsp;[译] Linux网络栈监控和调优：发送数据 6</span>
      
    </a>
      
      
      <a class="next" href="/blog/tuning-stack-tx-zh-8/"><span>[译] Linux网络栈监控和调优：发送数据 8&nbsp;&raquo;</span>
       
      </a>
     
  </div>
</div>


         

      </div>
   </div><!-- end .content -->

   <div class="footer">
   <div class="container">
      <p class="copy">&copy; 2016-2019
      <a href="https://arthurchiao.github.io">Arthur Chiao</a>, Powered by
      <a href="http://jekyllrb.com">Jekyll </a>, Theme originated from
      <a href="https://github.com/brianmaierjr/long-haul"> Long Haul.</a>

      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
      <span id="busuanzi_container_site_pv"> Site visits:
          <span id="busuanzi_value_site_pv"></span>, powered by<a href="http://busuanzi.ibruce.info/"> busuanzi</a>
      </span>

      </p>

      <div class="footer-links"> 
         <ul class="noList"> 
            
            <li><a href="https://www.facebook.com/profile.php?id=100014334455077">
                  <svg id="facebook-square" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M82.667,1H17.335C8.351,1,1,8.351,1,17.336v65.329c0,8.99,7.351,16.335,16.334,16.335h65.332 C91.652,99.001,99,91.655,99,82.665V17.337C99,8.353,91.652,1.001,82.667,1L82.667,1z M84.318,50H68.375v42.875H50V50h-8.855V35.973 H50v-9.11c0-12.378,5.339-19.739,19.894-19.739h16.772V22.3H72.967c-4.066-0.007-4.57,2.12-4.57,6.078l-0.023,7.594H86.75 l-2.431,14.027V50z"></path>
                  </svg>
            </a></li>
            
            
            <li><a href="https://linkedin.com/in/yanan-zhao-7691317b?trk=hp-identity-photo">
                  <svg id="linkedin" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M99.001,19.428c-3.606,1.608-7.48,2.695-11.547,3.184c4.15-2.503,7.338-6.466,8.841-11.189 c-3.885,2.318-8.187,4-12.768,4.908c-3.667-3.931-8.893-6.387-14.676-6.387c-11.104,0-20.107,9.054-20.107,20.223 c0,1.585,0.177,3.128,0.52,4.609c-16.71-0.845-31.525-8.895-41.442-21.131C6.092,16.633,5.1,20.107,5.1,23.813 c0,7.017,3.55,13.208,8.945,16.834c-3.296-0.104-6.397-1.014-9.106-2.529c-0.002,0.085-0.002,0.17-0.002,0.255 c0,9.799,6.931,17.972,16.129,19.831c-1.688,0.463-3.463,0.71-5.297,0.71c-1.296,0-2.555-0.127-3.783-0.363 c2.559,8.034,9.984,13.882,18.782,14.045c-6.881,5.424-15.551,8.657-24.971,8.657c-1.623,0-3.223-0.096-4.796-0.282 c8.898,5.738,19.467,9.087,30.82,9.087c36.982,0,57.206-30.817,57.206-57.543c0-0.877-0.02-1.748-0.059-2.617 C92.896,27.045,96.305,23.482,99.001,19.428z"></path>
                  </svg>
            </a></li>
            
            
            <li><a href="https://github.com/ArthurChiao">
                  <svg id="github" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M50,1C22.938,1,1,22.938,1,50s21.938,49,49,49s49-21.938,49-49S77.062,1,50,1z M79.099,79.099 c-3.782,3.782-8.184,6.75-13.083,8.823c-1.245,0.526-2.509,0.989-3.79,1.387v-7.344c0-3.86-1.324-6.699-3.972-8.517 c1.659-0.16,3.182-0.383,4.57-0.67c1.388-0.287,2.855-0.702,4.402-1.245c1.547-0.543,2.935-1.189,4.163-1.938 c1.228-0.75,2.409-1.723,3.541-2.919s2.082-2.552,2.847-4.067s1.372-3.334,1.818-5.455c0.446-2.121,0.67-4.458,0.67-7.01 c0-4.945-1.611-9.155-4.833-12.633c1.467-3.828,1.308-7.991-0.478-12.489l-1.197-0.143c-0.829-0.096-2.321,0.255-4.474,1.053 c-2.153,0.798-4.57,2.105-7.249,3.924c-3.797-1.053-7.736-1.579-11.82-1.579c-4.115,0-8.039,0.526-11.772,1.579 c-1.69-1.149-3.294-2.097-4.809-2.847c-1.515-0.75-2.727-1.26-3.637-1.532c-0.909-0.271-1.754-0.439-2.536-0.503 c-0.782-0.064-1.284-0.079-1.507-0.048c-0.223,0.031-0.383,0.064-0.478,0.096c-1.787,4.53-1.946,8.694-0.478,12.489 c-3.222,3.477-4.833,7.688-4.833,12.633c0,2.552,0.223,4.889,0.67,7.01c0.447,2.121,1.053,3.94,1.818,5.455 c0.765,1.515,1.715,2.871,2.847,4.067s2.313,2.169,3.541,2.919c1.228,0.751,2.616,1.396,4.163,1.938 c1.547,0.543,3.014,0.957,4.402,1.245c1.388,0.287,2.911,0.511,4.57,0.67c-2.616,1.787-3.924,4.626-3.924,8.517v7.487 c-1.445-0.43-2.869-0.938-4.268-1.53c-4.899-2.073-9.301-5.041-13.083-8.823c-3.782-3.782-6.75-8.184-8.823-13.083 C9.934,60.948,8.847,55.56,8.847,50s1.087-10.948,3.231-16.016c2.073-4.899,5.041-9.301,8.823-13.083s8.184-6.75,13.083-8.823 C39.052,9.934,44.44,8.847,50,8.847s10.948,1.087,16.016,3.231c4.9,2.073,9.301,5.041,13.083,8.823 c3.782,3.782,6.75,8.184,8.823,13.083c2.143,5.069,3.23,10.457,3.23,16.016s-1.087,10.948-3.231,16.016 C85.848,70.915,82.88,75.317,79.099,79.099L79.099,79.099z"></path>
                  </svg>
            </a></li>
             
            
            <li><a href="mailto:arthurchiao@hotmail.com">
                  <svg id="mail" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M50,1C22.938,1,1,22.938,1,50s21.938,49,49,49s49-21.938,49-49S77.062,1,50,1z M25.5,25.5h49 c0.874,0,1.723,0.188,2.502,0.542L50,57.544L22.998,26.041C23.777,25.687,24.626,25.499,25.5,25.5L25.5,25.5z M19.375,68.375v-36.75 c0-0.128,0.005-0.256,0.014-0.383l17.96,20.953L19.587,69.958C19.448,69.447,19.376,68.916,19.375,68.375L19.375,68.375z M74.5,74.5 h-49c-0.541,0-1.072-0.073-1.583-0.212l17.429-17.429L50,66.956l8.653-10.096l17.429,17.429C75.572,74.427,75.041,74.5,74.5,74.5 L74.5,74.5z M80.625,68.375c0,0.541-0.073,1.072-0.211,1.583L62.652,52.195l17.96-20.953c0.008,0.127,0.014,0.255,0.014,0.383 L80.625,68.375L80.625,68.375z"></path>
                  </svg>
            </a></li>
            
         </ul>
      </div>
   </div>
</div><!-- end .footer -->

   <!-- Add jQuery and other scripts -->
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src=""><\/script>')</script>
<script src="/assets/js/dropcap.min.js"></script>
<script src="/assets/js/responsive-nav.min.js"></script>
<script src="/assets/js/scripts.js"></script>


</body>

</html>
