<!DOCTYPE html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7"><![endif]-->
<!--[if IE 7]><html class="no-js lt-ie9 lt-ie8" <![endif]-->
<!--[if IE 8]><html class="no-js lt-ie9" <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->

<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
       new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
       j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
       'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
       })(window,document,'script','dataLayer','GTM-WP54B9K');</script>
    <!-- End Google Tag Manager -->

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <title>[译] Linux网络栈监控和调优：发送数据 4</title>

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="/assets/img/favicon.ico" />

    <!-- Come and get me RSS readers -->
    <link rel="alternate" type="application/rss+xml" title="ArthurChiao's Blog" href="http://0.0.0.0:4000/feed.xml" />
    
    <!-- Stylesheet -->
    <link rel="stylesheet" href="/assets/css/style.css">
    <!--[if IE 8]><link rel="stylesheet" href="/assets/css/ie.css"><![endif]-->
    <link rel="canonical" href="http://0.0.0.0:4000/blog/tuning-stack-tx-zh-4/">

    <!-- Modernizr -->
    <script src="/assets/js/modernizr.custom.15390.js" type="text/javascript"></script>

    
</head>


<body>
  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WP54B9K"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->

    <div class="header">
     <div class="container">
         <h1 class="logo"><a href="/">ArthurChiao's Blog</a></h1>
         <nav class="nav-collapse">
             <ul class="noList">
                 
                   
                   
                   <li class="element first  ">
                     <a href="/index.html">Home</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/articles">Articles</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/articles-zh">Articles (中文)</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/categories">Categories</a>
                   </li> 
                 
                   
                   
                   <li class="element   last">
                     <a href="/about">About</a>
                   </li> 
                 
                 <!-- <li> <a href="https://github.com/arthurchiao/reading" target="_blank">Reading</a></li> -->
                 <!-- <li> <a href="https://github.com/arthurchiao/" target="_blank">GitHub</a></li> -->
             </ul>
         </nav>
     </div>
 </div><!-- end .header -->


   <div class="content">
      <div class="container">
         <div class="post">
  
  <h1 class="postTitle">[译] Linux网络栈监控和调优：发送数据 4</h1>
  <p class="meta">2018-12-17 | <span class="time">28</span> Minute Read</p>

  
  
  <h2 id="6-ip协议层">6 IP协议层</h2>

<p>UDP协议层通过调用<code class="highlighter-rouge">ip_send_skb</code>将skb交给IP协议层，所以我们从这里开始，探索一下IP
协议层。</p>

<h3 id="61-ip_send_skb">6.1 <code class="highlighter-rouge">ip_send_skb</code></h3>

<p><code class="highlighter-rouge">ip_send_skb</code>函数定义在
<a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/ip_output.c#L1367-L1380">net/ipv4/ip_output.c</a>
中，非常简短。它只是调用<code class="highlighter-rouge">ip_local_out</code>，如果调用失败，就更新相应的错误计数。让
我们来看看：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">ip_send_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

        <span class="n">err</span> <span class="o">=</span> <span class="n">ip_local_out</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="n">err</span> <span class="o">=</span> <span class="n">net_xmit_errno</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
                        <span class="n">IP_INC_STATS</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">IPSTATS_MIB_OUTDISCARDS</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">net_xmit_errno</code>函数将低层错误转换为IP和UDP协议层所能理解的错误。如果发生错误，
IP协议计数器<code class="highlighter-rouge">OutDiscards</code>会递增。稍后我们将看到读取哪些文件可以获取此统计信
息。现在，让我们继续，看看<code class="highlighter-rouge">ip_local_out</code>带我们去哪。</p>

<h3 id="62-ip_local_out-and-__ip_local_out">6.2 <code class="highlighter-rouge">ip_local_out</code> and <code class="highlighter-rouge">__ip_local_out</code></h3>

<p>幸运的是，<code class="highlighter-rouge">ip_local_out</code>和<code class="highlighter-rouge">__ip_local_out</code>都很简单。<code class="highlighter-rouge">ip_local_out</code>只需调用
<code class="highlighter-rouge">__ip_local_out</code>，如果返回值为1，则调用路由层<code class="highlighter-rouge">dst_output</code>发送数据包：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">ip_local_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

        <span class="n">err</span> <span class="o">=</span> <span class="n">__ip_local_out</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">err</span> <span class="o">=</span> <span class="n">dst_output</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>我们来看看<code class="highlighter-rouge">__ip_local_out</code>的代码：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">__ip_local_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">iph</span> <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

        <span class="n">iph</span><span class="o">-&gt;</span><span class="n">tot_len</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
        <span class="n">ip_send_check</span><span class="p">(</span><span class="n">iph</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">nf_hook</span><span class="p">(</span><span class="n">NFPROTO_IPV4</span><span class="p">,</span> <span class="n">NF_INET_LOCAL_OUT</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
                       <span class="n">skb_dst</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dst_output</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>可以看到，该函数首先做了两件重要的事情：</p>

<ol>
  <li>设置IP数据包的长度</li>
  <li>调用<code class="highlighter-rouge">ip_send_check</code>来计算要写入IP头的校验和。<code class="highlighter-rouge">ip_send_check</code>函数将进一步调用
名为<code class="highlighter-rouge">ip_fast_csum</code>的函数来计算校验和。在x86和x86_64体系结构上，此函数用汇编实
现，代码：<a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/include/asm/checksum_64.h#L40-L73">64位实现</a>
和<a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/include/asm/checksum_32.h#L63-L98">32位实现</a>
。</li>
</ol>

<p>接下来，IP协议层将通过调用<code class="highlighter-rouge">nf_hook</code>进入netfilter，其返回值将传递回<code class="highlighter-rouge">ip_local_out</code>
。 如果<code class="highlighter-rouge">nf_hook</code>返回1，则表示允许数据包通过，并且调用者应该自己发送数据包。这正
是我们在上面看到的情况：<code class="highlighter-rouge">ip_local_out</code>检查返回值1时，自己通过调用<code class="highlighter-rouge">dst_output</code>发
送数据包。</p>

<h3 id="63-netfilter-and-nf_hook">6.3 netfilter and nf_hook</h3>

<p>简洁起见，我决定跳过对netfilter，iptables和conntrack的深入研究。如果你想深入了解
netfilter的代码实现，可以从 <code class="highlighter-rouge">include/linux/netfilter.h</code><a href="https://github.com/torvalds/linux/blob/v3.13/include/linux/netfilter.h#L142-L147">这里
</a>
和 <code class="highlighter-rouge">net/netfilter/core.c</code><a href="https://github.com/torvalds/linux/blob/v3.13/net/netfilter/core.c#L168-L209">这里
</a>开
始。</p>

<p>简短版本是：<code class="highlighter-rouge">nf_hook</code>只是一个wrapper，它调用<code class="highlighter-rouge">nf_hook_thresh</code>，首先检查是否有为这
个<strong>协议族</strong>和<strong>hook类型</strong>（这里分别为<code class="highlighter-rouge">NFPROTO_IPV4</code>和<code class="highlighter-rouge">NF_INET_LOCAL_OUT</code>）安装
的过滤器，然后将返回到IP协议层，避免深入到netfilter或更下面，比如iptables和
conntrack。</p>

<p>请记住：如果你有非常多或者非常复杂的netfilter或iptables规则，那些规则将在触发
<code class="highlighter-rouge">sendmsg</code>系统调的用户进程的上下文中执行。如果对这个用户进程设置了CPU亲和性，相应
的CPU将花费系统时间（system time）处理出站（outbound）iptables规则。如果你在做性
能回归测试，那可能要考虑根据系统的负载，将相应的用户进程绑到到特定的CPU，或者是
减少netfilter/iptables规则的复杂度，以减少对性能测试的影响。</p>

<p>出于讨论目的，我们假设<code class="highlighter-rouge">nf_hook</code>返回1，表示调用者（在这种情况下是IP协议层）应该
自己发送数据包。</p>

<h3 id="64-目的路由缓存">6.4 目的（路由）缓存</h3>

<p>dst代码在Linux内核中实现<strong>协议无关</strong>的目标缓存。为了继续学习发送UDP数据报的流程
，我们需要了解dst条目是如何被设置的，首先来看dst条目和路由是如何生成的。 目标缓
存，路由和邻居子系统，任何一个都可以拿来单独详细的介绍。我们不深入细节，只是快速
地看一下它们是如何组合到一起的。</p>

<p>我们上面看到的代码调用了<code class="highlighter-rouge">dst_output(skb)</code>。 此函数只是查找关联到这个skb的dst条目
，然后调用<code class="highlighter-rouge">output</code>方法。代码如下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Output packet to network from transport.  */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dst_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">skb_dst</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">output</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>看起来很简单，但是<code class="highlighter-rouge">output</code>方法之前是如何关联到dst条目的？</p>

<p>首先很重要的一点，目标缓存条目是以多种不同方式添加的。到目前为止，我们已经在代码
中看到的一种方法是从<code class="highlighter-rouge">udp_sendmsg</code>调用
<a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/route.c#L2252-L2267">ip_route_output_flow</a>
。<code class="highlighter-rouge">ip_route_output_flow</code>函数调用
<a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/route.c#L1990-L2173">__ip_route_output_key</a>
，后者进而调用
<a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/route.c#L1868-L1988">__mkroute_output</a>
。 <code class="highlighter-rouge">__mkroute_output</code>函数创建路由和目标缓存条目。当它执行创建操作时，它会判断哪
个<code class="highlighter-rouge">output</code>方法适合此dst。大多数时候，这个函数是<code class="highlighter-rouge">ip_output</code>。</p>

<h3 id="65-ip_output">6.5 <code class="highlighter-rouge">ip_output</code></h3>

<p>在UDP IPv4情况下，上面的<code class="highlighter-rouge">output</code>方法指向的是<code class="highlighter-rouge">ip_output</code>。<code class="highlighter-rouge">ip_output</code>函数很简单：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">ip_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">skb_dst</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

        <span class="n">IP_UPD_PO_STATS</span><span class="p">(</span><span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">IPSTATS_MIB_OUT</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

        <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
        <span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">NF_HOOK_COND</span><span class="p">(</span><span class="n">NFPROTO_IPV4</span><span class="p">,</span> <span class="n">NF_INET_POST_ROUTING</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span>
                            <span class="n">ip_finish_output</span><span class="p">,</span>
                            <span class="o">!</span><span class="p">(</span><span class="n">IPCB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IPSKB_REROUTED</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>首先，更新<code class="highlighter-rouge">IPSTATS_MIB_OUT</code>统计计数。<code class="highlighter-rouge">IP_UPD_PO_STATS</code>宏将更新字节数和包数统计。
我们将在后面的部分中看到如何获取IP协议层统计信息以及它们各自的含义。接下来，设置
要发送此skb的设备，以及协议。</p>

<p>最后，通过调用<code class="highlighter-rouge">NF_HOOK_COND</code>将控制权交给netfilter。查看<code class="highlighter-rouge">NF_HOOK_COND</code>的函数原型
有助于更清晰地解释它如何工作。来自
<a href="https://github.com/torvalds/linux/blob/v3.13/include/linux/netfilter.h#L177-L188">include/linux/netfilter.h</a>
：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="n">NF_HOOK_COND</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">pf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hook</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
             <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
             <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">okfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">),</span> <span class="n">bool</span> <span class="n">cond</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">NF_HOOK_COND</code>通过检查传入的条件来工作。在这里条件是<code class="highlighter-rouge">!(IPCB(skb)-&gt;flags &amp;
IPSKB_REROUTED</code>。如果此条件为真，则skb将发送给netfilter。如果netfilter允许包通过
，<code class="highlighter-rouge">okfn</code>回调函数将被调用。在这里，<code class="highlighter-rouge">okfn</code>是<code class="highlighter-rouge">ip_finish_output</code>。</p>

<h3 id="66-ip_finish_output">6.6 <code class="highlighter-rouge">ip_finish_output</code></h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">ip_finish_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if defined(CONFIG_NETFILTER) &amp;&amp; defined(CONFIG_XFRM)
</span>        <span class="cm">/* Policy lookup after SNAT yielded a new policy */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">skb_dst</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">xfrm</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">IPCB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IPSKB_REROUTED</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">dst_output</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
        <span class="p">}</span>
<span class="cp">#endif
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">ip_skb_dst_mtu</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">skb_is_gso</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">ip_fragment</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ip_finish_output2</span><span class="p">);</span>
        <span class="k">else</span>
                <span class="k">return</span> <span class="n">ip_finish_output2</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果内核启用了netfilter和数据包转换（XFRM），则更新skb的标志并通过<code class="highlighter-rouge">dst_output</code>将
其发回。</p>

<p>更常见的两种情况是：</p>

<ol>
  <li>如果数据包的长度大于MTU并且分片不会offload到设备，则会调用<code class="highlighter-rouge">ip_fragment</code>在发送之前对数据包进行分片</li>
  <li>否则，数据包将直接发送到ip_finish_output2</li>
</ol>

<p>在继续我们的内核之前，让我们简单地谈谈Path MTU Discovery。</p>

<h4 id="path-mtu-discovery">Path MTU Discovery</h4>

<p>Linux提供了一个功能，我迄今为止一直避免提及：<a href="https://en.wikipedia.org/wiki/Path_MTU_Discovery">路径MTU发现
</a>。此功能允许内核自动确定
路由的最大传输单元（
<a href="https://en.wikipedia.org/wiki/Maximum_transmission_unit">MTU</a>
）。发送小于或等于该路由的MTU的包意味着可以避免IP分片，这是推荐设置，因为数
据包分片会消耗系统资源，而避免分片看起来很容易：只需发送足够小的不需要分片的数据
包。</p>

<p>你可以在应用程序中通过调用<code class="highlighter-rouge">setsockopt</code>带<code class="highlighter-rouge">SOL_IP</code>和<code class="highlighter-rouge">IP_MTU_DISCOVER</code>选项，在
packet级别来调整路径MTU发现设置，相应的合法值参考IP协议的<a href="http://man7.org/linux/man-pages/man7/ip.7.html">man
page</a>。例如，你可能想设置的值是
：<code class="highlighter-rouge">IP_PMTUDISC_DO</code>，表示“始终执行路径MTU发现”。更高级的网络应用程序或诊断工具可
能选择自己实现<a href="https://www.ietf.org/rfc/rfc4821.txt">RFC 4821</a>，以在应用程序启动
时针对特定的路由做PMTU。在这种情况下，你可以使用<code class="highlighter-rouge">IP_PMTUDISC_PROBE</code>选项告诉内核
设置“Do not Fragment”位，这就会允许你发送大于PMTU的数据。</p>

<p>应用程序可以通过调用<code class="highlighter-rouge">getsockopt</code>带<code class="highlighter-rouge">SOL_IP</code>和<code class="highlighter-rouge">IP_MTU</code>选项来查看当前PMTU。可以使
用它指导应用程序在发送之前，构造UDP数据报的大小。</p>

<p>如果已启用PMTU发现，则发送大于PMTU的UDP数据将导致应用程序收到<code class="highlighter-rouge">EMSGSIZE</code>错误。
这种情况下，应用程序只能减小packet大小重试。</p>

<p>强烈建议启用PTMU发现，因此我将不再详细描述IP分片的代码。当我们查看IP协议层统计信
息时，我将解释所有统计信息，包括与分片相关的统计信息。其中许多计数都在
<code class="highlighter-rouge">ip_fragment</code>中更新的。不管分片与否，代码最后都会调到<code class="highlighter-rouge">ip_finish_output2</code>，所以让
我们继续。</p>

<h3 id="67-ip_finish_output2">6.7 <code class="highlighter-rouge">ip_finish_output2</code></h3>

<p>IP分片后调用<code class="highlighter-rouge">ip_finish_output2</code>，另外<code class="highlighter-rouge">ip_finish_output</code>也会直接调用它。这个函数
在将包发送到邻居缓存之前处理各种统计计数器。让我们看看它是如何工作的：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ip_finish_output2</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>

                <span class="cm">/* variable declarations */</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">rt_type</span> <span class="o">==</span> <span class="n">RTN_MULTICAST</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">IP_UPD_PO_STATS</span><span class="p">(</span><span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">IPSTATS_MIB_OUTMCAST</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">rt_type</span> <span class="o">==</span> <span class="n">RTN_BROADCAST</span><span class="p">)</span>
                <span class="n">IP_UPD_PO_STATS</span><span class="p">(</span><span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">IPSTATS_MIB_OUTBCAST</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

        <span class="cm">/* Be paranoid, rather than too clever. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb_headroom</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">hh_len</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">header_ops</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb2</span><span class="p">;</span>

                <span class="n">skb2</span> <span class="o">=</span> <span class="n">skb_realloc_headroom</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">LL_RESERVED_SPACE</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">skb2</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
                        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">)</span>
                        <span class="n">skb_set_owner_w</span><span class="p">(</span><span class="n">skb2</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">);</span>
                <span class="n">consume_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
                <span class="n">skb</span> <span class="o">=</span> <span class="n">skb2</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>如果与此数据包关联的路由是多播类型，则使用<code class="highlighter-rouge">IP_UPD_PO_STATS</code>宏来增加
<code class="highlighter-rouge">OutMcastPkts</code>和<code class="highlighter-rouge">OutMcastOctets</code>计数。如果广播路由，则会增加<code class="highlighter-rouge">OutBcastPkts</code>和
<code class="highlighter-rouge">OutBcastOctets</code>计数。</p>

<p>接下来，确保skb结构有足够的空间容纳需要添加的任何链路层头。如果空间不够，则调用
<code class="highlighter-rouge">skb_realloc_headroom</code>分配额外的空间，并且新的skb的费用（charge）记在相关的
socket上。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="n">rcu_read_lock_bh</span><span class="p">();</span>
        <span class="n">nexthop</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">u32</span><span class="p">)</span> <span class="n">rt_nexthop</span><span class="p">(</span><span class="n">rt</span><span class="p">,</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">);</span>
        <span class="n">neigh</span> <span class="o">=</span> <span class="n">__ipv4_neigh_lookup_noref</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">nexthop</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">neigh</span><span class="p">))</span>
                <span class="n">neigh</span> <span class="o">=</span> <span class="n">__neigh_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arp_tbl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nexthop</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div></div>

<p>继续，查询路由层找到下一跳，再根据下一跳信息查找邻居缓存。如果未找到，则
调用<code class="highlighter-rouge">__neigh_create</code>创建一个邻居。例如，第一次将数据发送到另一
台主机的时候，就是这种情况。请注意，创建邻居缓存的时候带了<code class="highlighter-rouge">arp_tbl</code>（
<a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/arp.c#L160-L187">net/ipv4/arp.c</a>
中定义）参数。其他系统（如IPv6或
<a href="https://en.wikipedia.org/wiki/DECnet">DECnet</a>）维护自己的ARP表，并将不同的变量
传给<code class="highlighter-rouge">__neigh_create</code>。 这篇文章的目的并不是要详细介绍邻居缓存，但注意如果创建，
会导致缓存表增大。本文后面会介绍有关邻居缓存的更多详细信息。 邻居缓存会导出一组
统计信息，以便可以衡量这种增长。有关详细信息，请参阅下面的监控部分。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">neigh</span><span class="p">))</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">dst_neigh_output</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">neigh</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

                <span class="n">rcu_read_unlock_bh</span><span class="p">();</span>
                <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">rcu_read_unlock_bh</span><span class="p">();</span>

        <span class="n">net_dbg_ratelimited</span><span class="p">(</span><span class="s">"%s: No header cache and no neighbour!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                            <span class="n">__func__</span><span class="p">);</span>
        <span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>最后，如果创建邻居缓存成功，则调用<code class="highlighter-rouge">dst_neigh_output</code>继续传递skb；否则，释放skb并返
回<code class="highlighter-rouge">EINVAL</code>，这会向上传递，导致<code class="highlighter-rouge">OutDiscards</code>在<code class="highlighter-rouge">ip_send_skb</code>中递增。让我们继续在
<code class="highlighter-rouge">dst_neigh_output</code>中接近Linux内核的netdevice子系统。</p>

<h3 id="68-dst_neigh_output">6.8 <code class="highlighter-rouge">dst_neigh_output</code></h3>

<p><code class="highlighter-rouge">dst_neigh_output</code>函数做了两件重要的事情。首先，回想一下之前在本文中我
们看到，如果用户调用<code class="highlighter-rouge">sendmsg</code>并通过辅助消息指定<code class="highlighter-rouge">MSG_CONFIRM</code>参数，则会设置一个标
志位以指示目标高速缓存条目仍然有效且不应进行垃圾回收。这个检查就是在这个函数里面
做的，并且邻居上的<code class="highlighter-rouge">confirm</code>字段设置为当前的jiffies计数。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dst_neigh_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span>
                                   <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">const</span> <span class="k">struct</span> <span class="n">hh_cache</span> <span class="o">*</span><span class="n">hh</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">pending_confirm</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

                <span class="n">dst</span><span class="o">-&gt;</span><span class="n">pending_confirm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="cm">/* avoid dirtying neighbour */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">confirmed</span> <span class="o">!=</span> <span class="n">now</span><span class="p">)</span>
                        <span class="n">n</span><span class="o">-&gt;</span><span class="n">confirmed</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>其次，检查邻居的状态并调用适当的<code class="highlighter-rouge">output</code>函数。让我们看一下这些条件，并尝试了解发
生了什么：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="n">hh</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">hh</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">nud_state</span> <span class="o">&amp;</span> <span class="n">NUD_CONNECTED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">hh</span><span class="o">-&gt;</span><span class="n">hh_len</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">neigh_hh_output</span><span class="p">(</span><span class="n">hh</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
        <span class="k">else</span>
                <span class="k">return</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">output</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>邻居被认为是<code class="highlighter-rouge">NUD_CONNECTED</code>，如果它满足以下一个或多个条件：</p>

<ol>
  <li><code class="highlighter-rouge">NUD_PERMANENT</code>：静态路由</li>
  <li><code class="highlighter-rouge">NUD_NOARP</code>：不需要ARP请求（例如，目标是多播或广播地址，或环回设备）</li>
  <li><code class="highlighter-rouge">NUD_REACHABLE</code>：邻居是“可达的。”只要<a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/arp.c#L905-L923">成功处理了</a>ARP请求，目标就会被标记为可达</li>
</ol>

<p>进一步，如果“硬件头”（hh）被缓存（之前已经发送过数据，并生成了缓存），将调
用<code class="highlighter-rouge">neigh_hh_output</code>。</p>

<p>否则，调用<code class="highlighter-rouge">output</code>函数。</p>

<p>以上两种情况，最后都会到<code class="highlighter-rouge">dev_queue_xmit</code>，它将skb发送给Linux网络设备子系统，在它
进入设备驱动程序层之前将对其进行更多处理。让我们沿着<code class="highlighter-rouge">neigh_hh_output</code>和
<code class="highlighter-rouge">n-&gt;output</code>代码继续向下，直到达到<code class="highlighter-rouge">dev_queue_xmit</code>。</p>

<h3 id="69-neigh_hh_output">6.9 <code class="highlighter-rouge">neigh_hh_output</code></h3>

<p>如果目标是<code class="highlighter-rouge">NUD_CONNECTED</code>并且硬件头已被缓存，则将调用<code class="highlighter-rouge">neigh_hh_output</code>，在将skb移交
给<code class="highlighter-rouge">dev_queue_xmit</code>之前执行一小部分处理。 我们来看看
<a href="https://github.com/torvalds/linux/blob/v3.13/include/net/neighbour.h#L336-L356">include/net/neighbour.h</a>
：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">neigh_hh_output</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">hh_cache</span> <span class="o">*</span><span class="n">hh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seq</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">hh_len</span><span class="p">;</span>

        <span class="k">do</span> <span class="p">{</span>
                <span class="n">seq</span> <span class="o">=</span> <span class="n">read_seqbegin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hh</span><span class="o">-&gt;</span><span class="n">hh_lock</span><span class="p">);</span>
                <span class="n">hh_len</span> <span class="o">=</span> <span class="n">hh</span><span class="o">-&gt;</span><span class="n">hh_len</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">hh_len</span> <span class="o">&lt;=</span> <span class="n">HH_DATA_MOD</span><span class="p">))</span> <span class="p">{</span>
                        <span class="cm">/* this is inlined by gcc */</span>
                        <span class="n">memcpy</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">-</span> <span class="n">HH_DATA_MOD</span><span class="p">,</span> <span class="n">hh</span><span class="o">-&gt;</span><span class="n">hh_data</span><span class="p">,</span> <span class="n">HH_DATA_MOD</span><span class="p">);</span>
                 <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                         <span class="kt">int</span> <span class="n">hh_alen</span> <span class="o">=</span> <span class="n">HH_DATA_ALIGN</span><span class="p">(</span><span class="n">hh_len</span><span class="p">);</span>

                         <span class="n">memcpy</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">-</span> <span class="n">hh_alen</span><span class="p">,</span> <span class="n">hh</span><span class="o">-&gt;</span><span class="n">hh_data</span><span class="p">,</span> <span class="n">hh_alen</span><span class="p">);</span>
                 <span class="p">}</span>
         <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">read_seqretry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hh</span><span class="o">-&gt;</span><span class="n">hh_lock</span><span class="p">,</span> <span class="n">seq</span><span class="p">));</span>

         <span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">hh_len</span><span class="p">);</span>
         <span class="k">return</span> <span class="n">dev_queue_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这个函数理解有点难，部分原因是<a href="https://en.wikipedia.org/wiki/Seqlock">seqlock</a>这
个东西，它用于在缓存的硬件头上做读/写锁。可以将上面的<code class="highlighter-rouge">do {} while ()</code>循环想象成
一个简单的重试机制，它将尝试在循环中执行，直到成功。</p>

<p>循环里处理硬件头的长度对齐。这是必需的，因为某些硬件头（如<a href="https://github.com/torvalds/linux/blob/v3.13/include/linux/ieee80211.h#L210-L218">IEEE
802.11</a>
头）大于<code class="highlighter-rouge">HH_DATA_MOD</code>（16字节）。</p>

<p>将头数据复制到skb后，<code class="highlighter-rouge">skb_push</code>将更新skb内指向数据缓冲区的指针。最后调用
<code class="highlighter-rouge">dev_queue_xmit</code>将skb传递给Linux网络设备子系统。</p>

<h3 id="610-n-output">6.10 <code class="highlighter-rouge">n-&gt;output</code></h3>

<p>如果目标不是<code class="highlighter-rouge">NUD_CONNECTED</code>或硬件头尚未缓存，则代码沿<code class="highlighter-rouge">n-&gt;output</code>路径向下。
neigbour结构上的<code class="highlighter-rouge">output</code>指针指向哪个函数？这得看情况。要了解这是如何设置的，我们
需要更多地了解邻居缓存的工作原理。</p>

<p><code class="highlighter-rouge">struct
neighbour</code>包含几个重要字段：我们在上面看到的<code class="highlighter-rouge">nud_state</code>字段，<code class="highlighter-rouge">output</code>函数和<code class="highlighter-rouge">ops</code>
结构。回想一下，我们之前看到如果在缓存中找不到现有条目，会从<code class="highlighter-rouge">ip_finish_output2</code>
调用<code class="highlighter-rouge">__neigh_create</code>创建一个。当调用<code class="highlighter-rouge">__neigh_creaet</code>时，将分配邻居，其<code class="highlighter-rouge">output</code>函
数<a href="https://github.com/torvalds/linux/blob/v3.13/net/core/neighbour.c#L294">最初</a>
设置为<code class="highlighter-rouge">neigh_blackhole</code>。随着<code class="highlighter-rouge">__neigh_create</code>代码的进行，它将根据邻居的状态修改
<code class="highlighter-rouge">output</code>值以指向适当的发送方法。</p>

<p>例如，当代码确定是“已连接的”邻居时，<code class="highlighter-rouge">neigh_connect</code>会将<code class="highlighter-rouge">output</code>设置为
<code class="highlighter-rouge">neigh-&gt;ops-&gt;connected_output</code>。或者，当代码怀疑邻居可能已关闭时，<code class="highlighter-rouge">neigh_suspect</code>
会将<code class="highlighter-rouge">output</code>设置为<code class="highlighter-rouge">neigh-&gt;ops-&gt;output</code>（例如，如果已超过
<code class="highlighter-rouge">/proc/sys/net/ipv4/neigh/default/delay_first_probe_time</code>自发送探测以来的
<code class="highlighter-rouge">delay_first_probe_time</code>秒）。</p>

<p>换句话说：<code class="highlighter-rouge">neigh-&gt;output</code>会被设置为<code class="highlighter-rouge">neigh-&gt;ops_connected_output</code>或
<code class="highlighter-rouge">neigh-&gt;ops-&gt;output</code>，具体取决于邻居的状态。<code class="highlighter-rouge">neigh-&gt;ops</code>来自哪里？</p>

<p>分配邻居后，调用<code class="highlighter-rouge">arp_constructor</code>（
<a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/arp.c#L220-L313">net/ipv4/arp.c</a>
）来设置<code class="highlighter-rouge">struct neighbor</code>的某些字段。特别是，此函数会检查与此邻居关联的设备是否
导出来一个<code class="highlighter-rouge">struct header_ops</code>实例（<a href="https://github.com/torvalds/linux/blob/v3.13/net/ethernet/eth.c#L342-L348">以太网设备是这样做的
</a>），
该结构体有一个<code class="highlighter-rouge">cache</code>方法。</p>

<p><code class="highlighter-rouge">neigh-&gt;ops</code>设置为
<a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/arp.c#L138-L144">net/ipv4/arp</a>
中定义的以下实例：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">neigh_ops</span> <span class="n">arp_hh_ops</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">family</span> <span class="o">=</span>               <span class="n">AF_INET</span><span class="p">,</span>
        <span class="p">.</span><span class="n">solicit</span> <span class="o">=</span>              <span class="n">arp_solicit</span><span class="p">,</span>
        <span class="p">.</span><span class="n">error_report</span> <span class="o">=</span>         <span class="n">arp_error_report</span><span class="p">,</span>
        <span class="p">.</span><span class="n">output</span> <span class="o">=</span>               <span class="n">neigh_resolve_output</span><span class="p">,</span>
        <span class="p">.</span><span class="n">connected_output</span> <span class="o">=</span>     <span class="n">neigh_resolve_output</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<p>所以，不管neighbor是不是“已连接的”，或者邻居缓存代码是否怀疑连接“已关闭”，
<code class="highlighter-rouge">neigh_resolve_output</code>最终都会被赋给<code class="highlighter-rouge">neigh-&gt;output</code>。当执行到<code class="highlighter-rouge">n-&gt;output</code>时就会调
用它。</p>

<h4 id="neigh_resolve_output">neigh_resolve_output</h4>

<p>此函数的目的是解析未连接的邻居，或已连接但没有缓存硬件头的邻居。我们来看看这个
函数是如何工作的：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Slow and careful. */</span>

<span class="kt">int</span> <span class="nf">neigh_resolve_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="n">neigh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="n">skb_dst</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dst</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">discard</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">neigh_event_send</span><span class="p">(</span><span class="n">neigh</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
                <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">neigh</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
                <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seq</span><span class="p">;</span>
</code></pre></div></div>

<p>代码首先进行一些基本检查，然后调用<code class="highlighter-rouge">neigh_event_send</code>。 <code class="highlighter-rouge">neigh_event_send</code>函数是
<code class="highlighter-rouge">__neigh_event_send</code>的简单封装，后者干大部分脏话累活。可以在
<a href="https://github.com/torvalds/linux/blob/v3.13/net/core/neighbour.c#L964-L1028">net/core/neighbour.c</a>
中读<code class="highlighter-rouge">__neigh_event_send</code>的源代码，从大的层面看，三种情况：</p>

<ol>
  <li><code class="highlighter-rouge">NUD_NONE</code>状态（默认状态）的邻居：假设
<code class="highlighter-rouge">/proc/sys/net/ipv4/neigh/default/app_solicit</code>和
<code class="highlighter-rouge">/proc/sys/net/ipv4/neigh/default/mcast_solicit</code>配置允许发送探测（如果不是，
则将状态标记为<code class="highlighter-rouge">NUD_FAILED</code>），将导致立即发送ARP请求。邻居状态将更新为
<code class="highlighter-rouge">NUD_INCOMPLETE</code></li>
  <li><code class="highlighter-rouge">NUD_STALE</code>状态的邻居：将更新为<code class="highlighter-rouge">NUD_DELAYED</code>并且将设置计时器以稍后探测它们（
稍后是现在的时间+<code class="highlighter-rouge">/proc/sys/net/ipv4/neigh/default/delay_first_probe_time</code>秒
）</li>
  <li>检查<code class="highlighter-rouge">NUD_INCOMPLETE</code>状态的邻居（包括上面第一种情形），以确保未解析邻居的排
队packet的数量小于等于<code class="highlighter-rouge">/proc/sys/net/ipv4/neigh/default/unres_qlen</code>。如果超过
，则数据包会出列并丢弃，直到小于等于proc中的值。 统计信息中有个计数器会因此
更新</li>
</ol>

<p>如果需要ARP探测，ARP将立即被发送。<code class="highlighter-rouge">__neigh_event_send</code>将返回0，表示邻居被视为“已
连接”或“已延迟”，否则返回1。返回值0允许<code class="highlighter-rouge">neigh_resolve_output</code>继续：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">header_ops</span><span class="o">-&gt;</span><span class="n">cache</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">hh</span><span class="p">.</span><span class="n">hh_len</span><span class="p">)</span>
                        <span class="n">neigh_hh_init</span><span class="p">(</span><span class="n">neigh</span><span class="p">,</span> <span class="n">dst</span><span class="p">);</span>
</code></pre></div></div>

<p>如果邻居关联的设备的协议实现（在我们的例子中是以太网）支持缓存硬件头，并且当前没
有缓存，<code class="highlighter-rouge">neigh_hh_init</code>将缓存它。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                <span class="k">do</span> <span class="p">{</span>
                        <span class="n">__skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb_network_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
                        <span class="n">seq</span> <span class="o">=</span> <span class="n">read_seqbegin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">ha_lock</span><span class="p">);</span>
                        <span class="n">err</span> <span class="o">=</span> <span class="n">dev_hard_header</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">),</span>
                                              <span class="n">neigh</span><span class="o">-&gt;</span><span class="n">ha</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">read_seqretry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">ha_lock</span><span class="p">,</span> <span class="n">seq</span><span class="p">));</span>
</code></pre></div></div>

<p>接下来，seqlock锁控制对邻居的硬件地址字段（<code class="highlighter-rouge">neigh-&gt;ha</code>）的访问。
<code class="highlighter-rouge">dev_hard_header</code>为skb创建以太网头时将读取该字段。</p>

<p>之后是错误检查：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="n">rc</span> <span class="o">=</span> <span class="n">dev_queue_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
                <span class="k">else</span>
                        <span class="k">goto</span> <span class="n">out_kfree_skb</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>如果以太网头写入成功，将调用<code class="highlighter-rouge">dev_queue_xmit</code>将skb传递给Linux网络设备子系统进行发
送。如果出现错误，goto将删除skb，设置并返回错误码：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">out:</span>
        <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="n">discard</span><span class="o">:</span>
        <span class="n">neigh_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"%s: dst=%p neigh=%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">neigh</span><span class="p">);</span>
<span class="n">out_kfree_skb</span><span class="o">:</span>
        <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
        <span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">neigh_resolve_output</span><span class="p">);</span>
</code></pre></div></div>

<p>在我们进入Linux网络设备子系统之前，让我们看看一些用于监控和转换IP协议层的文件。</p>

<h3 id="611-监控-ip层">6.11 监控: IP层</h3>

<h4 id="procnetsnmp">/proc/net/snmp</h4>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cat</span> /proc/net/snmp
Ip: Forwarding DefaultTTL InReceives InHdrErrors InAddrErrors ForwDatagrams InUnknownProtos InDiscards InDelivers OutRequests OutDiscards OutNoRoutes ReasmTimeout ReasmReqds ReasmOKs ReasmFails FragOKs FragFails FragCreates
Ip: 1 64 25922988125 0 0 15771700 0 0 25898327616 22789396404 12987882 51 1 10129840 2196520 1 0 0 0
...
</code></pre></div></div>

<p>这个文件包扩多种协议的统计，IP层的在最前面，每一列代表什么有说明。</p>

<p>前面我们已经看到IP协议层有一些地方会更新计数器。这些计数器的类型是C枚举类型，定
义在<a href="https://github.com/torvalds/linux/blob/v3.13/include/uapi/linux/snmp.h#L10-L59">include/uapi/linux/snmp.h</a>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span>
<span class="p">{</span>
  <span class="n">IPSTATS_MIB_NUM</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="cm">/* frequently written fields in fast path, kept in same cache line */</span>
  <span class="n">IPSTATS_MIB_INPKTS</span><span class="p">,</span>     <span class="cm">/* InReceives */</span>
  <span class="n">IPSTATS_MIB_INOCTETS</span><span class="p">,</span>     <span class="cm">/* InOctets */</span>
  <span class="n">IPSTATS_MIB_INDELIVERS</span><span class="p">,</span>     <span class="cm">/* InDelivers */</span>
  <span class="n">IPSTATS_MIB_OUTFORWDATAGRAMS</span><span class="p">,</span>   <span class="cm">/* OutForwDatagrams */</span>
  <span class="n">IPSTATS_MIB_OUTPKTS</span><span class="p">,</span>      <span class="cm">/* OutRequests */</span>
  <span class="n">IPSTATS_MIB_OUTOCTETS</span><span class="p">,</span>      <span class="cm">/* OutOctets */</span>

  <span class="cm">/* ... */</span>
</code></pre></div></div>

<p>一些有趣的统计：</p>

<ul>
  <li><code class="highlighter-rouge">OutRequests</code>: Incremented each time an IP packet is attempted to be sent. It appears that this is incremented for every send, successful or not.</li>
  <li><code class="highlighter-rouge">OutDiscards</code>: Incremented each time an IP packet is discarded. This can happen if appending data to the skb (for corked sockets) fails, or if the layers below IP return an error.</li>
  <li><code class="highlighter-rouge">OutNoRoute</code>: Incremented in several places, for example in the UDP protocol layer (udp_sendmsg) if no route can be generated for a given destination. Also incremented when an application calls “connect” on a UDP socket but no route can be found.</li>
  <li><code class="highlighter-rouge">FragOKs</code>: Incremented once per packet that is fragmented. For example, a packet split into 3 fragments will cause this counter to be incremented once.</li>
  <li><code class="highlighter-rouge">FragCreates</code>: Incremented once per fragment that is created. For example, a packet split into 3 fragments will cause this counter to be incremented thrice.</li>
  <li><code class="highlighter-rouge">FragFails</code>: Incremented if fragmentation was attempted, but is not permitted (because the “Don’t Fragment” bit is set). Also incremented if outputting the fragment fails.</li>
</ul>

<p>其他（接收数据部分）的统计可以见本文的姊妹篇：<a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#monitoring-ip-protocol-layer-statistics">原文
</a>
，<a href="">中文翻译版</a>。</p>

<h4 id="procnetnetstat">/proc/net/netstat</h4>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cat</span> /proc/net/netstat | <span class="nb">grep </span>IpExt
IpExt: InNoRoutes InTruncatedPkts InMcastPkts OutMcastPkts InBcastPkts OutBcastPkts InOctets OutOctets InMcastOctets OutMcastOctets InBcastOctets OutBcastOctets InCsumErrors InNoECTPkts InECT0Pktsu InCEPkts
IpExt: 0 0 0 0 277959 0 14568040307695 32991309088496 0 0 58649349 0 0 0 0 0
</code></pre></div></div>

<p>格式与前面的类似，除了每列的名称都有<code class="highlighter-rouge">IpExt</code>前缀之外。</p>

<p>一些有趣的统计：</p>

<ul>
  <li><code class="highlighter-rouge">OutMcastPkts</code>: Incremented each time a packet destined for a multicast address is sent.</li>
  <li><code class="highlighter-rouge">OutBcastPkts</code>: Incremented each time a packet destined for a broadcast address is sent.</li>
  <li><code class="highlighter-rouge">OutOctects</code>: The number of packet bytes output.</li>
  <li><code class="highlighter-rouge">OutMcastOctets</code>: The number of multicast packet bytes output.</li>
  <li><code class="highlighter-rouge">OutBcastOctets</code>: The number of broadcast packet bytes output.</li>
</ul>

<p>其他（接收数据部分）的统计可以见本文的姊妹篇：<a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#monitoring-ip-protocol-layer-statistics">原文
</a>
，<a href="">中文翻译版</a>。</p>

<p>注意这些计数分别在IP层的不同地方被更新。由于代码一直在更新，重复计数或者计数错误
的bug可能会引入。如果这些计数对你非常重要，强烈建议你阅读内核的相应源码，确定它
们是在哪里被更新的，以及更新的对不对，是不是有bug。</p>


  <!-- POST NAVIGATION -->
  <div class="postNav clearfix">
     
      <a class="prev" href="/blog/tuning-stack-tx-zh-3/"><span>&laquo;&nbsp;[译] Linux网络栈监控和调优：发送数据 3</span>
      
    </a>
      
      
      <a class="next" href="/blog/tuning-stack-tx-zh-5/"><span>[译] Linux网络栈监控和调优：发送数据 5&nbsp;&raquo;</span>
       
      </a>
     
  </div>
</div>


         

      </div>
   </div><!-- end .content -->

   <div class="footer">
   <div class="container">
      <p class="copy">&copy; 2016-2019
      <a href="https://arthurchiao.github.io">Arthur Chiao</a>, Powered by
      <a href="http://jekyllrb.com">Jekyll </a>, Theme originated from
      <a href="https://github.com/brianmaierjr/long-haul"> Long Haul.</a>

      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
      <span id="busuanzi_container_site_pv"> Site visits:
          <span id="busuanzi_value_site_pv"></span>, powered by<a href="http://busuanzi.ibruce.info/"> busuanzi</a>
      </span>

      </p>

      <div class="footer-links"> 
         <ul class="noList"> 
            
            <li><a href="https://www.facebook.com/profile.php?id=100014334455077">
                  <svg id="facebook-square" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M82.667,1H17.335C8.351,1,1,8.351,1,17.336v65.329c0,8.99,7.351,16.335,16.334,16.335h65.332 C91.652,99.001,99,91.655,99,82.665V17.337C99,8.353,91.652,1.001,82.667,1L82.667,1z M84.318,50H68.375v42.875H50V50h-8.855V35.973 H50v-9.11c0-12.378,5.339-19.739,19.894-19.739h16.772V22.3H72.967c-4.066-0.007-4.57,2.12-4.57,6.078l-0.023,7.594H86.75 l-2.431,14.027V50z"></path>
                  </svg>
            </a></li>
            
            
            <li><a href="https://linkedin.com/in/yanan-zhao-7691317b?trk=hp-identity-photo">
                  <svg id="linkedin" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M99.001,19.428c-3.606,1.608-7.48,2.695-11.547,3.184c4.15-2.503,7.338-6.466,8.841-11.189 c-3.885,2.318-8.187,4-12.768,4.908c-3.667-3.931-8.893-6.387-14.676-6.387c-11.104,0-20.107,9.054-20.107,20.223 c0,1.585,0.177,3.128,0.52,4.609c-16.71-0.845-31.525-8.895-41.442-21.131C6.092,16.633,5.1,20.107,5.1,23.813 c0,7.017,3.55,13.208,8.945,16.834c-3.296-0.104-6.397-1.014-9.106-2.529c-0.002,0.085-0.002,0.17-0.002,0.255 c0,9.799,6.931,17.972,16.129,19.831c-1.688,0.463-3.463,0.71-5.297,0.71c-1.296,0-2.555-0.127-3.783-0.363 c2.559,8.034,9.984,13.882,18.782,14.045c-6.881,5.424-15.551,8.657-24.971,8.657c-1.623,0-3.223-0.096-4.796-0.282 c8.898,5.738,19.467,9.087,30.82,9.087c36.982,0,57.206-30.817,57.206-57.543c0-0.877-0.02-1.748-0.059-2.617 C92.896,27.045,96.305,23.482,99.001,19.428z"></path>
                  </svg>
            </a></li>
            
            
            <li><a href="https://github.com/ArthurChiao">
                  <svg id="github" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M50,1C22.938,1,1,22.938,1,50s21.938,49,49,49s49-21.938,49-49S77.062,1,50,1z M79.099,79.099 c-3.782,3.782-8.184,6.75-13.083,8.823c-1.245,0.526-2.509,0.989-3.79,1.387v-7.344c0-3.86-1.324-6.699-3.972-8.517 c1.659-0.16,3.182-0.383,4.57-0.67c1.388-0.287,2.855-0.702,4.402-1.245c1.547-0.543,2.935-1.189,4.163-1.938 c1.228-0.75,2.409-1.723,3.541-2.919s2.082-2.552,2.847-4.067s1.372-3.334,1.818-5.455c0.446-2.121,0.67-4.458,0.67-7.01 c0-4.945-1.611-9.155-4.833-12.633c1.467-3.828,1.308-7.991-0.478-12.489l-1.197-0.143c-0.829-0.096-2.321,0.255-4.474,1.053 c-2.153,0.798-4.57,2.105-7.249,3.924c-3.797-1.053-7.736-1.579-11.82-1.579c-4.115,0-8.039,0.526-11.772,1.579 c-1.69-1.149-3.294-2.097-4.809-2.847c-1.515-0.75-2.727-1.26-3.637-1.532c-0.909-0.271-1.754-0.439-2.536-0.503 c-0.782-0.064-1.284-0.079-1.507-0.048c-0.223,0.031-0.383,0.064-0.478,0.096c-1.787,4.53-1.946,8.694-0.478,12.489 c-3.222,3.477-4.833,7.688-4.833,12.633c0,2.552,0.223,4.889,0.67,7.01c0.447,2.121,1.053,3.94,1.818,5.455 c0.765,1.515,1.715,2.871,2.847,4.067s2.313,2.169,3.541,2.919c1.228,0.751,2.616,1.396,4.163,1.938 c1.547,0.543,3.014,0.957,4.402,1.245c1.388,0.287,2.911,0.511,4.57,0.67c-2.616,1.787-3.924,4.626-3.924,8.517v7.487 c-1.445-0.43-2.869-0.938-4.268-1.53c-4.899-2.073-9.301-5.041-13.083-8.823c-3.782-3.782-6.75-8.184-8.823-13.083 C9.934,60.948,8.847,55.56,8.847,50s1.087-10.948,3.231-16.016c2.073-4.899,5.041-9.301,8.823-13.083s8.184-6.75,13.083-8.823 C39.052,9.934,44.44,8.847,50,8.847s10.948,1.087,16.016,3.231c4.9,2.073,9.301,5.041,13.083,8.823 c3.782,3.782,6.75,8.184,8.823,13.083c2.143,5.069,3.23,10.457,3.23,16.016s-1.087,10.948-3.231,16.016 C85.848,70.915,82.88,75.317,79.099,79.099L79.099,79.099z"></path>
                  </svg>
            </a></li>
             
            
            <li><a href="mailto:arthurchiao@hotmail.com">
                  <svg id="mail" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M50,1C22.938,1,1,22.938,1,50s21.938,49,49,49s49-21.938,49-49S77.062,1,50,1z M25.5,25.5h49 c0.874,0,1.723,0.188,2.502,0.542L50,57.544L22.998,26.041C23.777,25.687,24.626,25.499,25.5,25.5L25.5,25.5z M19.375,68.375v-36.75 c0-0.128,0.005-0.256,0.014-0.383l17.96,20.953L19.587,69.958C19.448,69.447,19.376,68.916,19.375,68.375L19.375,68.375z M74.5,74.5 h-49c-0.541,0-1.072-0.073-1.583-0.212l17.429-17.429L50,66.956l8.653-10.096l17.429,17.429C75.572,74.427,75.041,74.5,74.5,74.5 L74.5,74.5z M80.625,68.375c0,0.541-0.073,1.072-0.211,1.583L62.652,52.195l17.96-20.953c0.008,0.127,0.014,0.255,0.014,0.383 L80.625,68.375L80.625,68.375z"></path>
                  </svg>
            </a></li>
            
         </ul>
      </div>
   </div>
</div><!-- end .footer -->

   <!-- Add jQuery and other scripts -->
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src=""><\/script>')</script>
<script src="/assets/js/dropcap.min.js"></script>
<script src="/assets/js/responsive-nav.min.js"></script>
<script src="/assets/js/scripts.js"></script>


</body>

</html>
