<!DOCTYPE html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7"><![endif]-->
<!--[if IE 7]><html class="no-js lt-ie9 lt-ie8" <![endif]-->
<!--[if IE 8]><html class="no-js lt-ie9" <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->

<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
       new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
       j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
       'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
       })(window,document,'script','dataLayer','GTM-WP54B9K');</script>
    <!-- End Google Tag Manager -->

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <title>[译] 如何基于 Cilium 和 eBPF 打造可感知微服务的 Linux</title>

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="/assets/img/favicon.ico" />

    <!-- Come and get me RSS readers -->
    <link rel="alternate" type="application/rss+xml" title="ArthurChiao's Blog" href="http://0.0.0.0:4000/feed.xml" />
    
    <!-- Stylesheet -->
    <link rel="stylesheet" href="/assets/css/style.css">
    <!--[if IE 8]><link rel="stylesheet" href="/assets/css/ie.css"><![endif]-->
    <link rel="canonical" href="http://0.0.0.0:4000/blog/how-to-make-linux-microservice-aware-with-cilium-zh/">

    <!-- Modernizr -->
    <script src="/assets/js/modernizr.custom.15390.js" type="text/javascript"></script>

    
</head>


<body>
  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WP54B9K"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->

    <div class="header">
     <div class="container">
         <h1 class="logo"><a href="/">ArthurChiao's Blog</a></h1>
         <nav class="nav-collapse">
             <ul class="noList">
                 
                   
                   
                   <li class="element first  ">
                     <a href="/index.html">Home</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/articles">Articles</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/articles-zh">Articles (中文)</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/categories">Categories</a>
                   </li> 
                 
                   
                   
                   <li class="element   last">
                     <a href="/about">About</a>
                   </li> 
                 
                 <!-- <li> <a href="https://github.com/arthurchiao/reading" target="_blank">Reading</a></li> -->
                 <!-- <li> <a href="https://github.com/arthurchiao/" target="_blank">GitHub</a></li> -->
             </ul>
         </nav>
     </div>
 </div><!-- end .header -->


   <div class="content">
      <div class="container">
         <div class="post">
  
  <h1 class="postTitle">[译] 如何基于 Cilium 和 eBPF 打造可感知微服务的 Linux</h1>
  <p class="meta">2019-04-16 | <span class="time">11</span> Minute Read</p>

  
  
  <h3 id="译者序">译者序</h3>

<p>本文内容来自 2019 年的一个技术分享 <a href="https://www.infoq.com/presentations/linux-cilium-ebpf">How to Make Linux Microservice-Aware with
Cilium and eBPF</a>
，作者是 Cilium 项目的创始人和核心开发者，演讲为英文。</p>

<p>本文翻译了演讲的技术性内容，其他少部分非技术内容（例如部分开场白）已略过。如有疑
问，请观看<strong>原视频</strong>。注意，链接页面的英文讲稿很可能是语音识别出来的，其中包含一些
错误，会影响对内容的理解，所以有还是建议观看原视频。</p>

<p>以下是译文。</p>

<hr />

<p align="center"><img src="/assets/img/how-to-make-linux-microservice-aware-with-cilium/1.PNG" width="70%" height="70%" /></p>

<p>今天在这里给大家介绍 BPF（Berkeley Packet Filter），以及如何基于 BPF 将 Linux 打
造成一个<strong>可感知微服务的操作系统</strong>。</p>

<p align="center"><img src="/assets/img/how-to-make-linux-microservice-aware-with-cilium/2.PNG" width="70%" height="70%" /></p>

<p>我有什么资格谈论这些内容？</p>

<p>过去 15 年我一直都在从事 Linux 内核开发。</p>

<p>其中有 10 年左右，我的主要关注点是网络和安全子系统。我参与编写了可能是世界上最大
的单体应用（Linux Kernel），现在有 12 million 行源代码。我参与过所有的网络子系统
、一些用户空间安全组件、netlink、iptables 等等的开发。</p>

<p>过去的 2 年，我创建了 Cilium 项目，之后又联合创立了一个公司在背后支持 Cilium。</p>

<p align="center"><img src="/assets/img/how-to-make-linux-microservice-aware-with-cilium/3.PNG" width="70%" height="70%" /></p>

<p>在这次分享中，我将讨论以下内容：</p>

<ul>
  <li>应用运行方式的演进</li>
  <li>微服务时代 Linux 内核存在的问题</li>
  <li>BPF 和 Cilium</li>
</ul>

<h2 id="应用运行方式的演进">应用运行方式的演进</h2>

<p align="center"><img src="/assets/img/how-to-make-linux-microservice-aware-with-cilium/4.PNG" width="70%" height="70%" /></p>

<p>最早的时代是单任务时代。每个进程拥有对机器的所有权限。我对这个时代没什么了解，
我太年轻了。</p>

<p>然后多任务时代，多个 CPU 分给不同进程使用，开始有了 MMU、虚拟内存等概念。Linux 就是
从这个时候开始起飞的。你需要运行一个 Linux 发行版，管理应用的依赖。一个服务器上
所有的应用会共享一些库，你需要确保库的版本的正确性。<strong>多任务时代还是在物理服务器上
跑应用的</strong>。</p>

<p>再之后，我们就进入了虚拟化时代。突然间，所有的东西都开始跑在虚拟机内部。我们将应
用和操作系统打包到一起，基本上，每个应用都可以跑在不同的操作系统上，而你可以将这
些应用运行在同一台物理服务器（宿主机）上。然后我们开始虚拟硬件，很多名词前面
都开始加上 “虚拟”（“v”），例如虚拟交换机、虚拟网桥、虚拟设备。
<strong>所有东西都变成了软件定义的。本质上，这些都是以前硬件上的功能，我们用软件重做了
一遍，运行在虚拟机内部</strong>。</p>

<p>现在，我们正在进入微服务和容器时代。<strong>本质上，我们正在重新回到将应用跑在宿主机上的
时代</strong>：我们将不同应用直接跑在宿主机操作系统上，不再是每个应用一个虚拟机。这些应用
需要通过宿主机操作系统、容器、namespace等进行隔离和资源管理，后面会介绍这些内容。</p>

<p>这对<strong>操作系统需要提供什么功能</strong>产生了巨大的影响。不再是“喔，我需要将网络包转发给
这个虚拟机。我需要做一些防火墙工作”。<strong>我们真正需要考虑的是应用</strong>。同样的，这是一个
巨大的转变。这和单任务到多任务的转变还不一样。突然间，我们开始有一些只会持续几
十秒的应用，这导致完全不同的需求。另外，还有多租户系统，以及其他非常不同的场景。</p>

<h2 id="微服务时代-linux-内核的问题">微服务时代 Linux 内核的问题</h2>

<p align="center"><img src="/assets/img/how-to-make-linux-microservice-aware-with-cilium/5.PNG" width="70%" height="70%" /></p>

<p>在这种情况下，Linux 内核有哪些问题？显然，它不是为这个时代设计的。</p>

<h3 id="问题一抽象">问题一：抽象</h3>

<p align="center"><img src="/assets/img/how-to-make-linux-microservice-aware-with-cilium/6.PNG" width="70%" height="70%" /></p>

<p>软件开发者都喜欢抽象。上面这张图只是网络相关的抽象，但它清楚地展示了 Linux 内核里
的抽象长什么样子。如果我们想用 Netfilter 做包过滤，那就必须要经过 socket 和
TCP协议栈。而如果从网卡往上看的话，包得经过网络设备抽象层、流量整形（traffic
shaping）、以太网层、IP 层等等才能到达应用。上下都需要经历协议栈。</p>

<p>这种抽象会带来几方面好处：</p>

<ol>
  <li><strong>用户空间 API 强兼容性</strong>：例如，20 年前编译的可执行文件现在仍然能工作。这
太神奇了，非常伟大</li>
  <li><strong>使大部分内核代码不依赖硬件</strong>：我已经（作为内核开发者）工作 15 年了，但从来
没写过一个驱动程序。我对硬件所知甚少（have no clue about hardware），但我写过
很多底层代码（low level code），例如 IP、路由和防火墙相关的。对于真实的硬件，
我几乎没有什么了解</li>
</ol>

<p>抽象带来的坏处：</p>

<ol>
  <li><strong>巨大的性能开销</strong>（massive performance overhead）：接下来我们会看到为什么会
有这些性能开销，以及如何解决这个问题</li>
  <li><strong>很难绕过（bypass）这些层</strong>：虽然有一些场景可以做到 bypass，但大部分都是
bypass 不掉的</li>
</ol>

<h3 id="问题二每个子系统都有自己的-api">问题二：每个子系统都有自己的 API</h3>

<p align="center"><img src="/assets/img/how-to-make-linux-microservice-aware-with-cilium/7.PNG" width="70%" height="70%" /></p>

<p>这张图展示的是网络相关的（子系统），但对于存储和其他系统，问题都是类似的。我在图
中列出了对这些子系统进行操作所需的工具。例如，</p>

<ul>
  <li>配置以太网驱动或者网络设备需要使用 <code class="highlighter-rouge">ethtool</code> 命令</li>
  <li>配置路由使用 <code class="highlighter-rouge">ip</code> 命令</li>
  <li>配置过滤使用 <code class="highlighter-rouge">seccom</code> 命令</li>
  <li>配置 IP 防火墙使用 <code class="highlighter-rouge">iptables</code> 命令，但如果你使用的是 raw sockets，那有很多地方都
会 bypass，因此这并不是一个完整的防火墙</li>
  <li>配置流量整形使用 <code class="highlighter-rouge">tc</code> 命令</li>
  <li>抓包使用 <code class="highlighter-rouge">tcpdump</code>命令，但同样的，它并没有展示出全部信息，因为它只关注了一层</li>
  <li>如果有虚拟交换机，那使用 <code class="highlighter-rouge">brctl</code> 或 <code class="highlighter-rouge">ovsctl</code></li>
</ul>

<p>所以我们看到，每个子系统都有自己的 API，这意味着如果要自动化这些东西，必须单独的
使用这些工具。有一些工具这样做了，但这种方式意味着我们需要了解其中的每一层。</p>

<h3 id="问题三开发过程">问题三：开发过程</h3>

<p align="center"><img src="/assets/img/how-to-make-linux-microservice-aware-with-cilium/8.PNG" width="70%" height="70%" /></p>

<p>如果你需要改动 Linux 内核，那这项工作将是非常困难的。</p>

<p>但是，先来看一些好的方面。Linux 内核是开放和透明的，任何人都可以看到其他任何人的
改动，而且它的代码质量非常高。另
外，Linux内核非常稳定，可能是目前最稳定的系统，而且获取它非常方便。一旦你将自己
的改动合并到内核，每个使用内核的人都会用到你的改动，这几乎完全是厂商无关的（
vendor-neutral）。</p>

<p>不好的方面：不好的方面太多了。</p>

<p>首先，内核是非常，非常难改。通常需要大喊大叫（Shouting is involved）。
但这种状况也正在明显地改善。Linux 内核是一个非常庞大和复
杂的代码库，包含 12 million 行 C 和其他语言代码，其中一些代码已经 30 多岁高龄了
。向upstream
提交代码很难，需要达成共识。如果你有特殊的使用场景，而且没有发现其他人认同你的观
点，那你的代码是无法合并进内核的。在这种情况下，你只能 fork 一份内核，维护自己的
包含 12 million 行代码的内核分支。</p>

<p>视所使用的 Linux 内核发行版的不同，其他用户可
能得几年之后才能用到某个改动。一些人还在运行 10 年前的内核。</p>

<p>最大的问题可能是，每个人都在维护自己的内核 fork，很多时候涉及到上千个 patch 需要
backport。如果你运行的是 Android，那你运行的是 Linux，具体的说是 Android Linux。
如果你在运行 Rail，那你运行的是 Linux，具体的说是有 4 万个 patch 的 Linux。它们
和上游的Linux 还是不太一样的，而只是上游的一个 fork。因此，大家都在运行自己的
Linux。</p>

<h3 id="问题四linux-感知不到容器">问题四：Linux 感知不到容器</h3>

<p align="center"><img src="/assets/img/how-to-make-linux-microservice-aware-with-cilium/9.PNG" width="70%" height="70%" /></p>

<p><strong>这也许是最严重的问题：事实上内核感知不到容器的存在。</strong></p>

<p>内核知道的是：</p>

<ul>
  <li>进程和线程</li>
  <li>cgroups</li>
  <li>Namespaces</li>
  <li>IP 地址和端口号</li>
  <li>系统调用和 SELinux 上下文</li>
</ul>

<p>Cgroups 是一个逻辑结构，你可以将进程关联到一个 group，然后指定这个 group 的资源
限制，例如可以使用的 CPU、内存、IOPS 等等。</p>

<p>Namespace 是一种隔离技术，例如给一个 group 的进程指定 namespace 限制一个虚拟地址
空间，使它们只能看到这个 namespace 的进程。网络 namespace 的网络设备只能看到这个
namespace 内的网络设备。</p>

<p>内核知道 IP 地址和系统调用。因此应用发起系统调用时，内核可以对它进行跟踪和过滤。
内核还知道 SELinux 上下文，因此有过滤网络安全相关的功能，例如控制进程是否/如何与
其他进程通信。听起来很有用。</p>

<p><strong>这些都是多任务时代（multitasking age）的基石。</strong></p>

<p>内核不知道的是：</p>

<ul>
  <li>容器或 K8S pods</li>
  <li>暴露（到宿主机外面）的需求</li>
  <li>容器/Pods 之间的 API 调用</li>
  <li>service mesh</li>
</ul>

<p><strong>内核无法感知（作为一个整体的）容器</strong>。</p>

<p>你可以在 cgroup 文件中找到容器 ID，但内
核本身并不理解一个容器是什么。它只能看到 cgroups 里面的 namespaces。</p>

<p><strong>内核理解应用是否需要暴露给外部</strong>。在多任务时代，内核其实知道一个应用绑定了哪个
IP 和 port，以及是否对外暴露。例如如果一个web server 运行在 localhost 的 80
端口，内核就理解它不应该被暴露到外部。在容器时代，内核已经不清楚什么应该被暴露，
什么不应该被暴露了。</p>

<p>另外一个大问题：<strong>以前通过 IPC 或 Linux domain socket pipe 方式的通信，现在换成
REST、GRPC 等方式了。内核无法感知到后者</strong>。内核知道的仅仅是网络包、端口号等，
内核会知道：“嘿，这里有一个进程，它监听在 80 端口，运行在自己的 namespace 内。”
除此之外的（更上层）东西，内核就不知道了，例如跑在这个端口上的是什么服务。
在之前，内核还知道这是一个正在通过 IPC 和其他进程通信的进程，这种情况是简单的进
程到进程、服务到服务通信。而 service mesh —— 我不知道在坐有多少人正在关注
service mesh—— 内核无法感知到 service mesh。很多东西都是内核不知道的。</p>

<h3 id="解决办法">解决办法</h3>

<p align="center"><img src="/assets/img/how-to-make-linux-microservice-aware-with-cilium/10.PNG" width="70%" height="70%" /></p>

<p>面对这种情况，我们该怎么办呢？有几种解决方式。</p>

<p>第一种方式，针对第一个问题（内核实现的抽象和分层问题），我们可以<strong>给用户空间程序
访问硬件的权限，完全绕过内核</strong>。我是认真的（I mean it will be
fine），内核可以处理好这些事情。应用可能也知道如何使用硬件。这类用户空间程序包括
DMA、DPDK 及类似框架。</p>

<p>第二种解决方式：<strong>Unikernel</strong>。Linus 错了，<strong>每个应用应该自带它们自己的操作系统</strong>，
这完全可行（definitely feasible）。这类例子也很多，包括 ClickOS、MirageOS、
Rumprun 等等。每个应用自带自己的操作系统，而不是共享同一个操作系统。</p>

<p>第三种方式：<strong>将操作系统上移到用户空间</strong>。gVisor 是一个例子，已经好多年了。我们
可以<strong>将操作系统的大部分功能都跑在用户空间，只将最小的子集跑在内核空间</strong>，处理硬
件等相关的事情。这样对于很多网络和存储问题，我们就不需要和内核社区协商了（直接在
用户空间自己改）。这个想法非常棒，但是，代价是性能会有非常大的（massive）下降。</p>

<p>最后，我们还有一种解决方式：从头来过，<strong>重写一切</strong>（rewrite everything）。显然，
这也是一种办法。<strong>我相信今天晚些时候 Brian 会分享如何用 Rust 重写一切</strong>（高级黑
！）。我认为重写一切是非常大的一项工程，因此我去 google 了一下重写 Linux 内核需要
多少预算，这是给出的数字：<code class="highlighter-rouge">$1,372,340,206</code>。我不清楚计算所用的工资水平跟现在比是
否已经过时，但我们已经看出来：重写 Linux 内核基本上是不可行的。</p>

<h2 id="bpf-是什么">BPF 是什么？</h2>

<p align="center"><img src="/assets/img/how-to-make-linux-microservice-aware-with-cilium/11.PNG" width="70%" height="70%" /></p>

<p><strong>BPF 是一个解决所有这些问题的方案</strong>。那什么是 BPF？</p>

<p>BPF 是 Linux 内核中的一个高性能<strong>沙盒虚拟机</strong>（sandbox virtual machine），它将内
核变成了可编程的（programmable）。它由我们团队和 Facebook 的一些工程师维护，另外
还有很多 Google、RedHat、Netflix、Netronome 等工程师协助。BPF 生成的代码如上图所
示，这使得开发者可以<strong>对内核进行编程（program the Linux Kernel）</strong>，我们接下来会
看到这是如何工作的。</p>

<p align="center"><img src="/assets/img/how-to-make-linux-microservice-aware-with-cilium/12.PNG" width="70%" height="70%" /></p>

<p>要理解 BPF 首先要意识到：<strong>Linux 内核本质上是事件驱动的</strong>。</p>

<p>在图中最上面，有进程进行系统调用，它们会连接到其他应用，写数据到磁盘，读写
socket，请求定时器等等。这些都是事件驱动的。这些过程都是系统调用。</p>

<p>在图最下面，是硬件层。这些可以是真实的硬件，也可以是虚拟的硬件，它们会处理中断事
件，例如：“嗨，我收到了一个网络包”，“嗨，你在这个设备上请求的数据现在可以读了”，
等等。因此，内核所作的一切事情都是事件驱动的。</p>

<p>在图中间，是 12 million 行巨型单体应用（Linux Kernel）的代码，这些代码处理
各种事件。</p>

<p align="center"><img src="/assets/img/how-to-make-linux-microservice-aware-with-cilium/13.PNG" width="70%" height="70%" /></p>

<p>BPF 给我们提供了<strong>在事件发生时运行指定的 BPF 程序</strong>的能力。</p>

<p>例如，我们可以在以下事件发生时运行我们的 BPF 程序：</p>

<ul>
  <li>应用发起 <code class="highlighter-rouge">read</code>/<code class="highlighter-rouge">write</code>/<code class="highlighter-rouge">connect</code> 等系统调用</li>
  <li>TCP 发生重传</li>
  <li>网络包达到网卡</li>
</ul>

<p>因此，BPF 允许我们在内核实现这些逻辑，当发生特定的内核事件时做相应的处理。对所有
的内核函数，可以通过 kprobes 做这些事情。也可以对 tracepoints 做这些事情。这
些都是定义良好的、稳定的函数（名）。我们甚至可以对用户空间函数做这些，使用
uprobe。这样当用户空间应用调用到这些函数时，我们就可以通过 uprobe 和 BPF 程序捕
获。这就是那些基于 BPF 实现的 profiling 和 tracing 工具的工作原理。我们在系统调用、
网络设备、socket 层交互甚至网卡驱动层（通过 DMA）等地方调用 BPF 程序，而且内核里
的可 attach 点越来越多。</p>

<p align="center"><img src="/assets/img/how-to-make-linux-microservice-aware-with-cilium/14.PNG" width="70%" height="70%" /></p>

<p>BPF 程序之间可以通信，它们可以使用 BPF maps 保存状态信息。</p>

<p>BPF maps 数据<strong>可以通过 BPF 程序访问，也可以从用户空间访问</strong>。因此可以在 BPF
程序中向 BPF maps 写数据，然后从用户空间读取，例如导出一些采集数据。或者，可以将
配置信息写入 maps，然后从 BPF 程序读取配置。</p>

<p>BPF maps 支持哈希表、数组、LRU、Ring Buffer、Stack trace、LPM 等等。其中一些支持
per-CPU variant，性能更高。</p>

<p align="center"><img src="/assets/img/how-to-make-linux-microservice-aware-with-cilium/15.PNG" width="70%" height="70%" /></p>

<p>可以调用 BPF 辅助函数。例如 BPF 程序本身不知道如何操作一个网络包，而我们可以通过
调用helper 函数实现。这些 helper 函数都是稳定的 API。这使得 BPF 程序可以通过
Linux内核理解的、已有的功能来和内核交互。</p>

<p align="center"><img src="/assets/img/how-to-make-linux-microservice-aware-with-cilium/16.PNG" width="70%" height="70%" /></p>

<p>我们可以做尾调用（tail call）；可以从一个程序调用另一个程序；可以实现逻辑程序链
（chains of logical programs），基于此可以实现函数调用。这使得可以构建一个小程序
，按顺序依次调用他们。</p>

<p align="center"><img src="/assets/img/how-to-make-linux-microservice-aware-with-cilium/17.PNG" width="70%" height="70%" /></p>

<p>我们有一个 JIT （Just-In-Time）编译器。当加载通用
的、CPU无关的字节码之后，内核会接管，验证它的合法性，然后将它编译成 CPU 相关的代
码，例如 x86。可以看到目前支持的 CPU 类型，目前主要支持的是 64 位 CPU。</p>

<p align="center"><img src="/assets/img/how-to-make-linux-microservice-aware-with-cilium/18.PNG" width="70%" height="70%" /></p>

<p>BPF 的贡献者有哪些？以上是目前的列表，这个列表还在增长，这里展示的仅仅是 TOP10。
这是过去两年给 BPF 内核侧贡献过代码的开发者。Daniel 和 Alexei 目前共同维护 BPF。
然后有来自 Facebook、Reddit、Netronome 等公司的贡献者。我印象中大概有 186 位。
BPF 是目前内核最活跃的子系统之一。</p>

<p align="center"><img src="/assets/img/how-to-make-linux-microservice-aware-with-cilium/19.PNG" width="70%" height="70%" /></p>

<p>谁在使用 BPF？用来做什么？这个领域正在发生革命性的变化，但目前大家看到的还比较少
。</p>

<h3 id="use-case-1facebook">Use case 1：Facebook</h3>

<p>Facebook 用 BPF 重写了他们的大部分基础设施。</p>

<p>11 月 12 号的 BPF 峰会上，他们会介绍 Facebook 如何用 BPF 替换了 iptables 和
network filter。这个分享肯定会在线直播的。如果你对此感兴趣，到时可以在线收听。他
们会提供大量的细节和性能数据。Facebook 基本上已经将他们的负载均衡器从 IPVS 换成了
BPF。他们已经将 BPF 用在流量优化（traffic optimization），在分享中，它们也将会介
绍他们在网络安全方面的工作。</p>

<h3 id="use-case-2google">Use case 2：Google</h3>

<p>Google 已经开始用 BPF 做 <strong>profiling</strong>，找出在分布式系统中应用消耗多少 CPU。而且，他
们也开始将 BPF 的使用范围扩展到<strong>流量优化和网络安全</strong>。</p>

<h3 id="use-case-3redhat">Use case 3：Redhat</h3>

<p>Redhat 正在开发一个叫 <code class="highlighter-rouge">bpffilter</code> 的上游项目，将来会替换掉内核里的 iptables，也
就是说，内核里基于 iptables做包过滤的功能，以后都会用 BPF 替换。另外还有一些论文
和项目，关于 XDP 和 BPF+NFV的场景。</p>

<h3 id="use-case-4netflix">Use case 4：Netflix</h3>

<p>如果你听说过 DPF，那你估计是看过 Brendan Gregg 的分享。他介绍了如何在大规模生产
环境中使用 BPF 定位 CPU 消耗问题，这个问题用传统方式是很难做的，需要特别轻量级的
工具。他基于 BPF 采集信息然后画出所谓的火焰图（flame graphs），帮助定位性能问题
。最近他开源了一个 BPF trace 的项目，可以帮助排查性能问题。</p>

<p>另外还有大量的与 BPF 相关的项目。</p>

<h3 id="bpf-程序长什么样">BPF 程序长什么样？</h3>

<p align="center"><img src="/assets/img/how-to-make-linux-microservice-aware-with-cilium/20.PNG" width="70%" height="70%" /></p>

<p>以上是一个（至少对我来说）简单的 BPF 程序。</p>

<p>BPF 程序使用高级语言编写，例如 C 语言。以上这个例子中，每次系统调用返回时，就会
执行这个 BPF 程序。程序会获取进程的 PID 和 程序名，将信息送到用户空间。这样你就
可以监控你的系统。非常非常简单的例子，但这就是基于 BPF 的 profiling 和
monitoring 系统的工作原理。</p>

<h2 id="cilium-是什么">Cilium 是什么？</h2>

<p align="center"><img src="/assets/img/how-to-make-linux-microservice-aware-with-cilium/21.PNG" width="70%" height="70%" /></p>

<p>以上就是关于 BPF 的介绍，非常的底层，那么，必须得了解所有这些细节才能使用 BPF 吗
？不，这就是我们创建 Cilium 项目的原因。</p>

<p>Cilium 是一个开源项目，目标是为微服务环境提供网络、负载均衡、安全功能，主要定位
是容器平台。这个项目本身并不需要容器环境，但目前我们提供的是容器化的安装方式。
Cilium 基于 BPF。</p>

<h3 id="目标">目标</h3>

<p align="center"><img src="/assets/img/how-to-make-linux-microservice-aware-with-cilium/22.PNG" width="70%" height="70%" /></p>

<p>首先是<strong>让 BPF 更易上手使用</strong>（approachable）。BPF 本身很神奇、灵活、性能非常高，但
对内核不了解的话，要使用起来非常困难。而毫无疑问，大部分人并不想自己写 BPF 程序
，但想利用 BPF 来完成一些事情。因此，我们需要自动化 BPF 代码生成、自动化 BPF 管
理等等。这是第一个目标。</p>

<p>第二个目标是<strong>利用 BPF 的灵活性使内核感知到 cloud native 应用</strong>，我们后面会详细展开
。</p>

<p>第三个目标是<strong>安全</strong>，通过 BPF 使内核能够感知到 API 层。内核能够理解：“嗨，你有
两个应用互相通信，它们之间调用了哪些 API？”使内核能够为 API 调用提供安全保障。构
建一个基于身份认证（identity-based）机制使服务通信更安全。因此不同于以前简单的
IP+Port 过滤，<strong>现在内核可以理解什么是一个微服务</strong>，微服务的 labels 有哪些，这个
微服务的安全性是怎么样的。</p>

<p>进程级别的上下文 enforcement。利用 BPF 的强大功能使内核理解一个可执行文件是什么
，一个容器里的进程正在进行什么 API 调用。这非常有用。例如，大家都知道 <code class="highlighter-rouge">kubectl
exec</code> 可以到一个容器里去执行命令，但是，谁来保证这个通信过程的安全？显然不是服务自身。
那你如何保证这个通信过程的安全呢，保证命令不会发送到错误的地方？</p>

<p>最后一点就是 BPF 的性能。</p>

<h3 id="cilium-use-cases">Cilium Use Cases</h3>

<p align="center"><img src="/assets/img/how-to-make-linux-microservice-aware-with-cilium/23.PNG" width="70%" height="70%" /></p>

<p>首先我们提供了 CNI 和 CNM plugin，你可以使用 cilium 作为容器的网络方案。
支持 IPv4/IPv6、NAT46、负载均衡等等。</p>

<p>我们提供了微服务安全（microservice security），<strong>基于 identity 做安全，而不是传统
的基于 IP 和端口</strong>。我们给服务指定 identity，允许基于 service label
定义安全策略。例如允许我的前端和后端通信，我们是在网络层做这种策略的。我们有<strong>增强
的 API 安全支持</strong>，例如之允许部分 REST API 调用，或者只允许访问 Kafka 集群，并且只
能生产或消费特定的 topic 等等。</p>

<p>我们有 DNS 服务器策略。下一个版本会支持 SSL。</p>

<p align="center"><img src="/assets/img/how-to-make-linux-microservice-aware-with-cilium/24.PNG" width="70%" height="70%" /></p>

<p>最后是 <strong>service mesh 的加速</strong>。这里我介绍的稍微详细一点，因为我感觉这是很多人感
兴趣的地方。</p>

<p>上面左边这张图就是 service mesh 中常见的两个服务通信的场景。两个服务并不是直接和
彼此通信，而是通过各自的 sidecar。看起来非常简单和简洁。</p>

<p>右边是它实际的、在数据传输层的样子。服务出来的请求经过协议栈和 iptables 规则进入到
sidecar 的监听 socket，这个 TCP 连接到这里就是终点了。sidecar 会将请求收进来，检
查 HTTP头和其他一些信息，做一些它自己的处理，然后再将请求发送出去。这个过程并不
高效。<strong>加上这一层 sidecar 会有 10x 的性能损失</strong>。<strong>这并不是 sidecar 本身的性能造成
的</strong>（我这里放的图是 Envoy，已经很高效了），而是 sidecar 代理的工作方式造成的。</p>

<p align="center"><img src="/assets/img/how-to-make-linux-microservice-aware-with-cilium/25.PNG" width="70%" height="70%" /></p>

<p>这里为什么要使用 TCP？TCP 是为有质量差、有丢包的网络设计的。如果服务和 sidecar
永远都是在一台宿主机内部，我们为什么还要用 TCP？</p>

<p>我们可以绕过 TCP，将两个 socket 以短路方式连接到一起。如果服务和 sidecar 永远在
一台宿主机上，我们可以直接在两个 socket 之间拷贝数据。我们实际测量，如果以 RPS
（每分钟请求数）衡量，<strong>性能可以 3x ~ 4x</strong>。因此，这就是 Cilium 和 BPF 使 Linux
内核可感知微服务的一个例子。Cilium/BPF 的目的就是为服务化时代提供便利和所需的功
能。</p>

<p align="center"><img src="/assets/img/how-to-make-linux-microservice-aware-with-cilium/26.PNG" width="70%" height="70%" /></p>

<p>其他一些 BPF 相关的项目。</p>

<p align="center"><img src="/assets/img/how-to-make-linux-microservice-aware-with-cilium/27.PNG" width="70%" height="70%" /></p>


  <!-- POST NAVIGATION -->
  <div class="postNav clearfix">
     
      <a class="prev" href="/blog/internet-routing-architecture-zh/"><span>&laquo;&nbsp;[笔记] Internet Routing Architecture (Cisco Press, 2000)</span>
      
    </a>
      
      
      <a class="next" href="/blog/ctrip-network-arch-evolution/"><span>Ctrip Network Architecture Evolution in the Cloud Computing Era&nbsp;&raquo;</span>
       
      </a>
     
  </div>
</div>


         

      </div>
   </div><!-- end .content -->

   <div class="footer">
   <div class="container">
      <p class="copy">&copy; 2016-2019
      <a href="https://arthurchiao.github.io">Arthur Chiao</a>, Powered by
      <a href="http://jekyllrb.com">Jekyll </a>, Theme originated from
      <a href="https://github.com/brianmaierjr/long-haul"> Long Haul.</a>

      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
      <span id="busuanzi_container_site_pv"> Site visits:
          <span id="busuanzi_value_site_pv"></span>, powered by<a href="http://busuanzi.ibruce.info/"> busuanzi</a>
      </span>

      </p>

      <div class="footer-links"> 
         <ul class="noList"> 
            
            <li><a href="https://www.facebook.com/profile.php?id=100014334455077">
                  <svg id="facebook-square" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M82.667,1H17.335C8.351,1,1,8.351,1,17.336v65.329c0,8.99,7.351,16.335,16.334,16.335h65.332 C91.652,99.001,99,91.655,99,82.665V17.337C99,8.353,91.652,1.001,82.667,1L82.667,1z M84.318,50H68.375v42.875H50V50h-8.855V35.973 H50v-9.11c0-12.378,5.339-19.739,19.894-19.739h16.772V22.3H72.967c-4.066-0.007-4.57,2.12-4.57,6.078l-0.023,7.594H86.75 l-2.431,14.027V50z"></path>
                  </svg>
            </a></li>
            
            
            <li><a href="https://linkedin.com/in/yanan-zhao-7691317b?trk=hp-identity-photo">
                  <svg id="linkedin" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M99.001,19.428c-3.606,1.608-7.48,2.695-11.547,3.184c4.15-2.503,7.338-6.466,8.841-11.189 c-3.885,2.318-8.187,4-12.768,4.908c-3.667-3.931-8.893-6.387-14.676-6.387c-11.104,0-20.107,9.054-20.107,20.223 c0,1.585,0.177,3.128,0.52,4.609c-16.71-0.845-31.525-8.895-41.442-21.131C6.092,16.633,5.1,20.107,5.1,23.813 c0,7.017,3.55,13.208,8.945,16.834c-3.296-0.104-6.397-1.014-9.106-2.529c-0.002,0.085-0.002,0.17-0.002,0.255 c0,9.799,6.931,17.972,16.129,19.831c-1.688,0.463-3.463,0.71-5.297,0.71c-1.296,0-2.555-0.127-3.783-0.363 c2.559,8.034,9.984,13.882,18.782,14.045c-6.881,5.424-15.551,8.657-24.971,8.657c-1.623,0-3.223-0.096-4.796-0.282 c8.898,5.738,19.467,9.087,30.82,9.087c36.982,0,57.206-30.817,57.206-57.543c0-0.877-0.02-1.748-0.059-2.617 C92.896,27.045,96.305,23.482,99.001,19.428z"></path>
                  </svg>
            </a></li>
            
            
            <li><a href="https://github.com/ArthurChiao">
                  <svg id="github" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M50,1C22.938,1,1,22.938,1,50s21.938,49,49,49s49-21.938,49-49S77.062,1,50,1z M79.099,79.099 c-3.782,3.782-8.184,6.75-13.083,8.823c-1.245,0.526-2.509,0.989-3.79,1.387v-7.344c0-3.86-1.324-6.699-3.972-8.517 c1.659-0.16,3.182-0.383,4.57-0.67c1.388-0.287,2.855-0.702,4.402-1.245c1.547-0.543,2.935-1.189,4.163-1.938 c1.228-0.75,2.409-1.723,3.541-2.919s2.082-2.552,2.847-4.067s1.372-3.334,1.818-5.455c0.446-2.121,0.67-4.458,0.67-7.01 c0-4.945-1.611-9.155-4.833-12.633c1.467-3.828,1.308-7.991-0.478-12.489l-1.197-0.143c-0.829-0.096-2.321,0.255-4.474,1.053 c-2.153,0.798-4.57,2.105-7.249,3.924c-3.797-1.053-7.736-1.579-11.82-1.579c-4.115,0-8.039,0.526-11.772,1.579 c-1.69-1.149-3.294-2.097-4.809-2.847c-1.515-0.75-2.727-1.26-3.637-1.532c-0.909-0.271-1.754-0.439-2.536-0.503 c-0.782-0.064-1.284-0.079-1.507-0.048c-0.223,0.031-0.383,0.064-0.478,0.096c-1.787,4.53-1.946,8.694-0.478,12.489 c-3.222,3.477-4.833,7.688-4.833,12.633c0,2.552,0.223,4.889,0.67,7.01c0.447,2.121,1.053,3.94,1.818,5.455 c0.765,1.515,1.715,2.871,2.847,4.067s2.313,2.169,3.541,2.919c1.228,0.751,2.616,1.396,4.163,1.938 c1.547,0.543,3.014,0.957,4.402,1.245c1.388,0.287,2.911,0.511,4.57,0.67c-2.616,1.787-3.924,4.626-3.924,8.517v7.487 c-1.445-0.43-2.869-0.938-4.268-1.53c-4.899-2.073-9.301-5.041-13.083-8.823c-3.782-3.782-6.75-8.184-8.823-13.083 C9.934,60.948,8.847,55.56,8.847,50s1.087-10.948,3.231-16.016c2.073-4.899,5.041-9.301,8.823-13.083s8.184-6.75,13.083-8.823 C39.052,9.934,44.44,8.847,50,8.847s10.948,1.087,16.016,3.231c4.9,2.073,9.301,5.041,13.083,8.823 c3.782,3.782,6.75,8.184,8.823,13.083c2.143,5.069,3.23,10.457,3.23,16.016s-1.087,10.948-3.231,16.016 C85.848,70.915,82.88,75.317,79.099,79.099L79.099,79.099z"></path>
                  </svg>
            </a></li>
             
            
            <li><a href="mailto:arthurchiao@hotmail.com">
                  <svg id="mail" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M50,1C22.938,1,1,22.938,1,50s21.938,49,49,49s49-21.938,49-49S77.062,1,50,1z M25.5,25.5h49 c0.874,0,1.723,0.188,2.502,0.542L50,57.544L22.998,26.041C23.777,25.687,24.626,25.499,25.5,25.5L25.5,25.5z M19.375,68.375v-36.75 c0-0.128,0.005-0.256,0.014-0.383l17.96,20.953L19.587,69.958C19.448,69.447,19.376,68.916,19.375,68.375L19.375,68.375z M74.5,74.5 h-49c-0.541,0-1.072-0.073-1.583-0.212l17.429-17.429L50,66.956l8.653-10.096l17.429,17.429C75.572,74.427,75.041,74.5,74.5,74.5 L74.5,74.5z M80.625,68.375c0,0.541-0.073,1.072-0.211,1.583L62.652,52.195l17.96-20.953c0.008,0.127,0.014,0.255,0.014,0.383 L80.625,68.375L80.625,68.375z"></path>
                  </svg>
            </a></li>
            
         </ul>
      </div>
   </div>
</div><!-- end .footer -->

   <!-- Add jQuery and other scripts -->
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src=""><\/script>')</script>
<script src="/assets/js/dropcap.min.js"></script>
<script src="/assets/js/responsive-nav.min.js"></script>
<script src="/assets/js/scripts.js"></script>


</body>

</html>
