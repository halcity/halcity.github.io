<!DOCTYPE html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7"><![endif]-->
<!--[if IE 7]><html class="no-js lt-ie9 lt-ie8" <![endif]-->
<!--[if IE 8]><html class="no-js lt-ie9" <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->

<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
       new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
       j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
       'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
       })(window,document,'script','dataLayer','GTM-WP54B9K');</script>
    <!-- End Google Tag Manager -->

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <title>[译] 网络包内核路径跟踪：3 eBPF</title>

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="/assets/img/favicon.ico" />

    <!-- Come and get me RSS readers -->
    <link rel="alternate" type="application/rss+xml" title="ArthurChiao's Blog" href="http://0.0.0.0:4000/feed.xml" />
    
    <!-- Stylesheet -->
    <link rel="stylesheet" href="/assets/css/style.css">
    <!--[if IE 8]><link rel="stylesheet" href="/assets/css/ie.css"><![endif]-->
    <link rel="canonical" href="http://0.0.0.0:4000/blog/trace-packet-zh-3/">

    <!-- Modernizr -->
    <script src="/assets/js/modernizr.custom.15390.js" type="text/javascript"></script>

    
</head>


<body>
  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WP54B9K"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->

    <div class="header">
     <div class="container">
         <h1 class="logo"><a href="/">ArthurChiao's Blog</a></h1>
         <nav class="nav-collapse">
             <ul class="noList">
                 
                   
                   
                   <li class="element first  ">
                     <a href="/index.html">Home</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/articles">Articles</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/articles-zh">Articles (中文)</a>
                   </li> 
                 
                   
                   
                   <li class="element   ">
                     <a href="/categories">Categories</a>
                   </li> 
                 
                   
                   
                   <li class="element   last">
                     <a href="/about">About</a>
                   </li> 
                 
                 <!-- <li> <a href="https://github.com/arthurchiao/reading" target="_blank">Reading</a></li> -->
                 <!-- <li> <a href="https://github.com/arthurchiao/" target="_blank">GitHub</a></li> -->
             </ul>
         </nav>
     </div>
 </div><!-- end .header -->


   <div class="content">
      <div class="container">
         <div class="post">
  
  <h1 class="postTitle">[译] 网络包内核路径跟踪：3 eBPF</h1>
  <p class="meta">2018-11-30 | <span class="time">19</span> Minute Read</p>

  
  
  <p>译者按：本文翻译自一篇英文博客<a href="https://blog.yadutaf.fr/2017/07/28/tracing-a-packet-journey-using-linux-tracepoints-perf-ebpf/">Tracing a packet’s journey using Linux tracepoints, perf and eBPF</a>。由于原文篇幅较长，我将其分成了三篇，并添加了适当的标题。
本文不会100%逐词逐句翻译，那样的翻译太过生硬，看看《TCP/IP详解》中文版就知道了。
例如，有多少人会在讨论网络问题的时候说<strong>“插口”</strong>而不是<strong>“socket”</strong>？在技术领域，过
度翻译反而会带来交流障碍。<strong>如果能看懂英文，我建议你阅读原文，或者和本文对照看。</strong></p>

<hr />

<p>前面介绍的内容已经可以满足大部分tracing场景的需求了。如果你只是想学习如何在Linux上
跟踪一个packet的传输路径，那到此已经足够了。但如果你想跟进一步，学习如何写一个自定
义的过滤器，跟踪网络命名空间、源IP、目的IP等信息，请继续往下读。</p>

<h2 id="1-ebpf和kprobes">1 eBPF和kprobes</h2>

<p>从Linux 内核4.7开始，eBPF程序可以attach到内核跟踪点(kernel tracepoints)。在此之
前，要完成类似的工作，只能用kprobes之类的工具attach到<strong>导出的内核函数</strong>
(exported kernel sysbols)。后者虽然可以完成工作，但存在很多不足：</p>

<ol>
  <li>内核的内部（internal）API不稳定</li>
  <li>出于性能考虑，大部分网络相关的内层函数(inner functions)都是内联或者静态的（inlined or static），两者都不可探测</li>
  <li>找出调用某个函数的所有地方是相当乏味的，有时所需的字段数据不全具备</li>
</ol>

<p>这篇博客的早期版本使用了kprobes，但结果并不是太好。</p>

<p>现在，诚实地说，通过内核tracepoints访问数据比通过kprobe要更加乏味。我尽量保持本文简
洁，如果你想了解本文稍老的版本，可以访问这里<a href="https://blog.yadutaf.fr/2016/03/30/turn-any-syscall-into-event-introducing-ebpf-kernel-probes/">英文</a>
，<a href="/blog/ebpf-turn-syscall-to-event-zh">中文翻译</a>。</p>

<h2 id="2-安装">2 安装</h2>

<p>我不是徒手写汇编（handwritten assembly）的粉丝，因此将使用 <code class="highlighter-rouge">bcc</code>。<code class="highlighter-rouge">bcc</code>是一个灵
活强大的工具，允许用受限的C语法（restricted C）写内核探测代码，然后用Python在用
户态做控制。这种方式对于生产环境算是重量级，但对开发来说非常完美。</p>

<p><strong>注意：eBPF需要Linux Kernel 4.7+。</strong></p>

<p>Ubuntu 17.04 <a href="https://github.com/iovisor/bcc/blob/master/INSTALL.md">安装 (GitHub)</a> <code class="highlighter-rouge">bcc</code>:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Install dependencies</span>
<span class="nv">$ </span><span class="nb">sudo </span>apt <span class="nb">install </span>bison build-essential cmake flex git libedit-dev python zlib1g-dev libelf-dev libllvm4.0 llvm-dev libclang-dev luajit luajit-5.1-dev

<span class="c"># Grab the sources</span>
<span class="nv">$ </span>git clone https://github.com/iovisor/bcc.git
<span class="nv">$ </span><span class="nb">mkdir </span>bcc/build
<span class="nv">$ </span><span class="nb">cd </span>bcc/build
<span class="nv">$ </span>cmake .. <span class="nt">-DCMAKE_INSTALL_PREFIX</span><span class="o">=</span>/usr
<span class="nv">$ </span>make
<span class="nv">$ </span><span class="nb">sudo </span>make <span class="nb">install</span>
</code></pre></div></div>

<h2 id="3-自定义跟踪器hello-world">3 自定义跟踪器：Hello World</h2>

<p>接下来我们从一个简单的hello world例子开始，展示如何在底层打点。我们还是用上一篇
文章里选择的四个点：</p>

<ul>
  <li><code class="highlighter-rouge">net_dev_queue</code></li>
  <li><code class="highlighter-rouge">netif_receive_skb_entry</code></li>
  <li><code class="highlighter-rouge">netif_rx</code></li>
  <li><code class="highlighter-rouge">napi_gro_receive_entry</code></li>
</ul>

<p>每当网络包经过这些点，就会触发我们的处理逻辑。为保持简单，我们的处理逻辑只是将程
序的<code class="highlighter-rouge">comm</code>字段（16字节字符串）发送出来（到用户空间程序），这个字段里存的是发送相应
的网络包的程序的名字。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;bcc/proto.h&gt;
#include &lt;linux/sched.h&gt;
</span>
<span class="c1">// Event structure</span>
<span class="k">struct</span> <span class="n">route_evt_t</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">comm</span><span class="p">[</span><span class="n">TASK_COMM_LEN</span><span class="p">];</span>
<span class="p">};</span>
<span class="n">BPF_PERF_OUTPUT</span><span class="p">(</span><span class="n">route_evt</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">do_trace</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ctx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span><span class="o">*</span> <span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Built event for userland</span>
    <span class="k">struct</span> <span class="n">route_evt_t</span> <span class="n">evt</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">bpf_get_current_comm</span><span class="p">(</span><span class="n">evt</span><span class="p">.</span><span class="n">comm</span><span class="p">,</span> <span class="n">TASK_COMM_LEN</span><span class="p">);</span>

    <span class="c1">// Send event to userland</span>
    <span class="n">route_evt</span><span class="p">.</span><span class="n">perf_submit</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">evt</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">evt</span><span class="p">));</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**
  * Attach to Kernel Tracepoints
  */</span>
<span class="n">TRACEPOINT_PROBE</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">netif_rx</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">do_trace</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="o">*</span><span class="p">)</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">skbaddr</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">TRACEPOINT_PROBE</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">net_dev_queue</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">do_trace</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="o">*</span><span class="p">)</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">skbaddr</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">TRACEPOINT_PROBE</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">napi_gro_receive_entry</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">do_trace</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="o">*</span><span class="p">)</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">skbaddr</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">TRACEPOINT_PROBE</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">netif_receive_skb_entry</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">do_trace</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="o">*</span><span class="p">)</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">skbaddr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>可以看到，我们的程序attach到4个tracepoint，并会访问<code class="highlighter-rouge">skbaddr</code>字段，将其传给处理
逻辑函数，这个函数现在只是将程序名字发送出来。你可能会有疑问，<code class="highlighter-rouge">args-&gt;skbaddr</code>是哪
里来的？答案是，每次用<code class="highlighter-rouge">TRACEPONT_PROBE</code>定义一个tracepoint，<code class="highlighter-rouge">bcc</code>就会为其自动生成<code class="highlighter-rouge">args</code>参数，由
于它是动态生成的，因此要查看它的定义不太容易。</p>

<p>不过，有另外一种简单的方式可以查看。在Linux上面，每个tracepoint都对应一个
<code class="highlighter-rouge">/sys/kernel/debug/tracing/events</code>条目。例如，查看<code class="highlighter-rouge">net:netif_rx</code>：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cat</span> /sys/kernel/debug/tracing/events/net/netif_rx/format
name: netif_rx
ID: 1183
format:
	field:unsigned short common_type<span class="p">;</span>         offset:0<span class="p">;</span> size:2<span class="p">;</span> signed:0<span class="p">;</span>
	field:unsigned char common_flags<span class="p">;</span>         offset:2<span class="p">;</span> size:1<span class="p">;</span> signed:0<span class="p">;</span>
	field:unsigned char common_preempt_count<span class="p">;</span> offset:3<span class="p">;</span> size:1<span class="p">;</span> signed:0<span class="p">;</span>
	field:int common_pid<span class="p">;</span>                     offset:4<span class="p">;</span> size:4<span class="p">;</span> signed:1<span class="p">;</span>

	field:void <span class="k">*</span> skbaddr<span class="p">;</span>         offset:8<span class="p">;</span>  size:8<span class="p">;</span> signed:0<span class="p">;</span>
	field:unsigned int len<span class="p">;</span>       offset:16<span class="p">;</span> size:4<span class="p">;</span> signed:0<span class="p">;</span>
	field:__data_loc char[] name<span class="p">;</span> offset:20<span class="p">;</span> size:4<span class="p">;</span> signed:1<span class="p">;</span>

print <span class="nb">fmt</span>: <span class="s2">"dev=%s skbaddr=%p len=%u"</span>, __get_str<span class="o">(</span>name<span class="o">)</span>, REC-&gt;skbaddr, REC-&gt;len
</code></pre></div></div>

<p>注意最后一行<code class="highlighter-rouge">print fmt</code>，这正是<code class="highlighter-rouge">perf trace</code>打印相应消息的格式。</p>

<p>在底层插入这样的探测点之后，我们再写个Python脚本，接收内核发出来的消息，每个eBP
发出的数据都打印一行：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python
# coding: utf-8
</span>
<span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="n">inet_ntop</span>
<span class="kn">from</span> <span class="nn">bcc</span> <span class="kn">import</span> <span class="n">BPF</span>
<span class="kn">import</span> <span class="nn">ctypes</span> <span class="k">as</span> <span class="n">ct</span>

<span class="n">bpf_text</span> <span class="o">=</span> <span class="s">'''&lt;SEE CODE SNIPPET ABOVE&gt;'''</span>

<span class="n">TASK_COMM_LEN</span> <span class="o">=</span> <span class="mi">16</span> <span class="c1"># linux/sched.h
</span>
<span class="k">class</span> <span class="nc">RouteEvt</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s">"comm"</span><span class="p">,</span>    <span class="n">ct</span><span class="o">.</span><span class="n">c_char</span> <span class="o">*</span> <span class="n">TASK_COMM_LEN</span><span class="p">),</span>
    <span class="p">]</span>

<span class="k">def</span> <span class="nf">event_printer</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
    <span class="c1"># Decode event
</span>    <span class="n">event</span> <span class="o">=</span> <span class="n">ct</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ct</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">RouteEvt</span><span class="p">))</span><span class="o">.</span><span class="n">contents</span>

    <span class="c1"># Print event
</span>    <span class="k">print</span> <span class="s">"Just got a packet from </span><span class="si">%</span><span class="s">s"</span> <span class="o">%</span> <span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">comm</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">BPF</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">bpf_text</span><span class="p">)</span>
    <span class="n">b</span><span class="p">[</span><span class="s">"route_evt"</span><span class="p">]</span><span class="o">.</span><span class="n">open_perf_buffer</span><span class="p">(</span><span class="n">event_printer</span><span class="p">)</span>

    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">b</span><span class="o">.</span><span class="n">kprobe_poll</span><span class="p">()</span>
</code></pre></div></div>

<p>现在可以测试了，注意需要root权限。</p>

<p><strong>注意：现在的代码没有对包做任何过滤，因此即便你的机器网络流量很小，输出也很可能刷屏。</strong></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$&gt;</span> <span class="nb">sudo </span>python ./tracepkt.py
...
Just got a packet from ping6
Just got a packet from ping6
Just got a packet from ping
Just got a packet from irq/46-iwlwifi
...
</code></pre></div></div>

<p>上面的输出显示，我正在使用ping和ping6，另外WiFi驱动也收到了一些包。</p>

<h2 id="4-自定义跟踪器改进">4 自定义跟踪器：改进</h2>

<p>接下来让我们添加一些有用的数据/过滤条件。</p>

<h3 id="41-添加网卡信息">4.1 添加网卡信息</h3>

<p>首先，可以安全地删除前面代码中的comm字段，它在这里没什么用处。然后，include
<code class="highlighter-rouge">net/inet_sock.h</code>头文件，这里有我们所需要的函数声明。最后给event结构体添加<code class="highlighter-rouge">char
ifname[IFNAMSIZ]</code>字段。</p>

<p>现在我们可以从device结构体中访问device name字段。这里开始展示出<strong>代码的强大之处
：我们可以访问任何受控范围内的字段。</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Get device pointer, we'll need it to get the name and network namespace</span>
<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
<span class="n">bpf_probe_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span> <span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="p">)</span> <span class="o">+</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">skb</span><span class="p">),</span> <span class="n">dev</span><span class="p">));</span>

<span class="c1">// Load interface name</span>
<span class="n">bpf_probe_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">evt</span><span class="p">.</span><span class="n">ifname</span><span class="p">,</span> <span class="n">IFNAMSIZ</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
</code></pre></div></div>

<p>现在你可以测试一下，这样是能工作的。注意相应地修改一下Python部分。那么，它是怎么
工作的呢？</p>

<p>我们引入了<code class="highlighter-rouge">net_device</code>结构体来访问<strong>网卡名字</strong>字段。第一个<code class="highlighter-rouge">bpf_probe_read</code>从内核
的网络包中将网卡名字拷贝到<code class="highlighter-rouge">dev</code>，第二个将其接力复制到<code class="highlighter-rouge">evt.ifname</code>。</p>

<p>不要忘了，eBPF的目标是允许安全地编写在内核运行的脚本。这意味着，随机内存访问是绝
对不允许的。所有的内存访问都要经过验证。除非你要访问的内存在协议栈，否则你需要通
过<code class="highlighter-rouge">bpf_probe_read</code>读取数据。这会使得代码看起来很繁琐，但非常安全。<code class="highlighter-rouge">bpf_probe_read</code>
像是<code class="highlighter-rouge">memcpy</code>的一个更安全的版本，它定义在内核源文件
<a href="http://elixir.free-electrons.com/linux/v4.10.17/source/kernel/trace/bpf_trace.c#L64">bpf_trace.c</a>
中:</p>

<ol>
  <li>它和memcpy类似，因此注意内存拷贝的代价</li>
  <li>如果遇到错误，它会返回一个错误和一个初始化为0的缓冲区，而不会造成程序崩溃或停
止运行</li>
</ol>

<p>接下来为使代码看起来更加简洁，我将使用如下宏：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define member_read(destination, source_struct, source_member)                 \
  do{                                                                          \
    bpf_probe_read(                                                            \
      destination,                                                             \
      sizeof(source_struct-&gt;source_member),                                    \
      ((char*)source_struct) + offsetof(typeof(*source_struct), source_member) \
    );                                                                         \
  } while(0)
</span></code></pre></div></div>

<p>这样上面的例子就可以写成：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">member_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="42-添加网络命名空间id">4.2 添加网络命名空间ID</h3>

<p>采集网络命名空间信息非常有用，但是实现起来要复杂一些。原理上可以从两个地方访问：</p>

<ol>
  <li>socket结构体<code class="highlighter-rouge">sk</code></li>
  <li>device结构体<code class="highlighter-rouge">dev</code></li>
</ol>

<p>当我在写
<a href="https://github.com/iovisor/bcc/blob/master/tools/solisten.py"><code class="highlighter-rouge">solisten.py</code></a>时
，我使用的时socket结构体。不幸的是，不知道为什么，网络命名空间ID在跨命名空间的地
方消失了。这个字段全是0，很明显是有非法内存访问时的返回值（回忆前面介绍的
<code class="highlighter-rouge">bpf_probe_read</code>如何处理错误）。</p>

<p>幸好，device结构体工作正常。想象一下，我们可以问一个<code class="highlighter-rouge">packet</code>它在哪个<code class="highlighter-rouge">网卡</code>，进而
问这个网卡它在哪个<code class="highlighter-rouge">网络命名空间</code>。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">net</span><span class="o">*</span> <span class="n">net</span><span class="p">;</span>

<span class="c1">// Get netns id. Equivalent to: evt.netns = dev-&gt;nd_net.net-&gt;ns.inum</span>
<span class="n">possible_net_t</span> <span class="o">*</span><span class="n">skc_net</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">nd_net</span><span class="p">;</span>
<span class="n">member_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="p">,</span> <span class="n">skc_net</span><span class="p">,</span> <span class="n">net</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">ns_common</span><span class="o">*</span> <span class="n">ns</span> <span class="o">=</span> <span class="n">member_address</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">ns</span><span class="p">);</span>
<span class="n">member_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">evt</span><span class="p">.</span><span class="n">netns</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">inum</span><span class="p">);</span>
</code></pre></div></div>

<p>其中的宏定义如下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define member_address(source_struct, source_member) \
({                                                   \
  void* __ret;                                       \
  __ret = (void*) (((char*)source_struct) + offsetof(typeof(*source_struct), source_member)); \
  __ret;                                             \
})
</span></code></pre></div></div>

<p>这个宏还可以用于简化<code class="highlighter-rouge">member_read</code>，这个就留给读者作为练习了。</p>

<p>好了，有了以上实现，我们再运行的效果就是：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$&gt;</span> <span class="nb">sudo </span>python ./tracepkt.py
<span class="o">[</span>  4026531957]          docker0
<span class="o">[</span>  4026531957]      vetha373ab6
<span class="o">[</span>  4026532258]             eth0
<span class="o">[</span>  4026532258]             eth0
<span class="o">[</span>  4026531957]      vetha373ab6
<span class="o">[</span>  4026531957]          docker0
</code></pre></div></div>

<p>如果ping一个容器，你看到的就是类似上面的输出。packet首先经过本地的docker0网桥，
然后经veth pair跨过网络命名空间，最后到达容器的eth0网卡。应答包沿着相反的路径回
到宿主机。</p>

<p>至此，功能是实现了，不过还太粗糙，继续改进。</p>

<h3 id="43-只跟踪icmp-echo-requestreply包">4.3 只跟踪ICMP echo request/reply包</h3>

<p>这次我们将读取包的IP信息，这里我只展示IPv4的例子，IPv6的与此类似。</p>

<p>不过，事情也并没有那么简单。我们是在和kernel的网络部分打交道。一些包可能还没被打
开，这意味着，变量的很多字段是没有初始化的。我们只能从MAC头开始，用offset的方式
计算IP头和ICMP头的位置。</p>

<p>首先从MAC头地址推导IP头地址。这里我们不(从<code class="highlighter-rouge">skb</code>的相应字段)加载MAC头长度信息，就认为
它是固定的14字节。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Compute MAC header address</span>
<span class="kt">char</span><span class="o">*</span> <span class="n">head</span><span class="p">;</span>
<span class="n">u16</span> <span class="n">mac_header</span><span class="p">;</span>

<span class="n">member_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="p">,</span>       <span class="n">skb</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
<span class="n">member_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mac_header</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">mac_header</span><span class="p">);</span>

<span class="c1">// Compute IP Header address</span>
<span class="cp">#define MAC_HEADER_SIZE 14;
</span><span class="kt">char</span><span class="o">*</span> <span class="n">ip_header_address</span> <span class="o">=</span> <span class="n">head</span> <span class="o">+</span> <span class="n">mac_header</span> <span class="o">+</span> <span class="n">MAC_HEADER_SIZE</span><span class="p">;</span>
</code></pre></div></div>

<p>这表示我们假设IP头开始的地方在：<code class="highlighter-rouge">skb-&gt;head + skb-&gt;mac_header + MAC_HEADER_SIZE</code>
。
现在，我们可以解析IP头第一个字节的前4个bit：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Load IP protocol version</span>
<span class="n">u8</span> <span class="n">ip_version</span><span class="p">;</span>
<span class="n">bpf_probe_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ip_version</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u8</span><span class="p">),</span> <span class="n">ip_header_address</span><span class="p">);</span>
<span class="n">ip_version</span> <span class="o">=</span> <span class="n">ip_version</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>

<span class="c1">// Filter IPv4 packets</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ip_version</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>然后加载整个IP头，获取IP地址，以使得Python程序的输出看起来更有意义。另外注意，IP
包内的下一个头就是ICMP头。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Load IP Header</span>
<span class="k">struct</span> <span class="n">iphdr</span> <span class="n">iphdr</span><span class="p">;</span>
<span class="n">bpf_probe_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iphdr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">iphdr</span><span class="p">),</span> <span class="n">ip_header_address</span><span class="p">);</span>

<span class="c1">// Load protocol and address</span>
<span class="n">u8</span> <span class="n">icmp_offset_from_ip_header</span> <span class="o">=</span> <span class="n">iphdr</span><span class="p">.</span><span class="n">ihl</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
<span class="n">evt</span><span class="p">.</span><span class="n">saddr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">iphdr</span><span class="p">.</span><span class="n">saddr</span><span class="p">;</span>
<span class="n">evt</span><span class="p">.</span><span class="n">daddr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">iphdr</span><span class="p">.</span><span class="n">daddr</span><span class="p">;</span>

<span class="c1">// Filter ICMP packets</span>
<span class="k">if</span> <span class="p">(</span><span class="n">iphdr</span><span class="p">.</span><span class="n">protocol</span> <span class="o">!=</span> <span class="n">IPPROTO_ICMP</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>最后，我们加载ICMP头，如果是ICMP echo request或reply，就读取序列号：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Compute ICMP header address and load ICMP header</span>
<span class="kt">char</span><span class="o">*</span> <span class="n">icmp_header_address</span> <span class="o">=</span> <span class="n">ip_header_address</span> <span class="o">+</span> <span class="n">icmp_offset_from_ip_header</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">icmphdr</span> <span class="n">icmphdr</span><span class="p">;</span>
<span class="n">bpf_probe_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">icmphdr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">icmphdr</span><span class="p">),</span> <span class="n">icmp_header_address</span><span class="p">);</span>

<span class="c1">// Filter ICMP echo request and echo reply</span>
<span class="k">if</span> <span class="p">(</span><span class="n">icmphdr</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ICMP_ECHO</span> <span class="o">&amp;&amp;</span> <span class="n">icmphdr</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ICMP_ECHOREPLY</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Get ICMP info</span>
<span class="n">evt</span><span class="p">.</span><span class="n">icmptype</span> <span class="o">=</span> <span class="n">icmphdr</span><span class="p">.</span><span class="n">type</span><span class="p">;</span>
<span class="n">evt</span><span class="p">.</span><span class="n">icmpid</span>   <span class="o">=</span> <span class="n">icmphdr</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">echo</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
<span class="n">evt</span><span class="p">.</span><span class="n">icmpseq</span>  <span class="o">=</span> <span class="n">icmphdr</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">echo</span><span class="p">.</span><span class="n">sequence</span><span class="p">;</span>

<span class="c1">// Fix endian</span>
<span class="n">evt</span><span class="p">.</span><span class="n">icmpid</span>  <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">evt</span><span class="p">.</span><span class="n">icmpid</span><span class="p">);</span>
<span class="n">evt</span><span class="p">.</span><span class="n">icmpseq</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">evt</span><span class="p">.</span><span class="n">icmpseq</span><span class="p">);</span>
</code></pre></div></div>

<p>这就是全部工作了。</p>

<p>如果你想过滤特定的ping进程的包，你可以认为<code class="highlighter-rouge">evt.icmpid</code>就是相应ping进程的进程号，
至少Linux上如此。</p>

<h2 id="5-最终效果">5 最终效果</h2>

<p>再写一些比较简单的Python程序配合，我们就可以测试我们的跟踪器在多种场景下的用途。
以root权限启动这个程序，在不同终端发起几个ping进程，就会看到：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># ping -4 localhost</span>
<span class="o">[</span>  4026531957]               lo request <span class="c">#20212.001 127.0.0.1 -&gt; 127.0.0.1</span>
<span class="o">[</span>  4026531957]               lo request <span class="c">#20212.001 127.0.0.1 -&gt; 127.0.0.1</span>
<span class="o">[</span>  4026531957]               lo   reply <span class="c">#20212.001 127.0.0.1 -&gt; 127.0.0.1</span>
<span class="o">[</span>  4026531957]               lo   reply <span class="c">#20212.001 127.0.0.1 -&gt; 127.0.0.1</span>
</code></pre></div></div>

<p>这个ICMP请求是进程20212（Linux ping的ICMP ID）在loopback网卡发出的，最后的
reply原路回到了这个loopback。这个环回接口既是发送网卡又是接收网卡。</p>

<p>如果是我的WiFi网关会是什么样子内？</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># ping -4 192.168.43.1</span>
<span class="o">[</span>  4026531957]           wlp2s0 request <span class="c">#20710.001 192.168.43.191 -&gt; 192.168.43.1</span>
<span class="o">[</span>  4026531957]           wlp2s0   reply <span class="c">#20710.001 192.168.43.1 -&gt; 192.168.43.191</span>
</code></pre></div></div>

<p>可以看到，这种情况下走的是WiFi网卡，也没问题。</p>

<p>另外，让我们的话题稍微偏一下，还记得刚开始我们只打印程序名字的版本吗？在
上面这种情况下，ICMP请求的程序名字会是ping，而应答包的程序的名字会是WiFi驱动，因
为是驱动发的应答包，至少Linux上是如此。</p>

<p>最后还是拿我最喜欢的例子：ping容器。之所以最喜欢并不是因为Docker，而是它展示了
eBPF的强大，<strong>就像给ping过程做了一次X射线检查</strong>。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># ping -4 172.17.0.2</span>
<span class="o">[</span>  4026531957]          docker0 request <span class="c">#17146.001 172.17.0.1 -&gt; 172.17.0.2</span>
<span class="o">[</span>  4026531957]      vetha373ab6 request <span class="c">#17146.001 172.17.0.1 -&gt; 172.17.0.2</span>
<span class="o">[</span>  4026532258]             eth0 request <span class="c">#17146.001 172.17.0.1 -&gt; 172.17.0.2</span>
<span class="o">[</span>  4026532258]             eth0   reply <span class="c">#17146.001 172.17.0.2 -&gt; 172.17.0.1</span>
<span class="o">[</span>  4026531957]      vetha373ab6   reply <span class="c">#17146.001 172.17.0.2 -&gt; 172.17.0.1</span>
<span class="o">[</span>  4026531957]          docker0   reply <span class="c">#17146.001 172.17.0.2 -&gt; 172.17.0.1</span>
</code></pre></div></div>

<p>来点 ASCII 艺术，就变成：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>       Host netns           | Container netns
+---------------------------+-----------------+
| docker0 <span class="nt">---</span><span class="o">&gt;</span> veth0e65931 <span class="nt">---</span><span class="o">&gt;</span> eth0          |
+---------------------------+-----------------+
</code></pre></div></div>

<h2 id="6-结束语">6 结束语</h2>

<p>在eBPF/bcc出现之前，要深入的排查和追踪很多网络问题，只能靠给内核打补丁。现在，我
们可以比较方便地用eBPF/bcc编写一些工具来完成这些事情。跟踪点(tracepoint)也很方便
，它们提示了我们可以在哪些地方进行探测，避免了去看繁杂的内核代码。kprobe无法探测
的一些地方，例如一些内联函数和静态函数，eBPF/bcc也可以探测。</p>

<p>本文的例子要添加对IPv6的支持也非常简单，我就留给读者作为练习。</p>

<p>如果要使本文更加完善的话，我需要对我们的程序做性能测试。但考虑到文章本身已经非常
长，这里就不做了。</p>

<p>对我们的代码进行改进，用在跟踪路由和iptables判决，或是ARP包，也是很有意思的。
这将会把它变成一个完美的X射线跟踪器，对像我这样需要经常处理复杂网络问题的
人来说将非常有用。</p>

<p>完整的（包含IPv6支持）代码可以访问：
<a href="https://github.com/yadutaf/tracepkt">https://github.com/yadutaf/tracepkt</a>。</p>

<p>最后，我要感谢 <a href="https://twitter.com/fcabestre">@fcabestre</a>帮我将这篇文章的草稿从
一个异常的硬盘上恢复出来，感谢<a href="https://twitter.com/bluxte">@bluxte</a>的耐心审读，
以及技术上使得本文成为可能的<a href="https://github.com/iovisor/bcc">bcc</a>团队。</p>


  <!-- POST NAVIGATION -->
  <div class="postNav clearfix">
     
      <a class="prev" href="/blog/trace-packet-zh-2/"><span>&laquo;&nbsp;[译] 网络包内核路径跟踪：2 Perf</span>
      
    </a>
      
      
      <a class="next" href="/blog/ebpf-turn-syscall-to-event-zh/"><span>[译] eBPF内核探测：如何将任意系统调用转换成事件&nbsp;&raquo;</span>
       
      </a>
     
  </div>
</div>


         

      </div>
   </div><!-- end .content -->

   <div class="footer">
   <div class="container">
      <p class="copy">&copy; 2016-2019
      <a href="https://arthurchiao.github.io">Arthur Chiao</a>, Powered by
      <a href="http://jekyllrb.com">Jekyll </a>, Theme originated from
      <a href="https://github.com/brianmaierjr/long-haul"> Long Haul.</a>

      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
      <span id="busuanzi_container_site_pv"> Site visits:
          <span id="busuanzi_value_site_pv"></span>, powered by<a href="http://busuanzi.ibruce.info/"> busuanzi</a>
      </span>

      </p>

      <div class="footer-links"> 
         <ul class="noList"> 
            
            <li><a href="https://www.facebook.com/profile.php?id=100014334455077">
                  <svg id="facebook-square" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M82.667,1H17.335C8.351,1,1,8.351,1,17.336v65.329c0,8.99,7.351,16.335,16.334,16.335h65.332 C91.652,99.001,99,91.655,99,82.665V17.337C99,8.353,91.652,1.001,82.667,1L82.667,1z M84.318,50H68.375v42.875H50V50h-8.855V35.973 H50v-9.11c0-12.378,5.339-19.739,19.894-19.739h16.772V22.3H72.967c-4.066-0.007-4.57,2.12-4.57,6.078l-0.023,7.594H86.75 l-2.431,14.027V50z"></path>
                  </svg>
            </a></li>
            
            
            <li><a href="https://linkedin.com/in/yanan-zhao-7691317b?trk=hp-identity-photo">
                  <svg id="linkedin" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M99.001,19.428c-3.606,1.608-7.48,2.695-11.547,3.184c4.15-2.503,7.338-6.466,8.841-11.189 c-3.885,2.318-8.187,4-12.768,4.908c-3.667-3.931-8.893-6.387-14.676-6.387c-11.104,0-20.107,9.054-20.107,20.223 c0,1.585,0.177,3.128,0.52,4.609c-16.71-0.845-31.525-8.895-41.442-21.131C6.092,16.633,5.1,20.107,5.1,23.813 c0,7.017,3.55,13.208,8.945,16.834c-3.296-0.104-6.397-1.014-9.106-2.529c-0.002,0.085-0.002,0.17-0.002,0.255 c0,9.799,6.931,17.972,16.129,19.831c-1.688,0.463-3.463,0.71-5.297,0.71c-1.296,0-2.555-0.127-3.783-0.363 c2.559,8.034,9.984,13.882,18.782,14.045c-6.881,5.424-15.551,8.657-24.971,8.657c-1.623,0-3.223-0.096-4.796-0.282 c8.898,5.738,19.467,9.087,30.82,9.087c36.982,0,57.206-30.817,57.206-57.543c0-0.877-0.02-1.748-0.059-2.617 C92.896,27.045,96.305,23.482,99.001,19.428z"></path>
                  </svg>
            </a></li>
            
            
            <li><a href="https://github.com/ArthurChiao">
                  <svg id="github" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M50,1C22.938,1,1,22.938,1,50s21.938,49,49,49s49-21.938,49-49S77.062,1,50,1z M79.099,79.099 c-3.782,3.782-8.184,6.75-13.083,8.823c-1.245,0.526-2.509,0.989-3.79,1.387v-7.344c0-3.86-1.324-6.699-3.972-8.517 c1.659-0.16,3.182-0.383,4.57-0.67c1.388-0.287,2.855-0.702,4.402-1.245c1.547-0.543,2.935-1.189,4.163-1.938 c1.228-0.75,2.409-1.723,3.541-2.919s2.082-2.552,2.847-4.067s1.372-3.334,1.818-5.455c0.446-2.121,0.67-4.458,0.67-7.01 c0-4.945-1.611-9.155-4.833-12.633c1.467-3.828,1.308-7.991-0.478-12.489l-1.197-0.143c-0.829-0.096-2.321,0.255-4.474,1.053 c-2.153,0.798-4.57,2.105-7.249,3.924c-3.797-1.053-7.736-1.579-11.82-1.579c-4.115,0-8.039,0.526-11.772,1.579 c-1.69-1.149-3.294-2.097-4.809-2.847c-1.515-0.75-2.727-1.26-3.637-1.532c-0.909-0.271-1.754-0.439-2.536-0.503 c-0.782-0.064-1.284-0.079-1.507-0.048c-0.223,0.031-0.383,0.064-0.478,0.096c-1.787,4.53-1.946,8.694-0.478,12.489 c-3.222,3.477-4.833,7.688-4.833,12.633c0,2.552,0.223,4.889,0.67,7.01c0.447,2.121,1.053,3.94,1.818,5.455 c0.765,1.515,1.715,2.871,2.847,4.067s2.313,2.169,3.541,2.919c1.228,0.751,2.616,1.396,4.163,1.938 c1.547,0.543,3.014,0.957,4.402,1.245c1.388,0.287,2.911,0.511,4.57,0.67c-2.616,1.787-3.924,4.626-3.924,8.517v7.487 c-1.445-0.43-2.869-0.938-4.268-1.53c-4.899-2.073-9.301-5.041-13.083-8.823c-3.782-3.782-6.75-8.184-8.823-13.083 C9.934,60.948,8.847,55.56,8.847,50s1.087-10.948,3.231-16.016c2.073-4.899,5.041-9.301,8.823-13.083s8.184-6.75,13.083-8.823 C39.052,9.934,44.44,8.847,50,8.847s10.948,1.087,16.016,3.231c4.9,2.073,9.301,5.041,13.083,8.823 c3.782,3.782,6.75,8.184,8.823,13.083c2.143,5.069,3.23,10.457,3.23,16.016s-1.087,10.948-3.231,16.016 C85.848,70.915,82.88,75.317,79.099,79.099L79.099,79.099z"></path>
                  </svg>
            </a></li>
             
            
            <li><a href="mailto:arthurchiao@hotmail.com">
                  <svg id="mail" class="custom-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" style="height: 30px; width: 30px;"><circle class="outer-shape" cx="50" cy="50" r="48" style="opacity: 1;"></circle>
                  <path class="inner-shape" style="opacity: 1;" transform="translate(25,25) scale(0.5)" d="M50,1C22.938,1,1,22.938,1,50s21.938,49,49,49s49-21.938,49-49S77.062,1,50,1z M25.5,25.5h49 c0.874,0,1.723,0.188,2.502,0.542L50,57.544L22.998,26.041C23.777,25.687,24.626,25.499,25.5,25.5L25.5,25.5z M19.375,68.375v-36.75 c0-0.128,0.005-0.256,0.014-0.383l17.96,20.953L19.587,69.958C19.448,69.447,19.376,68.916,19.375,68.375L19.375,68.375z M74.5,74.5 h-49c-0.541,0-1.072-0.073-1.583-0.212l17.429-17.429L50,66.956l8.653-10.096l17.429,17.429C75.572,74.427,75.041,74.5,74.5,74.5 L74.5,74.5z M80.625,68.375c0,0.541-0.073,1.072-0.211,1.583L62.652,52.195l17.96-20.953c0.008,0.127,0.014,0.255,0.014,0.383 L80.625,68.375L80.625,68.375z"></path>
                  </svg>
            </a></li>
            
         </ul>
      </div>
   </div>
</div><!-- end .footer -->

   <!-- Add jQuery and other scripts -->
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src=""><\/script>')</script>
<script src="/assets/js/dropcap.min.js"></script>
<script src="/assets/js/responsive-nav.min.js"></script>
<script src="/assets/js/scripts.js"></script>


</body>

</html>
